<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dw's 小站</title><link>https://dwye.dev/</link><description>Recent content on dw's 小站</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 22 Dec 2021 20:41:23 +0800</lastBuildDate><atom:link href="https://dwye.dev/" rel="self" type="application/rss+xml"/><item><title>在 GitHub Action 優化 Node.js App 的環境建置</title><link>https://dwye.dev/post/github-action-npm-cache/</link><pubDate>Wed, 22 Dec 2021 20:41:23 +0800</pubDate><guid>https://dwye.dev/post/github-action-npm-cache/</guid><description>
&lt;p>身為一位維護公司內部建置與發佈工具的工程師，建立方便又有效率的 CI/CD 工具來建置與測試產品，並且為產品的穩定性把關，一直是我們團隊的重要目標。不過我們對待自己的內部工具常常比產品來得隨便&amp;hellip;所以在我和主管聊過之後，決定慢慢幫我們的內部工具也來建立一些自動化的測試以及部署。&lt;/p>
&lt;p>內部工具說穿了就是個 Node.js 的應用程式。身為 YAML 工程師的我當然是用自己最熟悉的 GitHub Action 來實作。&lt;/p>
&lt;h2 id="從最簡單的版本開始">從最簡單的版本開始&lt;/h2>
&lt;p>下面是一個最簡單的 Node.js 專案所使用的單元測試的 GitHub Action 的 YAML 設定：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Unit test&lt;/span>
&lt;span style="color:#f92672">on&lt;/span>: &lt;span style="color:#ae81ff">push&lt;/span>
&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;span style="color:#f92672">unit-test&lt;/span>:
&lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-latest&lt;/span>
&lt;span style="color:#f92672">steps&lt;/span>:
- &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/checkout@v2&lt;/span>
- &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/setup-node@v2&lt;/span>
&lt;span style="color:#f92672">with&lt;/span>:
&lt;span style="color:#f92672">node-version&lt;/span>: &lt;span style="color:#ae81ff">16.13.1&lt;/span>
- &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">npm install&lt;/span>
- &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">npm run test&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這份 YAML 簡單又白話。使用 &lt;code>actions/checkout&lt;/code> 拿到最新版的 Code，並使用 &lt;code>actions/setup-node&lt;/code> 設置 Node.js 環境。這兩個都是 GitHub 官方的 actions，簡單方便。然後使用 &lt;code>npm install&lt;/code> 指令安裝套件，接著跑我們自定義的測試腳本 &lt;code>npm run test&lt;/code>（註：記得換成你自己的測試指令）。&lt;/p>
&lt;p>其實如果不要要求太多，這樣就已經完成了，因此這次的分享就到這裡告一段落。&lt;/p>
&lt;h2 id="還能做得更好嗎">還能做得更好嗎？&lt;/h2>
&lt;p>&amp;hellip;才怪，如果只是這樣，才不值得寫一篇文章 XD&lt;/p>
&lt;p>如果你的套件很多，每次都要跑 &lt;code>npm install&lt;/code> 會變成一個拖累你的 CI 速度的惡夢，測試如果不是簡單又快速，就會降低開發人員對於測試的關注，這絕對不是一件好事。&lt;/p>
&lt;h2 id="優化環境建置速度">優化環境建置速度&lt;/h2>
&lt;h3 id="actionssetup-node-的內建優化">Actions/setup-node 的內建優化&lt;/h3>
&lt;p>其實 &lt;code>actions/setup-node&lt;/code> 的文件就有寫到，他們有內建的 cache （快取）機制，可以透過將 &lt;code>package-lock.json&lt;/code> 或是 &lt;code>yarn.lock&lt;/code> 內的 dependency 做快取：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml"> - &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/setup-node@v2&lt;/span>
&lt;span style="color:#f92672">with&lt;/span>:
&lt;span style="color:#f92672">node-version&lt;/span>: &lt;span style="color:#ae81ff">16.13.1&lt;/span>
&lt;span style="color:#f92672">cache&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;npm&amp;#39;&lt;/span>
- &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">npm install&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>就是這麼簡單，更詳細用法可以查看 &lt;code>actions/setup-node&lt;/code> 的文件（https://github.com/actions/setup-node）。&lt;/p>
&lt;p>值得注意的是，這邊的 cache 對象是 &lt;code>.npm&lt;/code> 的資料夾，而不是 &lt;code>node_modules&lt;/code>，所以即便有 cache 了，在跑 &lt;code>npm install&lt;/code> 時還是有可能會需要下載與安裝一些 package。&lt;/p>
&lt;h3 id="使用-npm-ci">使用 NPM CI&lt;/h3>
&lt;p>我也是在這次建置中才注意到這個酷功能的：&lt;br>
&lt;a href="https://docs.npmjs.com/cli/v8/commands/npm-ci">https://docs.npmjs.com/cli/v8/commands/npm-ci&lt;/a>&lt;/p>
&lt;p>&lt;code>npm ci&lt;/code> 顧名思義，是給 CI 用的 &lt;code>npm install&lt;/code>，專注於安裝套件的效率，跑起來比 &lt;code>node_modules&lt;/code> 快&lt;strong>非常多&lt;/strong>。加速的方法是透過避免掉一些平常在 &lt;code>npm install&lt;/code> 時會處理的套件相依問題，略過需要傳遞給開發者的訊息。&lt;code>npm ci&lt;/code> 唯一需要做的事，就是根據 &lt;code>package-lock.json&lt;/code> 安裝套件。&lt;/p>
&lt;p>我自己實測，可以把我們的專案的安裝時間從 3 分又幾秒降低到 45 秒附近，足足提升了 4 倍，真的誇張。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml"> - &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/setup-node@v2&lt;/span>
&lt;span style="color:#f92672">with&lt;/span>:
&lt;span style="color:#f92672">node-version&lt;/span>: &lt;span style="color:#ae81ff">16.13.1&lt;/span>
&lt;span style="color:#f92672">cache&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;npm&amp;#39;&lt;/span>
- &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">npm ci&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其實做到這邊就可以停了，但不禁還是想問，還能再更快嗎？總覺得每次跑 &lt;code>npm ci&lt;/code> 還要重新安裝一遍套件，重新建立 &lt;code>node_modules&lt;/code> 有點花時間。&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/faster.jpg" alt="還要更快">&lt;/p>
&lt;h2 id="邪門加速法cache-node_modules">邪門加速法：Cache node_modules&lt;/h2>
&lt;p>大哉問：為何不直接 Cache node_modules 就好呢？&lt;/p>
&lt;p>可以參考前人的討論：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Actions/cache&lt;/code> 的&lt;a href="https://github.com/actions/cache/issues/67">issue #67&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/42521884/">StackOverflow: Should I have Travis cache node_modules or $HOME/.npm&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>我的理解是，當需要使用不同 Node.js / npm / OS 版本時，Cache node_modules 因為包含了一些針對特定環境編譯過的 packages，所以會在環境稍微不同時就造成問題。對 &lt;code>.npm&lt;/code> 做快取並不會讓 CI 速度變慢太多，但卻穩定很多，因此像是 GitHub Action / Travis 或 Azure 會預設對 &lt;code>.npm&lt;/code> 做快取，減少不懂的人遇到問題的機會 XD&lt;/p>
&lt;p>換個想法，如果我盡量使環境一致，把 Node.js 和 OS 版本都納入 cache key，環境有變動就讓 cache miss，這樣在大部分情況應該就能避免上述的問題，並且更加速 CI 的環境建置。&lt;/p>
&lt;h3 id="npm-ci-的陷阱">NPM CI 的陷阱&lt;/h3>
&lt;p>但還有個問題： &lt;code>npm ci&lt;/code> 永遠都會先把 node_modules 刪掉再安裝一遍 packages（我想也是為了避免檢查目前已有的套件的正確性而做的優化）&lt;/p>
&lt;p>因此 &lt;code>npm ci&lt;/code> 不能和 cache node_modules 一起使用嗎？那就大錯特錯了 XD&lt;br>
如果我們把 node_modules 快取起來，並且確認 &lt;code>package-lock.json&lt;/code> 和 node version 等因素都沒有改變，那就不必重新跑一遍 &lt;code>npm ci&lt;/code> 了啊，直接跑測試就行了。&lt;br>
可以利用查看 node_modules 是否存在來判斷 cache hit 或 miss:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">test -d node_modules &lt;span style="color:#75715e"># 查看資料夾是否存在，把結果存入 $?&lt;/span>
echo $? &lt;span style="color:#75715e"># 0 代表存在，1 代表不存在&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="加入-cache-node_modules-並使用-npm-ci-後">加入 cache node_modules 並使用 npm ci 後：&lt;/h3>
&lt;p>因為變更有點多，這邊再次附上完整 YAML：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Unit test&lt;/span>
&lt;span style="color:#f92672">on&lt;/span>: &lt;span style="color:#ae81ff">push&lt;/span>
&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;span style="color:#f92672">unit-test&lt;/span>:
&lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-latest&lt;/span>
&lt;span style="color:#f92672">strategy&lt;/span>:
&lt;span style="color:#f92672">matrix&lt;/span>:
&lt;span style="color:#f92672">node-version&lt;/span>: [&lt;span style="color:#ae81ff">16.13.1&lt;/span>] &lt;span style="color:#75715e"># 把 node.js 版本記錄在這，之後可以重新取出作為 cache key&lt;/span>
&lt;span style="color:#f92672">steps&lt;/span>:
- &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/checkout@v2&lt;/span>
- &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/setup-node@v2&lt;/span>
&lt;span style="color:#f92672">with&lt;/span>:
&lt;span style="color:#f92672">node-version&lt;/span>: &lt;span style="color:#ae81ff">${{ matrix.node-version }}&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Cache Node Modules&lt;/span>
&lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/cache@v2&lt;/span>
&lt;span style="color:#f92672">with&lt;/span>:
&lt;span style="color:#f92672">path&lt;/span>: &lt;span style="color:#ae81ff">node_modules&lt;/span>
&lt;span style="color:#75715e"># cache key 包含了所有我們希望固定的資訊：OS，node 版本，以及 package-lock.json 的檔案內容，使用 hashFiles 將檔案內容轉換成字串&lt;/span>
&lt;span style="color:#f92672">key&lt;/span>: &lt;span style="color:#ae81ff">node-modules-${{ runner.os }}-${{ matrix.node-version }}-${{ hashFiles(&amp;#39;package-lock.json&amp;#39;) }}&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Install Packages&lt;/span>
&lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">test -d node_modules &amp;amp;&amp;amp; echo &amp;#34;node_modules exists&amp;#34; || npm ci&lt;/span>
- &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">npm run test&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>透過 cache node_modules 後，建置時間大幅縮短，原本需要跑 3 分鐘才能建置完成的 CI，現在只需要 10 秒就可以跑建置部分了。即便是 cache miss，也能在 45 秒附近完成套件的安裝，可說是十分有效的優化，成就感十足。&lt;/p>
&lt;p>接下來要做的事情就是慢慢補上 unit test 了&amp;hellip;。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>DeskMini X300 組裝紀錄</title><link>https://dwye.dev/post/deskmini-installation/</link><pubDate>Sat, 25 Sep 2021 17:42:23 +0800</pubDate><guid>https://dwye.dev/post/deskmini-installation/</guid><description>
&lt;h2 id="契機">契機&lt;/h2>
&lt;p>因為家母還在用我淘汰已久的舊電腦，有各種奇怪的問題，包含卡鍵或是滑鼠失靈、鍵盤連點之類的，對於電腦不太熟悉的家母來說要應付這些問題十分困難，而每次我都要出手去查出是什麼奇怪問題也很麻煩。&lt;/p>
&lt;p>也正很很久沒有組電腦了，就上參考 PTT 上原價屋抓菜單，後來發現華擎的 DeskMini 這個可以自己選配內部組件的迷你主機，就覺得蠻有趣的，整個配起來價格也可以接受，不會和市面上的迷你電腦差太多（有的文書機真的便宜的很誇張ˊˋ），性能需求也可以自己掌控，就下單買來組了。&lt;/p>
&lt;p>原本還懶惰想說交給原價屋組就好，只是原價屋那邊說，讓他們組裝的話，因為最近訂單多，要延後兩個禮拜才能出貨（是什麼換購電腦潮嗎，是說這時間點附近好像也是出生潮 XD），所以就選擇自己組裝了。&lt;/p>
&lt;h2 id="菜單">菜單&lt;/h2>
&lt;p>姑且列一下選購內容：&lt;/p>
&lt;ul>
&lt;li>機殼/主機板/電供等: DeskMini X300&lt;/li>
&lt;li>CPU: AMD Athlon 3000G&lt;/li>
&lt;li>RAM: 金士頓 NB 8GB DDR4-3200 (KVR32S22S8/8)&lt;/li>
&lt;li>SSD: WD 藍標 SN550 500G/M.2 PCIe&lt;/li>
&lt;li>無線網卡: 華擎 DeskMini WiFi+BT4.2無線模組 (M.2 Key E 2230)&lt;/li>
&lt;/ul>
&lt;p>總價 10460 元。&lt;/p>
&lt;p>除了 CPU 是 AMD 系列初階（但也已經有一定水平），RAM 和 SSD 其實並不是基礎水平。&lt;br>
記憶體部分，我自己筆電 8G 記憶體也是略嫌不夠，覺得不選到 8G 會太小，而選擇 3200 而不是基本的 2666，則是我覺得價格沒差很多就順便升上去了&amp;hellip;（但這個順便其實意外的很花錢又是另一回事了 XD）。&lt;br>
開機碟選擇 SSD 應該是現在的基本配備了，支援 M.2 就選 M.2，而 250 GB 和 500 GB 價格又沒差太多，所以就這樣選了，反正只是個 WD 藍標（結果總共好像比「順便」升了不少 XD）。&lt;/p>
&lt;p>無線網卡的部分是選購的，未雨綢繆，反正也 1000 有找，就直接先買一組，以後如果要接 wifi 或藍芽之類的也方便。&lt;/p>
&lt;h2 id="組裝">組裝&lt;/h2>
&lt;h3 id="開箱">開箱&lt;/h3>
&lt;p>&lt;img src="https://dwye.dev/img/deskmini/before.jpg" alt="before">&lt;/p>
&lt;p>打開寄來的包裹，能看到的零組件就是這些，其實還蠻簡單的，因為 DeskMini 不需要自己選購電源供應器，也不需要太強大的負荷因此不用額外加裝散熱。&lt;/p>
&lt;h3 id="cpu">CPU&lt;/h3>
&lt;p>組裝方式不用太煩惱，DeskMini 有附上蠻清楚的說明書，照著做就行了。因此第一個是裝上 CPU。AMD 的 CPU 我已經裝過好幾顆了（曾經壓壞一顆 CPU 的腳又是另一個故事了 ˊˋ），自然是熟能生巧：&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/deskmini/cpu.jpg" alt="cpu">&lt;/p>
&lt;p>DeskMini 和 Athlon 都各附了一顆風扇，兩顆看起來基本上一模一樣。因為不是特別在意散熱，我就沒特別研究哪顆比較好，反正就挑一顆裝：&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/deskmini/fan.jpg" alt="fan">&lt;/p>
&lt;h3 id="ram">RAM&lt;/h3>
&lt;p>原本以為卡榫打開，壓下去就沒事了，結果發現壓了半天他都沒有卡進去。一度懷疑自己是不是買錯記憶體，但的確是筆電記憶體 SO-DIMM DDR4。直到我查到別篇在巴哈組裝別的電腦的文，也有人說記憶體插不進去，底下就有人說：&lt;/p>
&lt;blockquote>
&lt;p>大力出奇蹟&lt;/p>
&lt;/blockquote>
&lt;p>嗯，只要確定規格正確，插入方向正確，接下來就是不夠用力的問題了吧。&lt;/p>
&lt;p>接下來我就使出真的是吃奶的力氣，因為 Deskmini 的主機板的支撐在兩側，下方離底盤有段空隙，這樣壓讓我懷疑主機板會不會被我折斷，但記憶體還是卡在那。後來索性直接拿螺絲起子頂住主機版下方輔助，再次用力推，終於慢慢進去了。真的是大力出奇蹟。&lt;/p>
&lt;p>沒有插不進去，只是不夠大力。&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/deskmini/memory.jpg" alt="memory">&lt;/p>
&lt;p>有人說 DeskMini 組裝簡單，但這步驟我還是花了我幾十分鐘嘗試和確認&amp;hellip;真的怕會把主機板或記憶體折斷ˊˋ。&lt;/p>
&lt;h3 id="無線網路模組">無線網路模組&lt;/h3>
&lt;p>因為這張網卡要裝在 M.2 SSD 插槽底下，所以勢必要在 SSD 之前先裝上去。&lt;/p>
&lt;p>有個小訣竅是兩條天線模組可以先接到網卡，再把網卡裝到主機板，會比先裝網卡再接天線模組容易很多，畢竟主機板很卡手，不是很好處理小小的天線模組的接口。&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/deskmini/wifi.jpg" alt="wifi module 1">&lt;/p>
&lt;p>天線模組的另一頭就是要接上天線本人。DeskMini 主機殼後方有幾個黑色圈圈可以取下，但也不是很容易取下（蠻緊的），我是先用螺絲起子硬戳下去，讓黑色圈圈半脫落，然後再用撬的把剩下的連接處撬開。&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/deskmini/wifi2.jpg" alt="wifi module 2">&lt;/p>
&lt;h3 id="ssd">SSD&lt;/h3>
&lt;p>最簡單的一部分，插進去、鎖螺絲，沒了。&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/deskmini/ssd.jpg" alt="ssd">&lt;/p>
&lt;h2 id="成品">成品&lt;/h2>
&lt;p>最後把主機板裝回去，天線鎖上，就大功告成了：&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/deskmini/after1.jpg" alt="finish!">&lt;/p>
&lt;p>真的蠻迷你一台的。&lt;/p>
&lt;p>下面是完工後服役中的圖：&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/deskmini/after2.jpg" alt="finish!">&lt;/p>
&lt;h2 id="os">OS&lt;/h2>
&lt;p>作業系統的部分，因為已經不是學生了，沒辦法取得免費的 Windows 10，對於不太熟系電腦也不玩遊戲的家母來說，不需要 Windows 應該也沒關係吧？反正就讓她上網就可以了。&lt;/p>
&lt;p>所以我就大膽嘗試了 &lt;a href="https://linuxmint.com/">Linux Mint&lt;/a> 作為作業系統，基於 ubuntu 並且有比較接近 Windows 系列的 UI，當然也支援繁體中文。&lt;/p>
&lt;p>當然，我也做了一些調整，把自動更新關掉，畫面字體調大，還有輸入法切換改成 shift 等等：&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/deskmini/mint.jpg" alt="Mint">&lt;/p>
&lt;p>希望這台電腦可以解決一些我生活上的 &lt;a href="https://sre.google/sre-book/eliminating-toil/">Toil&lt;/a>，SRE 精神嘛 XD&lt;br>
組電腦也是一種用工程解決重複問題，大概吧。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Git Checkout / Switch / Restore 比較</title><link>https://dwye.dev/post/git-checkout-switch-restore/</link><pubDate>Tue, 14 Sep 2021 13:41:25 +0800</pubDate><guid>https://dwye.dev/post/git-checkout-switch-restore/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>git checkout 原本的功能有：&lt;/p>
&lt;ul>
&lt;li>切換分支&lt;/li>
&lt;li>檔案管理&lt;/li>
&lt;/ul>
&lt;p>雖然兩者只是一個功能的一體兩面（從特定分支拿取特定檔案），但大多時候我們使用的時候會避免在一個指令進行太多邏輯操作，所以大多都只用到切換分支或是檔案管理其中一個。&lt;br>
而且說實在，&lt;code>checkout&lt;/code> 一個檔案實在不是一個語意上很直觀的說法。&lt;/p>
&lt;p>因此在 2019 年底的 git 2.23 版本，釋出了兩個新指令：&lt;code>git switch&lt;/code> 和 &lt;code>git restore&lt;/code>，來切分 &lt;code>git checkout&lt;/code> 的龐大工作量。&lt;/p>
&lt;p>從名稱就可以大略知道：&lt;/p>
&lt;ul>
&lt;li>&lt;code>git switch&lt;/code> 是用來切換分支&lt;/li>
&lt;li>&lt;code>git restore&lt;/code> 是用來管理檔案&lt;/li>
&lt;/ul>
&lt;h2 id="新舊指令對照">新舊指令對照&lt;/h2>
&lt;h3 id="git-switch">Git Switch&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># 切換分支&lt;/span>
git checkout &amp;lt;branch&amp;gt;
git switch &amp;lt;branch&amp;gt;
&lt;span style="color:#75715e"># 強制切換分支（=切換 + reset --hard，丟棄所有變更）&lt;/span>
git checkout -f &amp;lt;branch&amp;gt;
git switch -f &amp;lt;branch&amp;gt;
&lt;span style="color:#75715e"># 切換 commit（d: detach，會讓 HEAD 進入到非分支的狀態）&lt;/span>
git checkout &amp;lt;hash&amp;gt;
git switch -d &amp;lt;hash&amp;gt;
&lt;span style="color:#75715e"># 創建分支，並切換過去&lt;/span>
git checkout -b &amp;lt;new_branch&amp;gt;
git switch -c &amp;lt;new_branch&amp;gt; &lt;span style="color:#75715e"># c for create&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="git-restore">Git Restore&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># 復原工作區的檔案&lt;/span>
git checkout -- some_file
git restore some_file
git restore --worktree some_file &lt;span style="color:#75715e"># (a)&lt;/span>
&lt;span style="color:#75715e"># 取消 add，從暫存區移出&lt;/span>
git reset -- some_file
git restore --staged -- some_file &lt;span style="color:#75715e"># (b)&lt;/span>
&lt;span style="color:#75715e"># 復原暫存區檔案&lt;/span>
git checkout HEAD -- some_file
git restore --staged --worktree main test.txt &lt;span style="color:#75715e"># (a) + (b)，一次走兩步&lt;/span>
&lt;span style="color:#75715e"># 從別的 commit 拿檔案&lt;/span>
git checkout &amp;lt;hash/branch&amp;gt; -- some_file
git restore -s &amp;lt;hash/branch&amp;gt; some_file &lt;span style="color:#75715e"># s for source&lt;/span>
&lt;span style="color:#75715e"># 互動式復原：-p&lt;/span>
git checkout -p -- some_file
git restore -p some_file
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="小結">小結&lt;/h2>
&lt;p>可以發現新的兩個指令和 &lt;code>checkout&lt;/code> 比較大的差異分別是：&lt;/p>
&lt;ul>
&lt;li>&lt;code>git switch&lt;/code> 把對於特定 commit hash 的切換放進了 &lt;code>-d&lt;/code> option 內&lt;/li>
&lt;li>&lt;code>git restore&lt;/code> 可以直接接受檔案作為 input，不用加上 &lt;code>--&lt;/code>，但代價就是指定分支時需要塞到 &lt;code>-s&lt;/code> 選項內&lt;/li>
&lt;/ul>
&lt;p>習慣使用 &lt;code>checkout&lt;/code> 的，可以繼續使用，但我覺得 &lt;code>switch&lt;/code> 和 &lt;code>restore&lt;/code> 蠻推薦給初學者使用的，學習門檻比複雜的 &lt;code>checkout&lt;/code> 本身低很多。&lt;/p>
&lt;p>（但其實一般初學者可能也只知道 &lt;code>git checkout&lt;/code> 的切換分支功能吧 XD）&lt;/p>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://yanhaijing.com/git/2020/09/17/git-switch-and-restore/">Git 新命令 switch 和 restore&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.banterly.net/2021/07/31/new-in-git-switch-and-restore/">New in Git: switch and restore&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/Sweet_19BaBa/article/details/111950384">一次搞清 git checkout，git restore 和 git reset&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="官方文件">官方文件&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://git-scm.com/docs/git-checkout">git checkout&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git-scm.com/docs/git-switch">git switch&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git-scm.com/docs/git-restore">git restore&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/git/git/blob/master/Documentation/RelNotes/2.23.0.txt">git v2.23.0 release note&lt;/a>\&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>我的 Node.js Process 怎麼不會結束？</title><link>https://dwye.dev/post/node-event-loop-and-termination/</link><pubDate>Tue, 07 Sep 2021 16:13:25 +0800</pubDate><guid>https://dwye.dev/post/node-event-loop-and-termination/</guid><description>
&lt;p>工作時碰到了某個以 Node.js 撰寫的 scheduled job（排程工作）一直保持在 running 的狀態，永遠不會進到 complete。這時一般首先想到的是，程式可能在某個地方卡住了，進入無窮等待（像是進入無限迴圈一樣）。&lt;/p>
&lt;p>一開始我試著使用懶人 debug 方法：加入幾個 &lt;code>console.log&lt;/code> 看看 code 是跑到哪裡停住了。&lt;br>
結果，到程式碼最後一個 &lt;code>console.log&lt;/code> 也有被執行到。&lt;br>
但程式依然沒有結束。&lt;/p>
&lt;p>如果你是個對 JavaScript 這個語言的運行機制很熟的人，馬上就知道這問題在哪了。&lt;/p>
&lt;p>但因為我在這之前我寫的都是其他語言，JavaScript 頂多看看語法差異就上陣了，也因此忽略了 JavaScript 一個很重要的特性：&lt;/p>
&lt;h2 id="event-loop">Event Loop&lt;/h2>
&lt;p>Event Loop 其實就是 JavaScript 執行 Asynchronous 程式碼片段的方式：&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/eventLoop.jpg" alt="simplified event loop">&lt;/p>
&lt;p>當 Node.js 執行程式時，會把主程式先執行完。這之間碰到 async code 的話，會將 &lt;strong>async code 交給另外的 worker&lt;/strong> 處理，並在 queue 註冊 callback，主程式則繼續往下進行。&lt;br>
之後就會進入 Event Loop 不斷的監聽 callback，若有 worker 完成，則會將 callback 交給主程式執行。&lt;/p>
&lt;p>也因此，Node.js 的 async functions 不會 block 主程式進行，而會丟給背後的 worker 來跑。Worker 和主程式不一樣，&lt;strong>可以是多個 Threads&lt;/strong>，可以達到平行化，也因此 Node.js 鼓勵使用 asynchronous 的方式撰寫。&lt;/p>
&lt;p>註：這是我個人簡化後的版本，若有觀念上的錯誤歡迎指正。&lt;/p>
&lt;h2 id="quick-example">Quick Example&lt;/h2>
&lt;p>這算是蠻經典的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// index.js
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">setTimeout&lt;/span>(() =&amp;gt; &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;callback&amp;#39;&lt;/span>), &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;end of code&amp;#39;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">❯ node index.js
end of code
callback
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因為 &lt;code>setTimeout&lt;/code> 是 async，會註冊 callback，即便等待時間是 0，也會在主程式跑完後才執行。這也是我一開始 debug 的方法沒成功的原因。&lt;/p>
&lt;h2 id="回到正題我的-nodejs-process-怎麼不會結束">回到正題：我的 Node.js Process 怎麼不會結束？&lt;/h2>
&lt;p>就是有 worker 還在工作，導致 &lt;strong>event loop 一直在等 callback 可以被放進 call stack&lt;/strong>。&lt;/p>
&lt;h3 id="找出兇手">找出兇手&lt;/h3>
&lt;p>既然知道原因了，下一步就是找出是哪個 async code 沒有結束一直在等待。&lt;/p>
&lt;p>Node.js 有兩個一直沒有被官方列入文件的方法，可以快速查看現在還在 queue 等待的 work 有哪些：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">process&lt;/span>.&lt;span style="color:#ae81ff">_&lt;/span>&lt;span style="color:#a6e22e">getActiveHandles&lt;/span>())
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">process&lt;/span>.&lt;span style="color:#ae81ff">_&lt;/span>&lt;span style="color:#a6e22e">getActiveRequests&lt;/span>())
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這兩個底線開頭的方法直到最近還有 &lt;a href="https://github.com/nodejs/node/issues/36036">issue&lt;/a> 在討論要不要加入文件，但看起來就是無限延長，畢竟這個方法印出的結果也是蠻冗長的，包含了很多給人類 debug 時不需要的資訊。&lt;/p>
&lt;p>因此我找到了一個 package：&lt;/p>
&lt;h3 id="why-is-node-running">Why Is Node Running&lt;/h3>
&lt;p>&lt;a href="https://github.com/mafintosh/why-is-node-running">why-is-node-running&lt;/a> 是一個利用 Node.js 實驗中的 &lt;a href="https://nodejs.org/api/async_hooks.html">Async Hooks API&lt;/a> 撰寫的 library，可以幫你調查你的 Node.js 程式為什麼不會結束。&lt;/p>
&lt;p>原理是在 &lt;code>require&lt;/code> 時，利用 side effects 註冊一些 Async Hooks，這樣當 async code 被執行時，這個 module 就會知道，也可以因此監聽有哪些 Code 沒結束。&lt;/p>
&lt;p>用法也蠻簡單的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">log&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;why-is-node-running&amp;#39;&lt;/span>) &lt;span style="color:#75715e">// 一定要一開始就 require，讓 side effects 優先執行
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#a6e22e">setInterval&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> () {}, &lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;span style="color:#a6e22e">log&lt;/span>() &lt;span style="color:#75715e">// 印出目前還沒有結束的 work
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">❯ node index.js
There are 1 handle(s) keeping the process running
# Timeout
/Users/davidye/Projects/node_running/index.js:3 - setInterval(function () {}, 1000)
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;p>實際上關於 Event Loop 還有很多細節，也有很多已經寫得不錯的文章，列在下方給大家做為參考。&lt;/p>
&lt;h3 id="官方關於-event-loop-的說明文件">官方關於 Event Loop 的說明文件&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">The Node.js Event Loop, Timers, and process.nextTick() | Node.js&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/">Don&amp;rsquo;t Block the Event Loop (or the Worker Pool)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://nodejs.dev/learn/the-nodejs-event-loop">The Node.js Event Loop&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="event-loop-好文">Event Loop 好文&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://blog.huli.tw/2019/10/04/javascript-async-sync-and-callback/">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://notes.andywu.tw/2020/%E5%AE%8C%E6%95%B4%E5%9C%96%E8%A7%A3node-js%E7%9A%84event-loop%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88/">完整圖解 Node.js 的 Event Loop (事件迴圈)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yu-jack.github.io/2021/03/14/node-event-loop/">Event Loop 運行機制解析 - Node.js 篇&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.eebreakdown.com/2016/09/nodejs-eventemitter.html">非同步程式碼之霧：Node.js 的事件迴圈與 EventEmitter&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="其他參考資料">其他參考資料&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/7698834">How does a node.js process know when to stop?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/17960452">How can I get a list of callbacks in the Node work queue? (or, Why won&amp;rsquo;t Node exit?)&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Git 小技巧</title><link>https://dwye.dev/post/git-tricks/</link><pubDate>Wed, 01 Sep 2021 13:41:25 +0800</pubDate><guid>https://dwye.dev/post/git-tricks/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;h3 id="原來-git-比想像中的易學難精">原來 Git 比想像中的易學難精&lt;/h3>
&lt;p>剛開始學 git，我是隨便買了一本薄薄的書，然後跟著裡面的內容照著跑，就把 git 的基礎學起來了，例如說暫存區、分支、commit、tag、push 等等&lt;br>
曾經我以為這樣就算學會 git 了，我也這樣用 git 用了一兩年，直到有一天在實習的公司被問到說&lt;/p>
&lt;blockquote>
&lt;p>你會用 Git？那你會用 rebase 嗎？&lt;/p>
&lt;/blockquote>
&lt;p>&amp;hellip;那是什麼？&lt;/p>
&lt;blockquote>
&lt;p>不會 rebase 的話就不算會 Git 喔&lt;/p>
&lt;/blockquote>
&lt;p>所以趕快去把 rebase 學起來。&lt;br>
哦哦，rebase 就是把一個分支搬到另一個分支上面，來讓歷史紀錄變得漂亮嘛，讓大家都像是從 develop 長出來的一樣。&lt;/p>
&lt;p>這下好了，我會 rebase 了，我總算能打遍天下無敵手了吧。&lt;/p>
&lt;p>後來到第二間公司實習，主管說，自己 commit 很醜沒關係，但你在推出去之前要把自己的 commit 修一下&lt;/p>
&lt;blockquote>
&lt;p>要會用 rebase 修剪 commit，不然就不算是會 rebase&lt;/p>
&lt;/blockquote>
&lt;p>原來我 rebase 還沒學完嗎？&lt;/p>
&lt;p>因為第二間公司有圖書館，我就趁沒事的時候在圖書館逛逛有什麼書，就找到了好像近幾年蠻有名的「為你自己學 Git」，寫的淺顯易懂，即便是已經會一些 git 基本操作的人，也能夠學到一些東西，十分推薦給大家看（無業配）。當然還看了不少相關書籍與網路文章，感受到其實 git 有很多很方便的進階用法，也所以才有這篇文章。&lt;/p>
&lt;h2 id="git-的檔案分區">Git 的檔案分區&lt;/h2>
&lt;p>雖然會使用指令，但其實一開始我並不了解每個階段的名稱，因此在此附上：&lt;/p>
&lt;ul>
&lt;li>工作目錄&lt;/li>
&lt;li>暫存區 Stage&lt;/li>
&lt;li>儲存庫 Repository&lt;/li>
&lt;/ul>
&lt;p>&lt;code>git add&lt;/code> 從工作目錄把變更加到暫存區&lt;br>
&lt;code>git commit&lt;/code> 提交，把暫存區的變更加入儲存庫，正式納入版本管理&lt;/p>
&lt;h2 id="config">Config&lt;/h2>
&lt;p>常用的兩個 config 檔案：&lt;/p>
&lt;ul>
&lt;li>&lt;code>--global&lt;/code>：user 層級的，一般放在 &lt;code>~/.gitconfig&lt;/code>&lt;/li>
&lt;li>&lt;code>--local&lt;/code>：repo 層級，放在 &lt;code>.git/config&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>local 會優先&lt;/p>
&lt;p>使用 &lt;code>git config -l&lt;/code> 快速查看設定，也可以搭配 &lt;code>--global&lt;/code> 之類的 flag，只查看某層級的設定&lt;/p>
&lt;h3 id="預設編輯器">預設編輯器&lt;/h3>
&lt;p>以 VSCode 為例：&lt;/p>
&lt;pre>&lt;code>git config --global core.editor &amp;quot;code --wait&amp;quot;
&lt;/code>&lt;/pre>&lt;p>記得先裝 &lt;a href="https://code.visualstudio.com/docs/editor/command-line">VSCode Command Line Tool&lt;/a>&lt;/p>
&lt;h3 id="在編輯器修改-config">在編輯器修改 config&lt;/h3>
&lt;p>&lt;code>git config -e&lt;/code>&lt;/p>
&lt;p>像我習慣把編輯器設定為 VSCode，就可以直接打開 &lt;code>.git/config&lt;/code>，很方便&lt;/p>
&lt;h2 id="stage-相關操作">Stage 相關操作&lt;/h2>
&lt;h3 id="加錯檔案">加錯檔案&lt;/h3>
&lt;p>如果用 &lt;code>git rm&lt;/code> 也會把檔案砍掉，因為其實 &lt;code>git rm&lt;/code> = &lt;code>rm&lt;/code> + &lt;code>git add&lt;/code>&lt;br>
改用 &lt;code>git rm --cached&lt;/code> 就可以不砍掉檔案，單純移出暫存區&lt;/p>
&lt;p>同理&lt;/p>
&lt;p>&lt;code>git mv&lt;/code> = &lt;code>mv&lt;/code> + &lt;code>git add&lt;/code> 前後兩個檔名&lt;/p>
&lt;h3 id="不想要檔案變更回到修改前狀態">不想要檔案變更（回到修改前狀態）&lt;/h3>
&lt;p>用 &lt;code>checkout&lt;/code> 抵銷：&lt;/p>
&lt;p>&lt;code>git checkout -- &amp;lt;file&amp;gt;&lt;/code>：只復原工作區&lt;br>
&lt;code>git checkout HEAD -- &amp;lt;file&amp;gt;&lt;/code>：連暫存區也復原，相當於 &lt;code>git reset --hard -- &amp;lt;file&amp;gt;&lt;/code>&lt;/p>
&lt;p>同理也可以拿取特定分支檔案&lt;/p>
&lt;p>&lt;code>git checkout &amp;lt;hash/branch&amp;gt; -- &amp;lt;file&amp;gt;&lt;/code>&lt;/p>
&lt;p>同理，可以用 &lt;code>git checkout &amp;lt;hash/branch&amp;gt; -f&lt;/code> 硬切分支，會同時取消所有的變更！&lt;/p>
&lt;h3 id="gitignore-忽略的檔案又想要加入版本控制">&lt;code>.gitignore&lt;/code> 忽略的檔案又想要加入版本控制&lt;/h3>
&lt;p>兩個方法：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在 &lt;code>.gitignore&lt;/code> 內加入例外（反向）：&lt;code>!filename&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>git add -f&lt;/code> 強制加入（我忽略你的忽略，但不推薦）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>可以用 &lt;code>git clean -fx&lt;/code> 一次清光不該被加入 stage 的檔案&lt;/p>
&lt;h2 id="commit-相關情境">Commit 相關情境&lt;/h2>
&lt;h3 id="修改上次-commit">修改上次 commit&lt;/h3>
&lt;p>&lt;code>git commit --amend&lt;/code> 直接合併到上個 commit&lt;br>
&lt;code>git commit --amend --author &amp;quot;David Ye &amp;lt;david@dwye.dev&amp;gt;&amp;quot;&lt;/code> 修改 commit 的作者&lt;/p>
&lt;p>或是直接使用 rebase 來修改也可以，通常用在需要修改比較前面的 commit，或是一次修改大量 commits&lt;/p>
&lt;h3 id="拆掉-commit">拆掉 commit&lt;/h3>
&lt;p>&lt;code>git reset HEAD~&lt;/code>&lt;br>
&lt;code>HEAD&lt;/code> 是目前所在的 commit&lt;br>
&lt;code>~&lt;/code> 代表往前走一個 commit，因此也可以用多個 &lt;code>~&lt;/code> 拆多個&lt;/p>
&lt;h2 id="branch-操作">Branch 操作&lt;/h2>
&lt;h3 id="新增-branch-同時切過去">新增 branch 同時切過去&lt;/h3>
&lt;p>&lt;code>git checkout -b &amp;lt;new_branch&amp;gt;&lt;/code>，一步完成，就不需要先創建分支才切過去，使用頻率極高&lt;/p>
&lt;h3 id="branch-名稱修改">branch 名稱修改&lt;/h3>
&lt;p>切到該分支，然後 &lt;code>git branch -m &amp;lt;new_name&amp;gt;&lt;/code>&lt;/p>
&lt;h2 id="reset-與-checkout-的差別">Reset 與 Checkout 的差別&lt;/h2>
&lt;p>&lt;code>checkout&lt;/code> 是移動現在的工作區到哪個 commit&lt;br>
-&amp;gt; 移動工作區，分支放在地上&lt;br>
&lt;code>reset&lt;/code> 是設定分支到某個地方，已經 commit 的其實不會動到&lt;br>
-&amp;gt; 帶著分支移動&lt;/p>
&lt;p>所以 reset 可以拿來救 rebase！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git reset ORIG_HEAD --hard
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ORIG_HEAD&lt;/code> 就是 rebase 操作前的原先 commit&lt;/p>
&lt;h3 id="git-reset---hard-到底在幹嘛">&lt;code>git reset --hard&lt;/code> 到底在幹嘛&lt;/h3>
&lt;p>&lt;code>--hard&lt;/code> 會把 staging 的檔案全部清掉，reset 預設是切到 HEAD，所以分支不動&lt;br>
於是只有 &lt;code>--hard&lt;/code> 生效&lt;br>
就像&lt;strong>帶著分支&lt;/strong>原地跳一下，把身上的東西抖掉的感覺 XD&lt;/p>
&lt;h3 id="reset-可以當作-add-的相反">&lt;code>reset&lt;/code> 可以當作 &lt;code>add&lt;/code> 的相反&lt;/h3>
&lt;p>&lt;code>git reset -- &amp;lt;file&amp;gt;&lt;/code> 取消 &lt;code>add&lt;/code>，變更會保留在工作區&lt;br>
&lt;code>git checkout -- &amp;lt;file&amp;gt;&lt;/code> 連變更都移除掉！&lt;/p>
&lt;h2 id="remote">Remote&lt;/h2>
&lt;p>&lt;code>git remote&lt;/code> 列出節點（origin）&lt;br>
&lt;code>git remote --verbose&lt;/code> 列出節點 / 網址 / fetch / push&lt;br>
&lt;code>git branch --all&lt;/code> 可以看到遠端分支&lt;/p>
&lt;h3 id="push">Push&lt;/h3>
&lt;p>&lt;code>git push -u origin master&lt;/code> 設定上游分支！&lt;br>
&lt;code>git push origin master&lt;/code> 只推送分支，不設定下次也會預設推到這&lt;br>
&lt;code>git push origin master:another_name&lt;/code> 推到不同名分支&lt;/p>
&lt;h3 id="刪除遠端分支">刪除遠端分支&lt;/h3>
&lt;p>其實就是推一個空分支上去&lt;/p>
&lt;p>&lt;code>git push origin :another_name&lt;/code>&lt;/p>
&lt;h3 id="pull">Pull&lt;/h3>
&lt;p>&lt;code>pull&lt;/code> = &lt;code>fetch&lt;/code> + &lt;code>merge&lt;/code>&lt;/p>
&lt;p>&lt;code>fetch&lt;/code>: 更新 remote 分支到本機&lt;br>
&lt;code>merge&lt;/code>: 把本機分支和 remote 分支合併！&lt;/p>
&lt;p>&lt;code>pull --rebase&lt;/code> = &lt;code>fetch&lt;/code> + &lt;code>rebase&lt;/code>&lt;/p>
&lt;h3 id="當你推分支推不上去">當你推分支推不上去&lt;/h3>
&lt;p>兩個方法：&lt;/p>
&lt;ol>
&lt;li>&lt;code>push -f&lt;/code> 聽我的，強制更新遠端分支！&lt;/li>
&lt;li>&lt;code>pull --rebase&lt;/code> 跟新自己的分支，然後 &lt;code>push&lt;/code>&lt;/li>
&lt;/ol>
&lt;h2 id="rebase">Rebase&lt;/h2>
&lt;pre>&lt;code>git rebase &amp;lt;hash/branch&amp;gt;
&lt;/code>&lt;/pre>&lt;p>從 branch/hash &lt;strong>重新開始長出分支&lt;/strong>到現在的 commit&lt;/p>
&lt;p>操作完畢後，&lt;code>ORIG_HEAD&lt;/code> 會指向操作前的舊的 commit，雖然舊的 commit 會被藏起來，但其實舊的 commit 還是會存在一段時間的，因此可以用 &lt;code>git reset --hard&lt;/code> 返回。&lt;/p>
&lt;p>（當你害怕的時候，就用 &lt;code>git rebase --abort&lt;/code> 逃跑吧 XD）&lt;/p>
&lt;h3 id="修改過去-i-的互動式修改">修改過去：&lt;code>-i&lt;/code> 的互動式修改&lt;/h3>
&lt;pre>&lt;code>git rebase -i &amp;lt;hash/branch&amp;gt;
&lt;/code>&lt;/pre>&lt;p>開啟互動模式，會顯示出所有 commit，上到下是舊到新&lt;/p>
&lt;ul>
&lt;li>pick: 保留&lt;/li>
&lt;li>reword: 改 message&lt;/li>
&lt;li>squash: 把分支和&lt;strong>上一個&lt;/strong>壓扁&lt;/li>
&lt;li>fixup: 和 squash 相同，但 commit message 直接扔掉不保留&lt;/li>
&lt;li>edit: 停在這，回編輯器，等到 commit 後繼續，用來修改 commit
&lt;ul>
&lt;li>所以可以搭配 reset 拆 commit 內容：把檔案扔出暫存區，然後分次 commit&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>也可以換順序&lt;/p>
&lt;p>也能直接刪掉 commit，但不建議 &lt;strong>（會有更動消失掉）&lt;/strong>&lt;/p>
&lt;pre>&lt;code>git rebase -i --autosquash &amp;lt;hash/branch&amp;gt;
&lt;/code>&lt;/pre>&lt;p>會把 commit message 是 &lt;code>squash! &amp;lt;commit&amp;gt;&lt;/code> 和 &lt;code>fixup! &amp;lt;commit&amp;gt;&lt;/code> 的 commit 分別自動標記成 &lt;code>squash&lt;/code> 和 &lt;code>fixup&lt;/code>&lt;/p>
&lt;p>可以搭配 &lt;code>git commit --fixup&lt;/code> 使用，很方便&lt;/p>
&lt;h2 id="worktree-一個-repo-多個目錄">worktree: 一個 repo 多個目錄&lt;/h2>
&lt;p>&lt;code>git worktree add &amp;lt;path&amp;gt; &amp;lt;branch&amp;gt;&lt;/code> 設定分支為某個 path 底下的檔案&lt;/p>
&lt;p>&lt;code>git worktree list&lt;/code> 列出 worktree&lt;/p>
&lt;h3 id="刪除-worktree">刪除 worktree&lt;/h3>
&lt;p>先刪掉該資料夾（上面的 path），然後 &lt;code>git worktree prune&lt;/code>&lt;br>
可以先 &lt;code>git worktree prune -n&lt;/code> 看看會刪掉 (dry run)&lt;/p>
&lt;h2 id="submodule">submodule&lt;/h2>
&lt;p>執行 git clone 時不會自動把 submodule 一起 clone 過來，所以要初始化 submodule 並 clone：&lt;/p>
&lt;pre>&lt;code>git submodule update --init --recursive
&lt;/code>&lt;/pre>&lt;p>相關設定會存在 &lt;code>.git/config&lt;/code>&lt;/p>
&lt;h3 id="刪除-submodule">刪除 submodule&lt;/h3>
&lt;ol>
&lt;li>&lt;code>git submodule deinit &amp;lt;path&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>git rm &amp;lt;path&amp;gt;&lt;/code>&lt;/li>
&lt;/ol>
&lt;h3 id="更換-submodule-的-reference-url">更換 submodule 的 reference url&lt;/h3>
&lt;p>用指令更改：&lt;/p>
&lt;pre>&lt;code>git config -f .gitmodules submodule.&amp;lt;name&amp;gt;.url &amp;lt;url&amp;gt;
&lt;/code>&lt;/pre>&lt;p>或手動更改 &lt;code>.gitmodules&lt;/code>&lt;/p>
&lt;p>然後 sync：&lt;/p>
&lt;pre>&lt;code>git submodule sync
&lt;/code>&lt;/pre>&lt;h2 id="其他技巧">其他技巧&lt;/h2>
&lt;h3 id="log">Log&lt;/h3>
&lt;ul>
&lt;li>&lt;code>git log --oneline&lt;/code> 可以只看一行的 commit message，比起一般的 &lt;code>git log&lt;/code> 我更常用這個&lt;/li>
&lt;li>&lt;code>git reflog&lt;/code> 或 &lt;code>git log -g&lt;/code> 看 HEAD 移動，就像是你的操作記錄，想要回到某個 commit 卻忘了在哪，可以使用這個方法找到，包含回到 &lt;code>rebase&lt;/code> 之前的某個 commit 也行&lt;/li>
&lt;/ul>
&lt;h3 id="tig">Tig&lt;/h3>
&lt;p>可以使用 &lt;code>tig&lt;/code> 這套工具，提供更簡明的 git 相關顯示以及互動式操作：&lt;br>
&lt;a href="https://github.com/jonas/tig">https://github.com/jonas/tig&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/tig.png" alt="tig example">&lt;/p>
&lt;h2 id="git-學習資源推薦">Git 學習資源推薦&lt;/h2>
&lt;p>同時也是本篇的參考資料&lt;/p>
&lt;h3 id="免費電子書">免費電子書&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://gitbook.tw/">為你自己學 Git&lt;/a>：淺顯易懂的教學，大推&lt;/li>
&lt;li>&lt;a href="https://zlargon.gitbooks.io/git-tutorial/content/">Git-Tutorials 基本使用教學&lt;/a>：較精簡&lt;/li>
&lt;li>&lt;a href="https://git-scm.com/book/zh-tw/v2">Pro Git&lt;/a>：官方，前半有中譯&lt;/li>
&lt;/ul>
&lt;h3 id="實體書籍">實體書籍&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.tenlong.com.tw/products/9789864766932?list_name=srh">完整學會 Git, GitHub, Git Server 的 24 堂課，2/e&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="其他參考資料">其他參考資料&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sethrobertson.github.io/GitBestPractices/">Git Best Practices&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>客製化 git 使用的 SSH Key</title><link>https://dwye.dev/post/git-custom-ssh/</link><pubDate>Thu, 05 Aug 2021 15:33:25 +0800</pubDate><guid>https://dwye.dev/post/git-custom-ssh/</guid><description>
&lt;p>寫完&lt;a href="https://dwye.dev/post/ssh-switch-key">一個指令切換預設使用的 SSH Key&lt;/a>這篇之後，又思考了一下有沒有其他方式來解決這個同個電腦中使用兩個 github 帳號的問題，畢竟那篇是採用 ssh-agent level 來解決，但其實搞不好也可以直接從 git 的 config 下手，因此這次重新用更多關鍵字去調查解法，發現 git 其實也支援客製化 ssh 指令。&lt;/p>
&lt;h2 id="解法一環境變數-git_ssh_command">解法一：環境變數 &lt;code>GIT_SSH_COMMAND&lt;/code>&lt;/h2>
&lt;p>設定這個環境變數即可改變 git 使用的 ssh 指令。&lt;/p>
&lt;p>可以透過 &lt;code>export&lt;/code> 對當下的 shell 做一次性修改（也能達成一指令切換）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">export GIT_SSH_COMMAND&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ssh -o IdentitiesOnly=yes -i ~/.ssh/my_rsa&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或是直接搭配 git 指令使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">GIT_SSH_COMMAND&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ssh -o IdentitiesOnly=yes -i ~/.ssh/my_rsa&amp;#34;&lt;/span> git push
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="-o-identitiesonlyyes-防止--i-的-key-被-ssh-agent-取代">&lt;code>-o IdentitiesOnly=yes&lt;/code>: 防止 &lt;code>-i&lt;/code> 的 Key 被 SSH Agent 取代&lt;/h3>
&lt;p>我自己也無法 100% 確定什麼時候 &lt;code>-i&lt;/code> Options 會無效，不過知道原因是因為即便是加了 &lt;code>-i&lt;/code> 指定 key file，還是會參照到 ssh agent 現存的所有 keys。因此還是加上 &lt;code>-o IdentitiesOnly=yes&lt;/code> 保險。&lt;/p>
&lt;h2 id="解法二更改-git-configuration-的-coresshcommand">解法二：更改 Git Configuration 的 &lt;code>core.sshCommand&lt;/code>&lt;/h2>
&lt;p>根據文件，會影響到 &lt;code>git fetch&lt;/code> 和 &lt;code>git push&lt;/code> 時使用的 ssh 指令。&lt;/p>
&lt;p>因此可以在已經 clone 好的 repo 內下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git config --local core.sshCommand &lt;span style="color:#e6db74">&amp;#34;ssh -o IdentitiesOnly=yes -i ~/.ssh/my_rsa&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="解法三直接切換-ssh-agent">解法三：直接切換 SSH Agent&lt;/h2>
&lt;p>就是我原本的解法，詳見這篇：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dwye.dev/post/ssh-switch-key">一個指令切換預設使用的 SSH Key&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="小結">小結&lt;/h2>
&lt;p>最後採用解法二 + 三，三用來切換 default 的 SSH Key 用於 clone 自己的 private repo 時使用，之後就在 repo 內直接設定 &lt;code>core.sshCommand&lt;/code> 就不用每次再重新切換 ssh key 了。&lt;/p>
&lt;p>順便附上我準備的設定 local gitconfig 的 script：&lt;/p>
&lt;script src="https://gist.github.com/dwy6626/ce6bd08aad6ce17d0d277f21ba2c6a3f.js">&lt;/script>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://superuser.com/questions/232373/">How to tell git which private key to use?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://superuser.com/questions/681877/ssh-ignores-i-switch">SSH ignores -i switch&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git-scm.com/docs/git">git doc&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git-scm.com/docs/git-config">git config doc&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>一個指令切換預設使用的 SSH Key</title><link>https://dwye.dev/post/ssh-switch-key/</link><pubDate>Tue, 03 Aug 2021 20:00:25 +0800</pubDate><guid>https://dwye.dev/post/ssh-switch-key/</guid><description>
&lt;p>因應公司和個人有分開的 github 帳號，為了能在同一台電腦同使用者內工作，已經幾次重複解決這個問題，故寫篇文章記錄之。&lt;/p>
&lt;h3 id="檢視現在使用的-ssh-key">檢視現在使用的 SSH Key&lt;/h3>
&lt;p>我們可以使用 &lt;code>ssh-add&lt;/code> 這個工具來檢視目前使用 &lt;code>ssh&lt;/code> 指令連線時，會使用的 ssh key：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ssh-add -l
&lt;span style="color:#ae81ff">3072&lt;/span> SHA256:******************/****************** my-default-email@dwye.dev &lt;span style="color:#f92672">(&lt;/span>RSA&lt;span style="color:#f92672">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以直接用 &lt;code>ssh -T&lt;/code>，使用 ssh 連線但不要使用虛擬終端（pty）&lt;br>
這也衍生了 github 使用 &lt;code>git&lt;/code> 這個 user，作為設置 ssh key 時常見的確認手段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ssh -T git@github.com
Hi your-account! You&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ssh-key-的切換">SSH Key 的切換&lt;/h3>
&lt;p>&lt;code>ssh-add&lt;/code> 顧名思義也可以用來管理 ssh-agent 現在使用的 ssh-key。&lt;/p>
&lt;p>加入一個 ssh key:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ssh-add ~/.ssh/my_rsa
Identity added: /Users/myaccount/.ssh/my_rsa &lt;span style="color:#f92672">(&lt;/span>my-default-email@dwye.dev&lt;span style="color:#f92672">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>清空 ssh key:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ssh-add -D
All identities removed.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此我們就可以做如此操作達到切換 ssh key 的效果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># ~/switch_main.sh&lt;/span>
ssh-add -D
ssh-add ~/.ssh/id_rsa
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># ~/switch_personal.sh&lt;/span>
ssh-add -D
ssh-add ~/.ssh/my_rsa
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然後在啟動 shell 時加入 alias 即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># ~/.bashrc 或是 ~/.zshrc&lt;/span>
alias gitp&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;source ~/switch_personal.sh&amp;#39;&lt;/span>
alias gitm&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;source ~/switch_main.sh&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>之後就可以在 terminal 中透過 &lt;code>gitp&lt;/code> 或 &lt;code>gitm&lt;/code> 一指令切換 ssh key 了。&lt;/p>
&lt;h2 id="85-更新">8/5 更新&lt;/h2>
&lt;p>是的，才寫完這篇沒多久馬上就找到新解法來切換 git 使用的 ssh key，就不用每次開 shell 都要去手動改了（變成 0 指令切換 XD），我也比較喜歡這個新解法，詳細請見&lt;a href="https://dwye.dev/post/git-custom-ssh">客製化 git 使用的 SSH Key&lt;/a>&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>MY FIRST STORY 《I'm a mess》 中文歌詞翻譯</title><link>https://dwye.dev/post/i-am-a-mess/</link><pubDate>Sun, 01 Aug 2021 20:20:00 +0800</pubDate><guid>https://dwye.dev/post/i-am-a-mess/</guid><description>
&lt;p>《I&amp;rsquo;m a mess》 是 MY FIRST STORY 於2021 年 7 月 14 日發行的單曲《告白》的 B 面曲。&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/PAEgjePd3r8" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>Mess 在英文中就是一團糟、髒亂麻煩的東西的意思，常常用來形容事物一團亂、很難救的情況。&lt;br>
也因此這次的 《I&amp;rsquo;m a mess》在歌詞上繼承 MY FIRST STORY 一如以往的負面自卑的風格，以自己和自己的對話，訴說各種不得意，但曲風卻又輕快搖滾，是在低潮時容易共鳴並不斷 replay 的一首。&lt;/p>
&lt;p>這次的這首也是這半個月來十分中意而時常循環的新歌，看到網路上沒有什麼翻譯資料，所以選擇自己來翻譯。附帶一提，不知道為什麼 B 面曲對我來說總有特別的魔力，比起 A 面主打，我通常都比較中意 B 面曲，也許也和 B 面曲通常都是屬於比較特別敢嘗試的風格有關，不過通常 B 面曲都沒有 MV，也不太會收錄到專輯中就是，實在可惜。&lt;/p>
&lt;hr>
&lt;h3 id="im-a-mess">I&amp;rsquo;m a mess&lt;/h3>
&lt;p>作詞：HIRO&lt;br>
作曲：SHO&lt;/p>
&lt;p>I’m a mess, I’m a mess&lt;/p>
&lt;p>明けない夜に失いかけた声をあげて&lt;br>
在沒有黎明的夜裡聲嘶力竭地呼喊著&lt;/p>
&lt;p>I’m a mess, I’m a mess&lt;/p>
&lt;p>振り返れない僕の心はどこへ行くの&lt;br>
無法收回的我的思念該往何處去&lt;/p>
&lt;p>&lt;br>
閉ざされた世の中で&lt;br>
在這沒有出口的世界中&lt;/p>
&lt;p>何が不要不急かも分からなくなってしまう&lt;br>
逐漸變得分不清事情的輕重緩急&lt;/p>
&lt;p>血に濡れてるメッセージ&lt;br>
浸著血液的訊息&lt;/p>
&lt;p>隠された口元じゃなにも言えないだろう&lt;br>
隱藏起來的嘴角大概什麼也說不出來吧&lt;/p>
&lt;p>&lt;br>
満たされない日々に&lt;br>
無法滿足的日子裡&lt;/p>
&lt;p>囚われたくもないな&lt;br>
不想被囚禁著&lt;/p>
&lt;p>心の底から崩れかけた&lt;br>
從心靈深處開始崩壞殆盡&lt;/p>
&lt;p>&lt;br>
I’m a mess, I’m a mess&lt;/p>
&lt;p>1人の夜は　こんな想いが溢れていく&lt;br>
一個人的夜晚裡，滿滿的都是這種想法&lt;/p>
&lt;p>I’m a mess, I’m a mess&lt;/p>
&lt;p>余裕の negative&lt;br>
太多的負面思想&lt;/p>
&lt;p>同じように苦しめられて&lt;br>
同樣地被折磨著&lt;/p>
&lt;p>&lt;br>
いらないやらない宣言なんて&lt;br>
不需要、做不到的宣言什麼的&lt;/p>
&lt;p>何度繰り返せばいいの&lt;br>
到底要重複幾遍才滿足呢&lt;/p>
&lt;p>もう意味なんてないよな&lt;br>
已經什麼意義都沒有了&lt;/p>
&lt;p>I’m a mess, I’m a mess&lt;/p>
&lt;p>1人の夜も　乗り越えられたらいいのにな&lt;br>
要是能撐過這獨自一人的夜晚就好了&lt;/p>
&lt;p>&lt;br>
真っ暗な街中を&lt;br>
在漆黑的城鎮中&lt;/p>
&lt;p>憂いを帯びた顔で　バラバラに立ち去っていく&lt;br>
面帶悲傷的人們各自離去&lt;/p>
&lt;p>簡単に作られた意図的なマニュアルに　全て奪われてる&lt;br>
被廉價的意圖手冊奪去了一切&lt;/p>
&lt;p>&lt;br>
今の世界は先が見えずに&lt;br>
在這世界裡看不清未來&lt;/p>
&lt;p>どこにも救いはなくて&lt;br>
也無法得到救贖&lt;/p>
&lt;p>また次の犠牲者が増えていくの&lt;br>
不斷地出現更多的犧牲者&lt;/p>
&lt;p>&lt;br>
I’m a mess, I’m a mess&lt;/p>
&lt;p>聞こえる声を探し続けてたどり着いた&lt;br>
不斷尋找著聲音源頭而來到了這裡&lt;/p>
&lt;p>I’m a mess, I’m a mess&lt;/p>
&lt;p>不安な medicine　もっと近くで触れたいのに&lt;br>
帶來不安的藥物，想要更接近地觸摸&lt;/p>
&lt;p>&lt;br>
泣かない逢えないシンデレラ&lt;br>
不哭泣、得不到邂逅的灰姑娘&lt;/p>
&lt;p>まだ帰る時間じゃないのに&lt;br>
明明還沒有到結束時間&lt;/p>
&lt;p>魔法が解けていくの&lt;br>
魔法卻逐漸消失了&lt;/p>
&lt;p>I’m a mess, I’m a mess&lt;/p>
&lt;p>いつかは君と&lt;br>
冀望著有一天能與你&lt;/p>
&lt;p>朝まで踊り明かしたいんだ&lt;br>
跳著舞迎接黎明&lt;/p>
&lt;p>&lt;br>
当たり前じゃないだろう&lt;br>
並不是理所當然的吧&lt;/p>
&lt;p>やめたわけじゃないよな&lt;br>
也不是想要放棄的啊&lt;/p>
&lt;p>だとしたら答え探して&lt;br>
既然如此就去尋找答案吧&lt;/p>
&lt;p>&lt;br>
I’m a mess, I’m a mess&lt;/p>
&lt;p>あの日の僕は　夢は叶うと思ったけど&lt;br>
那一天的我真心以為夢想會成真&lt;/p>
&lt;p>I’m a mess, I’m a mess&lt;/p>
&lt;p>諦めたくない　なんて言葉じゃ頼りなくて&lt;br>
不想放棄什麼的言語根本不可靠&lt;/p>
&lt;p>&lt;br>
I’m a mess, I’m a mess&lt;/p>
&lt;p>1人の夜は　こんな想いが溢れていく&lt;br>
一個人的夜晚裡，滿滿的都是這種想法&lt;/p>
&lt;p>I’m a mess, I’m a mess&lt;/p>
&lt;p>余裕の negative&lt;br>
太多的負面思想&lt;/p>
&lt;p>同じように苦しめられて&lt;br>
同樣地被折磨著&lt;/p>
&lt;p>&lt;br>
いらないやらない宣言なんて&lt;br>
不需要、做不到的宣言什麼的&lt;/p>
&lt;p>何度繰り返せばいいの&lt;br>
到底要重複幾遍才滿足呢&lt;/p>
&lt;p>もう意味なんてないよな&lt;br>
已經什麼意義都沒有了&lt;/p>
&lt;p>I’m a mess, I’m a mess&lt;/p>
&lt;p>そんな世界を　君と歩いて行けるのなら&lt;br>
在那樣的世界裡如果有你一起走過就好了呢&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Ruby Object Model</title><link>https://dwye.dev/post/ruby-object-model/</link><pubDate>Sat, 17 Jul 2021 23:41:25 +0800</pubDate><guid>https://dwye.dev/post/ruby-object-model/</guid><description>
&lt;h2 id="前言ruby-中的物件導向">前言：Ruby 中的物件導向&lt;/h2>
&lt;p>Ruby Object Model 是我覺得 Ruby 算是十分特別也是十分重要的概念。&lt;/p>
&lt;p>在一般的物件導向程式語言中，物件是類別的實體，而資料型態是資料型態。一個變數可以儲存一個資料型態，一個變數也可以指向一個物件，但資料型態和物件是兩回事。&lt;/p>
&lt;p>但在 Ruby 中，&lt;strong>所有的東西都是物件&lt;/strong>。&lt;/p>
&lt;h3 id="所有東西都是物件">所有東西都是物件&lt;/h3>
&lt;p>對，在 Ruby 中，主程序（Main）本身是一個物件，被定義好的 function 是物件，你所知道的資料型態如：整數、浮點、Boolean、字串（Ruby 中沒有字串與字元的分別）等是物件，就連平常代表虛無的 &lt;code>nil&lt;/code> 也是一個物件！&lt;/p>
&lt;p>打開 irb 試試看：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> :&lt;span style="color:#ae81ff">001&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> :&lt;span style="color:#ae81ff">002&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> a&lt;span style="color:#f92672">.&lt;/span>nil?
&lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> :&lt;span style="color:#ae81ff">003&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>&lt;span style="color:#f92672">.&lt;/span>class
&lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">NilClass&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因為 Ruby 中 &lt;code>nil&lt;/code> 是一個 &lt;code>NilClass&lt;/code> 的 instance（也是唯一的 instance，不能 new 一個出來），所以有 &lt;code>nil?&lt;/code> 這種方法，可以問一個變數是不是 &lt;code>nil&lt;/code>，夠神奇吧？&lt;br>
這個語法糖相當於其他語言的 &lt;code>a == nil&lt;/code> 或是 &lt;code>a is None&lt;/code>，但變成 method 的形式讀起來更直觀。&lt;/p>
&lt;h3 id="所有-functions-都是-methods">所有 Functions 都是 Methods&lt;/h3>
&lt;p>因為所有東西都是物件，在主程序以 &lt;code>def&lt;/code> 定義的 function，其實也只是掛在 Main object 下的 private method:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> :&lt;span style="color:#ae81ff">001&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">my_custom_method&lt;/span>
&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> :&lt;span style="color:#ae81ff">002&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> puts &lt;span style="color:#e6db74">&amp;#39;hello&amp;#39;&lt;/span>
&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> :&lt;span style="color:#ae81ff">003&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#e6db74">:my_custom_method&lt;/span>
&lt;span style="color:#75715e"># 注意如果用 methods 只會拿到 public 和 protected methods&lt;/span>
&lt;span style="color:#75715e"># 這邊的 self 其實是可以省略的，但為了強調我們是在存取 `main` 這個 object，先保留了：&lt;/span>
&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> :&lt;span style="color:#ae81ff">004&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>private_methods&lt;span style="color:#f92672">.&lt;/span>include? &lt;span style="color:#e6db74">:my_custom_method&lt;/span>
&lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而 Main object 已經在使用了，還可以後續再寫入方法，這也是 ruby 的特色之一。&lt;/p>
&lt;h2 id="ruby-object-model">Ruby Object Model&lt;/h2>
&lt;p>Ruby 的物件模型，也就是 Ruby 中物件導向的運作機制。&lt;/p>
&lt;h3 id="instance">Instance&lt;/h3>
&lt;p>在 Ruby 中，可以利用 &lt;code>Class#new&lt;/code> 幫一個類別建立新的 instance，這時 instance 內儲存的資訊有：&lt;/p>
&lt;ul>
&lt;li>instance_variable&lt;/li>
&lt;li>class&lt;/li>
&lt;li>object_id&lt;/li>
&lt;/ul>
&lt;p>Instance methods 不需要存在每個物件裡，只需要存在 class 並查找 instance methods 就好。&lt;/p>
&lt;h3 id="self">Self&lt;/h3>
&lt;p>在 ruby 中，永遠都會有一個代表「現在的物件」，可以透過 &lt;code>self&lt;/code> 取得：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">puts self
&lt;span style="color:#75715e"># =&amp;gt; main，在最外層，self 代表 main object&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span>
puts self
&lt;span style="color:#75715e"># =&amp;gt; Car，在 class 內，self 是當下的 class object&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>self&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> run! pupu!&amp;#34;&lt;/span>
&lt;span style="color:#75715e"># 在 method 內，self 是物件本身！&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
c &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">Car&lt;/span>&lt;span style="color:#f92672">.&lt;/span>new
c&lt;span style="color:#f92672">.&lt;/span>run &lt;span style="color:#75715e"># =&amp;gt; #&amp;lt;Car:0x00007fe17f8eeac8&amp;gt; run! pupu!&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而這邊還有個有趣的觀察：&lt;br>
在 ruby 中，定義 class 是當下就會執行，而 def 定義 method 則是使用時動態執行。&lt;/p>
&lt;h3 id="singleton-class">Singleton Class&lt;/h3>
&lt;p>Singleton Class 是跟著每個 ruby 物件自動產生，對於每個物件是&lt;strong>獨一無二&lt;/strong>的 Class。&lt;br>
會有這樣的設計，要回到剛剛說的 ruby 的物件不會儲存 instance method 的特性。&lt;/p>
&lt;p>因為物件不存 method，但 ruby 又有個特色，可以為現有的物件定義新方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> c
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">run_twice&lt;/span>
run
run
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
c&lt;span style="color:#f92672">.&lt;/span>run_twice
&lt;span style="color:#75715e"># #&amp;lt;Car:0x00007fe17f8eeac8&amp;gt; run! pupu!&lt;/span>
&lt;span style="color:#75715e"># #&amp;lt;Car:0x00007fe17f8eeac8&amp;gt; run! pupu!&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這時候這個 &lt;code>run_twice&lt;/code> 方法是只有 &lt;code>c&lt;/code> 這個物件擁有，其他的 &lt;code>Car&lt;/code> 的 instance 是不會擁有的，因此 &lt;code>run_twice&lt;/code> 不能被放在 &lt;code>Car&lt;/code> 這個 class 裡。&lt;/p>
&lt;p>在 ruby 中，這種單一物件特有的 method，就叫做 singleton method：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">c&lt;span style="color:#f92672">.&lt;/span>singleton_methods
&lt;span style="color:#75715e"># =&amp;gt; [:run_twice]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而 singleton class 就是拿來儲存 singleton method 用的。&lt;/p>
&lt;p>因為 singleton class 是獨一無二的，所以有幾個限制：&lt;/p>
&lt;ul>
&lt;li>不能建立新的 instance（畢竟要是獨一無二，才叫 singleton）&lt;/li>
&lt;li>不能被繼承（但這個有例外，就是 class 的 singleton class，會自動跟著 class 自己產生繼承鏈（見下方），只是仍然不能手動去繼承他，不然會扔出 &lt;code>TypeError&lt;/code>）&lt;/li>
&lt;/ul>
&lt;p>對於一般 object （並不是 &lt;code>Class&lt;/code> 的 instance）來說，每個物件都有 singleton class，因此會在後面加上物件本身的識別，並繼承自他的 class：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">c&lt;span style="color:#f92672">.&lt;/span>singleton_class
&lt;span style="color:#75715e"># =&amp;gt; #&amp;lt;Class:#&amp;lt;Car:0x00007fe17f8eeac8&amp;gt;&amp;gt;&lt;/span>
c&lt;span style="color:#f92672">.&lt;/span>singleton_class&lt;span style="color:#f92672">.&lt;/span>superclass &lt;span style="color:#f92672">==&lt;/span> c&lt;span style="color:#f92672">.&lt;/span>class
&lt;span style="color:#75715e"># =&amp;gt; true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>對於一般 class（&lt;code>Class&lt;/code> 的 instance），因為 class 本身為為一，所以 singleton class 也是唯一的，並繼承自其 superclass 的 singleton class。&lt;br>
也就是 class 的 singleton class 們是形成一條繼承鏈，直到最後繼承自 Class。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#66d9ef">Car&lt;/span>&lt;span style="color:#f92672">.&lt;/span>singleton_class&lt;span style="color:#f92672">.&lt;/span>superclass &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">Car&lt;/span>&lt;span style="color:#f92672">.&lt;/span>class
&lt;span style="color:#75715e"># =&amp;gt; false&lt;/span>
&lt;span style="color:#66d9ef">Car&lt;/span>&lt;span style="color:#f92672">.&lt;/span>superclass&lt;span style="color:#f92672">.&lt;/span>singleton_class &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">Car&lt;/span>&lt;span style="color:#f92672">.&lt;/span>singleton_class&lt;span style="color:#f92672">.&lt;/span>superclass
&lt;span style="color:#75715e"># =&amp;gt; true&lt;/span>
&lt;span style="color:#66d9ef">Car&lt;/span>&lt;span style="color:#f92672">.&lt;/span>singleton_class&lt;span style="color:#f92672">.&lt;/span>ancestors
&lt;span style="color:#75715e"># =&amp;gt; [#&amp;lt;Class:Car&amp;gt;, #&amp;lt;Class:Object&amp;gt;, #&amp;lt;Class:BasicObject&amp;gt;,&lt;/span>
&lt;span style="color:#75715e"># Class, Module, Object, Kernel, BasicObject]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="receiver">Receiver&lt;/h3>
&lt;p>當我們呼叫一個 method，會需要有一個 receiver，使用 &lt;code>receiver.method_name&lt;/code> 的形式調用 method。&lt;br>
以上面 &lt;code>c.run&lt;/code> 為例，這時的 receiver 就是 &lt;code>c&lt;/code>。&lt;br>
如果沒有指定 receiver，預設會使用 &lt;code>self&lt;/code>，也就是當下的物件。&lt;/p>
&lt;p>而 Ruby 的 &lt;code>private&lt;/code> method 的定義，即是&lt;strong>不能明確指定 receiver&lt;/strong>，換句話說，就是只能透過 &lt;code>self&lt;/code> 來呼叫（當然如果你指定成 &lt;code>self&lt;/code> 還是會噴 error 的喔 XD）。&lt;br>
不過 Ruby 這麼自由的語言，當然可以繞過去，透過 &lt;code>receiver.send(:method_name)&lt;/code> 的方式即可呼叫 private method。&lt;/p>
&lt;p>Ruby 的哲學就是把給開發者最大的自由，當然也需要開發者謹慎的使用。&lt;/p>
&lt;h3 id="method-lookup">Method Lookup&lt;/h3>
&lt;p>當我們呼叫一個物件的 method，ruby 會去看該物件的 class 有沒有該方法定義。&lt;br>
而 class 的查找順序為：&lt;/p>
&lt;ol>
&lt;li>Singleton class&lt;/li>
&lt;li>繼承鏈中的 class 一路上找 (&lt;code>Class#ancestors&lt;/code> 可以拿出繼承鏈，不過會把 Module 也包含在內)&lt;/li>
&lt;/ol>
&lt;p>而對於每個 class &lt;code>C&lt;/code>而言，再以以下順序查找：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://ruby-doc.org/core-3.0.2/doc/syntax/refinements_rdoc.html">Refinements&lt;/a>，LIFO（後啟用，優先查找）&lt;/li>
&lt;li>prepended module&lt;/li>
&lt;li>自身定義的 methods&lt;/li>
&lt;li>included module&lt;/li>
&lt;/ol>
&lt;p>而每個 Refinements 內部也會依照 prepend -&amp;gt; 直接定義 -&amp;gt; include 的順序來查找。&lt;/p>
&lt;p>如果到了繼承鏈底部，都沒有找到該方法，會回到 singleton class 並重新查找 &lt;code>method_missing&lt;/code>（這也是透過 &lt;code>method_missing&lt;/code> 定義的 ghost method 會比較慢的原因：要爬兩次繼承鏈）。&lt;/p>
&lt;p>上面就是目前 Ruby 的整個 method 查找過程。&lt;/p>
&lt;h4 id="整理一下可以分解成三層">整理一下，可以分解成三層：&lt;/h4>
&lt;ol>
&lt;li>class 層：根據 singleton class -&amp;gt; superclass -&amp;gt; superclass 的順序查找。&lt;/li>
&lt;li>Refinement 層：若有 Refinements，則依照 LIFO 順序查找，最後才是該 class 自己。&lt;/li>
&lt;li>最內層：prepend -&amp;gt; def -&amp;gt; include。&lt;/li>
&lt;/ol>
&lt;h4 id="簡化版本">簡化版本：&lt;/h4>
&lt;p>一般看到的是沒有 refinements 的版本，而且 refinements 我自己也不常用 XD，拿掉也比較簡單：&lt;/p>
&lt;ol>
&lt;li>singleton class -&amp;gt; superclass -&amp;gt; superclass &amp;hellip;&lt;/li>
&lt;li>prepend -&amp;gt; def -&amp;gt; include&lt;/li>
&lt;/ol>
&lt;p>所以一個 instance 的 method 組成，其實就是 &lt;strong>singleton methods + 繼承鏈上的所有 instance methods + refinements 時定義的 methods&lt;/strong>（當然，不包含用 &lt;code>method_missing&lt;/code> 動態處理的 ghost methods）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#75715e"># 因為 refinement 的 method 無法透過 Kernel#methods 取得，因此先忽略&lt;/span>
&lt;span style="color:#75715e"># 這裡示範了 singleton methods + 繼承鏈上的所有 instance methods = instance 的 methods&lt;/span>
c&lt;span style="color:#f92672">.&lt;/span>methods &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">[&lt;/span>c&lt;span style="color:#f92672">.&lt;/span>singleton_class, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">Car&lt;/span>&lt;span style="color:#f92672">.&lt;/span>ancestors&lt;span style="color:#f92672">].&lt;/span>map { &lt;span style="color:#f92672">|&lt;/span>a&lt;span style="color:#f92672">|&lt;/span> a&lt;span style="color:#f92672">.&lt;/span>instance_methods(&lt;span style="color:#66d9ef">false&lt;/span>) }&lt;span style="color:#f92672">.&lt;/span>reduce(&lt;span style="color:#e6db74">:+&lt;/span>)
&lt;span style="color:#75715e"># =&amp;gt; true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>附帶一提，當呼叫 class method 時，其實也是一樣的，因為在 ruby 中 class 也是個物件，所以也是先找 singleton class，然後隨著繼承鏈上找。&lt;/p>
&lt;h3 id="例如">例如：&lt;/h3>
&lt;p>以下面這個 &lt;code>MyClass&lt;/code> 為例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#66d9ef">ParentClass&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
instance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">MyClass&lt;/span>&lt;span style="color:#f92672">.&lt;/span>new
&lt;/code>&lt;/pre>&lt;/div>&lt;p>class 與 superclass 分別為：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Class&lt;/th>
&lt;th>Superclass&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>instance&lt;/code>&lt;/td>
&lt;td>&lt;code>MyClass&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>instance&lt;/code> 的 singleton class&lt;/td>
&lt;td>&lt;code>Class&lt;/code>&lt;/td>
&lt;td>&lt;code>MyClass&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>MyClass&lt;/code>&lt;/td>
&lt;td>&lt;code>Class&lt;/code>&lt;/td>
&lt;td>&lt;code>ParentClass&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ParentClass&lt;/code>&lt;/td>
&lt;td>&lt;code>Class&lt;/code>&lt;/td>
&lt;td>&lt;code>Object&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Object&lt;/code>&lt;/td>
&lt;td>&lt;code>Class&lt;/code>&lt;/td>
&lt;td>&lt;code>BasicObject&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>BasicObject&lt;/code>&lt;/td>
&lt;td>&lt;code>Class&lt;/code>&lt;/td>
&lt;td>&lt;code>nil&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>畫成圖：&lt;/p>
&lt;pre>&lt;code> BasicObject
^
|
Object
^
|
ParentClass
^
|
MyClass
^
|
instance -&amp;gt; singelton_class
&lt;/code>&lt;/pre>&lt;p>（參考自 &lt;a href="https://gist.github.com/damien-roche/351bf4e7991449714533#one-more-step">https://gist.github.com/damien-roche/351bf4e7991449714533#one-more-step&lt;/a> 的圖並小修改）&lt;/p>
&lt;p>所以有個 method lookup 的口訣是「往右，然後一直往上」，其實就是：&lt;/p>
&lt;ul>
&lt;li>往右：instance 的 singleton_class&lt;/li>
&lt;li>往上：superclass -&amp;gt; superclass &amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>Metaprogramming Ruby 2, Paolo Perrotta&lt;/li>
&lt;li>我同事 Anthony 大神的 &lt;a href="https://qoosuperman.github.io/article/2021-07-31-Ruby_Metaprogramming/">Metaprogramming Ruby 筆記&lt;/a>，感謝他 XD&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/23848667/">Ruby method lookup path for an object&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gist.github.com/damien-roche/351bf4e7991449714533">A Primer on Ruby Method Lookup&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>傳說對決 桐人語音台詞 來源對照（第二彈）</title><link>https://dwye.dev/post/sao-kirito-aov-2/</link><pubDate>Mon, 05 Jul 2021 23:41:25 +0800</pubDate><guid>https://dwye.dev/post/sao-kirito-aov-2/</guid><description>
&lt;p>身為一個業餘 SAO 粉來就該來發第二篇粉絲文。&lt;br>
出處都是刀劍神域第三季，Alicization 篇，而且大部分都是爬塔篇的內容。&lt;br>
找的方法就是打開訓練場聽台詞，把台詞打下來，然後 Google，再開動畫去裡面找。&lt;/p>
&lt;h2 id="選角">選角&lt;/h2>
&lt;p>&lt;img src="https://dwye.dev/img/SAO2/kirito2.jpg" alt="kirito">&lt;/p>
&lt;blockquote>
&lt;p>違う、戦うんじゃ無い。勝つんだ&lt;/p>
&lt;/blockquote>
&lt;p>不，不是要跟你對抗，而是要幹掉你&lt;br>
出處：第 4 話 3:25，打大隻哥布林前的對話，大隻哥布林問說你認真敢跟我打嗎&lt;br>
&lt;img src="https://dwye.dev/img/SAO2/katsu.jpg" alt="kirito">&lt;/p>
&lt;blockquote>
&lt;p>世界を、そこに生きる人々を愛さない者に、支配者たる資格はない&lt;/p>
&lt;/blockquote>
&lt;p>不愛這個世界、不愛活在這世界的人民的人，沒有資格當一個掌權者&lt;br>
出處：第 24 話 7:00，與最高司祭嘴砲&lt;br>
&lt;img src="https://dwye.dev/img/SAO2/shihaishya.jpg" alt="kirito">&lt;/p>
&lt;blockquote>
&lt;p>俺はキリト。剣士キリトだ&lt;/p>
&lt;/blockquote>
&lt;p>我是桐人，劍士桐人&lt;br>
出處：第 44 話 4:44，加百列問桐人是誰時，同時用黑色心念包圍桐人，桐人聽到了 UGO 的聲音後彈開黑色心念回答&lt;br>
感謝網友艾澪補充&lt;br>
&lt;img src="https://dwye.dev/img/SAO2/kiritoda.jpg" alt="kirito2">&lt;/p>
&lt;h2 id="平常">平常&lt;/h2>
&lt;blockquote>
&lt;p>過程こそが重要なんだ。這い蹲って死ぬか、剣を握って死ぬかがね&lt;/p>
&lt;/blockquote>
&lt;p>過程才是最重要的，跪下而死、或拿著劍而死（是不同的）← 這邊後面省略掉了，日文常見的省略用法&lt;br>
出處：第 24 話 0:16，與最高司祭嘴砲&lt;/p>
&lt;blockquote>
&lt;p>刃に込められたものは、相手の魂にまで届く。俺はそう信じる！&lt;/p>
&lt;/blockquote>
&lt;p>劍中的信念可以傳達到對方的靈魂那裡，我是這麼相信的！&lt;br>
出處：第 21 話，6:01，桐人 vs 整合騎士 UGO&lt;br>
&lt;img src="https://dwye.dev/img/SAO2/vs_ugo.jpg" alt="kirito vs ugo">&lt;/p>
&lt;blockquote>
&lt;p>それじゃ足りないな。俺の愚かさを償うには&lt;/p>
&lt;/blockquote>
&lt;p>那樣可不夠啊，還不足以彌補我的愚蠢&lt;br>
出處：第 24 話，0:50，與最高司祭嘴砲&lt;/p>
&lt;blockquote>
&lt;p>それだけが、あらがうことだけが、俺が今ここにいる理由だからだ&lt;/p>
&lt;/blockquote>
&lt;p>因為只有如此和命運對抗，才是我此時此刻在這裡的原因&lt;br>
出處：第 24 話 6:31，與最高司祭嘴砲&lt;br>
&lt;img src="https://dwye.dev/img/SAO2/aragau.jpg" alt="kirito vs admin">&lt;/p>
&lt;blockquote>
&lt;p>俺達もあいつらも、生身の人間なんだ。そんな絶対の善悪なんてもの、人間には決められないんだよ、きっと。&lt;/p>
&lt;/blockquote>
&lt;p>無論是我們或是他們，全都是血肉之軀的人類，那種絕對的善惡，人類是絕對無法決定的。&lt;br>
出處：第 16 話，桐人打敗整合騎士副騎士長法娜提歐後，擔心她的傷勢&lt;/p>
&lt;blockquote>
&lt;p>考えることは、人間のいちばん強い力だ。どんな名剣、どんな秘奥義よりも強い&lt;/p>
&lt;/blockquote>
&lt;p>思考是人類最強大的力量，比任何的名劍或秘藏奧義都還要強大&lt;br>
出處：第 9 話 15:10，跟兩個學妹解釋，比起遵守規定，更重要的是思考&lt;br>
&lt;img src="https://dwye.dev/img/SAO2/think.jpg" alt="kirito say thinking">&lt;/p>
&lt;h2 id="首殺">首殺&lt;/h2>
&lt;blockquote>
&lt;p>剣の重さが戦いを左右する&lt;/p>
&lt;/blockquote>
&lt;p>劍的重量會左右戰局&lt;br>
出處：第 9 話 0:11，和 UGO 解釋劍術的強度&lt;br>
&lt;img src="https://dwye.dev/img/SAO2/weight.jpg" alt="kirito reading">&lt;/p>
&lt;h2 id="多殺">多殺&lt;/h2>
&lt;blockquote>
&lt;p>まだ戦う気のあるやつはかかってこい！&lt;/p>
&lt;/blockquote>
&lt;p>還想打的傢伙儘管過來！&lt;br>
出處：第 4 話 8:27，打贏大隻哥布林之後嗆退底下的小嘍囉&lt;br>
&lt;img src="https://dwye.dev/img/SAO2/head.jpg" alt="kirito and goblin head">&lt;/p>
&lt;blockquote>
&lt;p>俺だって、ここで、負けられないんだ！&lt;/p>
&lt;/blockquote>
&lt;p>我也是絕對不能在這裡輸掉！&lt;br>
出處：第 8 話 7:01，和學院上屆號稱最強的渦羅用真劍對打，想起大家之後說絕對不能輸&lt;br>
&lt;img src="https://dwye.dev/img/SAO2/asuna.jpg" alt="asuna smile">&lt;/p>
&lt;h2 id="凱薩">凱薩&lt;/h2>
&lt;blockquote>
&lt;p>頼むぜ、俺に力を貸してくれ&lt;/p>
&lt;/blockquote>
&lt;p>拜託了，將力量借給我吧&lt;br>
出處：第 21 話，4:10，桐人 vs 整合騎士 UGO&lt;/p>
&lt;h2 id="復活">復活&lt;/h2>
&lt;blockquote>
&lt;p>あぁ、立つよ。お前のためなら、何度だって&lt;/p>
&lt;/blockquote>
&lt;p>我會站起來的，為了你，無論幾次我都會站起來&lt;br>
出處：第 24 話 6:09，UGO 給桐人血紅色的藍薔薇劍，鼓勵桐人站起來繼續對抗&lt;br>
&lt;img src="https://dwye.dev/img/SAO2/stand.jpg" alt="kirito and U/GO">&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>傳說對決 桐人語音台詞 來源對照（第一彈）</title><link>https://dwye.dev/post/sao-kirito-aov/</link><pubDate>Sun, 04 Jul 2021 23:41:25 +0800</pubDate><guid>https://dwye.dev/post/sao-kirito-aov/</guid><description>
&lt;p>身為一個業餘 SAO 粉來就該來發一篇粉絲文。也好久沒寫技術文以外的東西了，就來寫點興趣導向的東西吧。&lt;br>
這邊語音出處基本上都是刀劍神域第一季，除了大招的之外（大概是第一季沒有符合的招式吧 XD）。&lt;br>
找的方法就是打開訓練場聽台詞，把台詞打下來，然後 Google，再開動畫去裡面找。&lt;/p>
&lt;h2 id="選角">選角&lt;/h2>
&lt;p>&lt;img src="https://dwye.dev/img/SAO/kirito1.jpg" alt="kirito">&lt;/p>
&lt;blockquote>
&lt;p>必ず勝つ、勝ってこの世界を終わらせる&lt;/p>
&lt;/blockquote>
&lt;p>我一定會贏的，打贏他並且終結這個世界&lt;br>
出處：第 14 話，8:10，桐人在跟茅場決鬥前對亞絲娜說&lt;br>
&lt;img src="https://dwye.dev/img/SAO/the_world.jpg" alt="kirito hug asuna">&lt;/p>
&lt;blockquote>
&lt;p>君たちは、俺が絶対に守るから&lt;/p>
&lt;/blockquote>
&lt;p>我一定會全力保護你們的&lt;br>
出處：第 3 話，10:42，跟幸同床的桐人在心中表示絕對會保護他們（QAQ&lt;/p>
&lt;blockquote>
&lt;p>ビーター、いい呼び名だな、それ&lt;/p>
&lt;/blockquote>
&lt;p>封弊者，這叫法聽起來不錯嘛&lt;br>
出處：第 2 話，20:20，打倒第一層 boss 後桐人被嘴封弊者&lt;br>
&lt;img src="https://dwye.dev/img/SAO/beater.jpg" alt="beater kirito">&lt;/p>
&lt;h2 id="平常">平常&lt;/h2>
&lt;blockquote>
&lt;p>俺は、俺は、生き延びて見せる、この世界で&lt;/p>
&lt;/blockquote>
&lt;p>我，我啊，一定會活下去的，在這個世界&lt;br>
出處：第 1 話，21:28，桐人和克萊因道別後，一個人率先衝去隔壁城鎮的途中說的（同時也使出了 Rage Spike）&lt;/p>
&lt;blockquote>
&lt;p>このゲームは遊びじゃないだ&lt;/p>
&lt;/blockquote>
&lt;p>這遊戲可不是鬧著玩的&lt;br>
出處：第 4 話 9:03，桐人跟西莉卡解釋紅色玩家&lt;br>
&lt;img src="https://dwye.dev/img/SAO/game.jpg" alt="kirito eat with silica">&lt;/p>
&lt;blockquote>
&lt;p>君は、何があろうと帰してみせる、あの世界に&lt;/p>
&lt;/blockquote>
&lt;p>無論發生什麼事，我都會把你送回去的，回到現實世界裡&lt;br>
出處：第 10 話，紅色殺意 18:25，桐人差點被亞絲娜的前護衛幹掉，事情解決之後的對話&lt;br>
&lt;img src="https://dwye.dev/img/SAO/kiss.jpg" alt="kirito kiss asuna">&lt;/p>
&lt;blockquote>
&lt;p>たかが数字が増えるだけで無茶な差が着く。それがレベル制MMOの理不尽さなんだ&lt;/p>
&lt;/blockquote>
&lt;p>只是增加數字就能拉大實力的差距，這就是等級制 MMO RPG 不合理的地方&lt;br>
出處：第 4 話 19:44，桐人站著給橘色公會的人打&lt;br>
&lt;img src="https://dwye.dev/img/SAO/stand_kirito.jpg" alt="kirito not hurt">&lt;/p>
&lt;blockquote>
&lt;p>誰かを見殺しにするくらいなら、一緒に死んだ方がずっとマシだ&lt;/p>
&lt;/blockquote>
&lt;p>與其見死不救，不如一起死去比較好吧&lt;br>
出處：第 7 話，心的溫度 11:19，莉茲貝特問桐人為何要冒風險救她&lt;/p>
&lt;h2 id="首殺">首殺&lt;/h2>
&lt;blockquote>
&lt;p>これはデュエルじゃない、単純な殺し合いだ&lt;/p>
&lt;/blockquote>
&lt;p>這不是決鬥，只是單純的互相殺害&lt;br>
出處：第 14 話，9:55，75 層打完 boss 後，和茅場單挑&lt;br>
&lt;img src="https://dwye.dev/img/SAO/koroshiai.jpg" alt="kirito and kayaba">&lt;/p>
&lt;h2 id="多殺">多殺&lt;/h2>
&lt;blockquote>
&lt;p>俺はビーターだ、元テスター如きと一緒にしないでくれ&lt;/p>
&lt;/blockquote>
&lt;p>我就是封弊者，不要把我和那些封測玩家相提並論&lt;br>
出處：第 2 話，20:26，打倒第一層 boss 後桐人被嘴封弊者&lt;/p>
&lt;h2 id="死亡">死亡&lt;/h2>
&lt;blockquote>
&lt;p>ごめん、君だけは生きて&lt;/p>
&lt;/blockquote>
&lt;p>抱歉了，至少你要好好活下去&lt;br>
出處：第 14 話，11:01，桐人被茅場引用使出 Eclipse 的時候&lt;br>
&lt;img src="https://dwye.dev/img/SAO/eclipse.jpg" alt="eclipse">&lt;/p>
&lt;h2 id="復活">復活&lt;/h2>
&lt;blockquote>
&lt;p>この世界での強さは、単なる幻想に過ぎない。そんなものより、もっと大事なものがある&lt;/p>
&lt;/blockquote>
&lt;p>在這個世界再如何強大，也只不過是幻想而已。比起這些，還有更重要的事物。&lt;br>
出處：第 4 話 21:05，桐人安慰西莉卡的等級差距&lt;br>
&lt;img src="https://dwye.dev/img/SAO/strength.jpg" alt="kirito and silica and bed">&lt;/p>
&lt;h2 id="技能">技能&lt;/h2>
&lt;p>以一二三技能排序：&lt;/p>
&lt;blockquote>
&lt;p>スターバースト・ストリーム&lt;/p>
&lt;/blockquote>
&lt;p>Starburst Stream / 星光流連擊（星爆氣流斬）&lt;br>
第 9 話，13:45 開始，不解釋&lt;/p>
&lt;blockquote>
&lt;p>レイジ・スパイク&lt;/p>
&lt;/blockquote>
&lt;p>Rage Spike / 憤怒刺擊&lt;br>
單手劍突進技&lt;br>
第 1 話，21:30 開始&lt;br>
&lt;img src="https://dwye.dev/img/SAO/rage_spike.jpg" alt="rage spike">&lt;/p>
&lt;blockquote>
&lt;p>ライトニング・フォール&lt;/p>
&lt;/blockquote>
&lt;p>Lightning Fall / 閃電墜擊&lt;br>
單手劍廣範圍攻擊技&lt;br>
出處：第二季第 17 話，聖劍篇，桐人對寶物堆使用，用來找出雷屬性的槌子（動畫沒有喊出招式名&amp;hellip;這個超難找）&lt;br>
&lt;img src="https://dwye.dev/img/SAO/ligntning_fall.jpg" alt="lightning fall">&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">キリトが使ったのは《ライトニング・フォール》というソードスキルで、真下への物理ダメージに加えて、周囲にスタン効果のある範囲攻撃を行うという技です。 &lt;a href="https://twitter.com/hashtag/sao2_jk?src=hash&amp;amp;ref_src=twsrc%5Etfw">#sao2_jk&lt;/a>&lt;/p>&amp;mdash; 川原礫;SAOP8巻6月発売 (@kunori) &lt;a href="https://twitter.com/kunori/status/528910909079425024?ref_src=twsrc%5Etfw">November 2, 2014&lt;/a>&lt;/blockquote> &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;p>根據川原自己的描述和小說內容，是從高處落下，對下方使用的廣範圍雷屬性 + 物理攻擊&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Rake Tasks 進階：Invoke, Execute, Enhance</title><link>https://dwye.dev/post/rake-execute-invoke-enhance/</link><pubDate>Thu, 01 Jul 2021 13:41:25 +0800</pubDate><guid>https://dwye.dev/post/rake-execute-invoke-enhance/</guid><description>
&lt;p>在「&lt;a href="https://dwye.dev/post/rake">如何在 Rails 中寫 Rake Tasks&lt;/a>」一文中，已經紀錄了在 Ruby on Rails 中 Rake Task 的基本寫法。&lt;/p>
&lt;p>這邊要來談一些最近碰到的議題：&lt;/p>
&lt;ul>
&lt;li>如何直接在一個 rake task 中呼叫另一個 rake task？&lt;/li>
&lt;li>或是如何在一個 rake task 執行時，做額外的事情？&lt;/li>
&lt;/ul>
&lt;h2 id="在程式中呼叫-rake-task-invoke-與-execute">在程式中呼叫 Rake Task: Invoke 與 Execute&lt;/h2>
&lt;p>如果我們想要在 ruby 的程式中執行一個 rake task，可以使用 &lt;code>Rake::Task['rake::name'].invoke&lt;/code>，或是 &lt;code>Rake::Task['rake::name'].execute&lt;/code>。&lt;/p>
&lt;h3 id="invoke-與-execute-的差別">Invoke 與 Execute 的差別&lt;/h3>
&lt;p>一般執行 Rake task 時，會先 invoke 該 task，然後依序 invoke 其 dependencies，然後 execute dependencies，接著才 execute 我們從外部 invoke 的 task。&lt;/p>
&lt;p>也因此兩者的差別在於：&lt;/p>
&lt;ul>
&lt;li>&lt;code>invoke&lt;/code> 如同在 command line 呼叫，完整的拉起 dependencies，並且每個 task 只會執行一次。&lt;/li>
&lt;li>&lt;code>execute&lt;/code> 直接執行該 task 內容，不管該 task 有沒有被執行過。&lt;/li>
&lt;/ul>
&lt;h3 id="寫點-code-做實驗">寫點 Code 做實驗&lt;/h3>
&lt;p>我們利用「&lt;a href="https://dwye.dev/post/rake">如何在 Rails 中寫 Rake Tasks&lt;/a>」中定義好的 Task &lt;code>hello:world&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">namespace &lt;span style="color:#e6db74">:hello&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
desc &lt;span style="color:#e6db74">&amp;#39;print hello world&amp;#39;&lt;/span>
task &lt;span style="color:#e6db74">world&lt;/span>: &lt;span style="color:#e6db74">%w[hello:man hello:earth]&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;Hello, world!&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
task &lt;span style="color:#e6db74">earth&lt;/span>: &lt;span style="color:#e6db74">%w[hello:man]&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;Hello, Earth~&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
task &lt;span style="color:#e6db74">:man&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;Hello, man.&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外再加上兩個 tasks，分別用上了 &lt;code>invoke&lt;/code> 和 &lt;code>execute&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">task &lt;span style="color:#e6db74">:invoke&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;hello:world&amp;#39;&lt;/span>&lt;span style="color:#f92672">].&lt;/span>invoke
&lt;span style="color:#66d9ef">end&lt;/span>
task &lt;span style="color:#e6db74">:execute&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;hello:world&amp;#39;&lt;/span>&lt;span style="color:#f92672">].&lt;/span>execute
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>分別執行這兩個 tasks:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ bundle exec rake invoke
Hello, man.
Hello, Earth~
Hello, world!
$ bundle exec rake execute
Hello, world!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以發現 execute &lt;code>hello:world&lt;/code> 這個 task，並不會跟著跑他的 dependencies &lt;code>hello:man&lt;/code> 和 &lt;code>hello:earth&lt;/code>&lt;/p>
&lt;h3 id="更多實驗">更多實驗&lt;/h3>
&lt;p>rake 其實是可以一次 invoke 多個的，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">bundle exec rake db:create db:migrate db:seed
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以我們也可以分別將剛剛的 &lt;code>invoke&lt;/code> 和 &lt;code>excute&lt;/code> 排列組合一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ bundle exec rake execute invoke
Hello, world!
Hello, man.
Hello, Earth~
Hello, world!
$ bundle exec rake invoke execute
Hello, man.
Hello, Earth~
Hello, world!
Hello, world!
$ bundle exec rake invoke invoke
Hello, man.
Hello, Earth~
Hello, world!
$ bundle exec rake execute execute
Hello, world!
Hello, world!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>前兩種組合的結果告訴我們，先 &lt;code>execute&lt;/code> 一次，該 task 下次 &lt;code>invoke&lt;/code> 時還是會照常被執行。因此 &lt;code>execute&lt;/code> 對於需要直接執行該 task 的 block 裡面的內容是很好用的。&lt;br>
而 &lt;code>invoke&lt;/code> 則是要考慮到之前是不是有被 &lt;code>invoke&lt;/code> 過，如果已經被 &lt;code>invoke&lt;/code> 過，即便再次 &lt;code>invoke&lt;/code> 一次，之後就不會再重複 &lt;code>execute&lt;/code> 了&lt;/p>
&lt;h3 id="如何重複-invoke-一個-task">如何重複 invoke 一個 task？&lt;/h3>
&lt;p>使用 &lt;code>reenable&lt;/code> 這個方法即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">task &lt;span style="color:#e6db74">:reenable&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;Reenable!&amp;#39;&lt;/span>
&lt;span style="color:#75715e"># because we invoke `invoke` to invoke `hello:world`, we need to re-enable both&lt;/span>
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;invoke&amp;#39;&lt;/span>&lt;span style="color:#f92672">].&lt;/span>reenable
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;hello:world&amp;#39;&lt;/span>&lt;span style="color:#f92672">].&lt;/span>reenable
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這樣下次跑 &lt;code>invoke&lt;/code> 就會重複印出 &lt;code>Hello, world!&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ bundle exec rake invoke reenable invoke
Hello, man.
Hello, Earth~
Hello, world!
Reenable!
Hello, world!
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="enhance幫-rake-task-打補丁">Enhance：幫 Rake Task 打補丁&lt;/h2>
&lt;p>如果你需要在執行特定的 rake task 前後做特定的事，那使用 &lt;code>enhance&lt;/code> 是不錯的選擇。&lt;code>enhance&lt;/code> 就像是在某個 task 加裝 hook 一樣，執行到該 task 時，就會執行他被 &lt;code>enhance&lt;/code> 的內容。&lt;/p>
&lt;p>一個例子是 &lt;a href="https://github.com/ctran/annotate_models">annotate_models&lt;/a> 這個 gem，可以在 database migration 後，對 model 檔案加上註解，翻開其原始碼，果然是用 &lt;code>enhance&lt;/code> 實現的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#75715e"># https://github.com/ctran/annotate_models/blob/v3.1.1/lib/tasks/annotate_models_migrate.rake&lt;/span>
&lt;span style="color:#e6db74">%w(db:migrate db:migrate:up db:migrate:down db:migrate:reset db:migrate:redo db:rollback)&lt;/span>&lt;span style="color:#f92672">.&lt;/span>each &lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#f92672">|&lt;/span>task&lt;span style="color:#f92672">|&lt;/span>
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">[&lt;/span>task&lt;span style="color:#f92672">].&lt;/span>enhance &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">.&lt;/span>application&lt;span style="color:#f92672">.&lt;/span>top_level_tasks&lt;span style="color:#f92672">.&lt;/span>last&lt;span style="color:#f92672">].&lt;/span>enhance &lt;span style="color:#66d9ef">do&lt;/span>
annotation_options_task &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">.&lt;/span>task_defined?(&lt;span style="color:#e6db74">&amp;#39;app:set_annotation_options&amp;#39;&lt;/span>)
&lt;span style="color:#e6db74">&amp;#39;app:set_annotation_options&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">else&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;set_annotation_options&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">[&lt;/span>annotation_options_task&lt;span style="color:#f92672">].&lt;/span>invoke
&lt;span style="color:#66d9ef">Annotate&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Migration&lt;/span>&lt;span style="color:#f92672">.&lt;/span>update_annotations
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這樣寫之後，當「執行完」上面所窮舉跟 database migration 有關的 rake task 時，就會 block 內的 code。&lt;/p>
&lt;p>那如果要在「執行前」插入 code 呢？&lt;/p>
&lt;p>&lt;code>enhance&lt;/code> 是可以額外增加 dependencies 的，可以將執行前要插入的 code 寫成另一個 rake task，然後將其定義為 &lt;code>enhance&lt;/code> 的 dependencies 即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">task &lt;span style="color:#e6db74">:before&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;before task&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#75715e"># 這裡 dependencies 一定要是 array，不然會報錯&lt;/span>
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;hello:world&amp;#39;&lt;/span>&lt;span style="color:#f92672">].&lt;/span>enhance(&lt;span style="color:#e6db74">%w[before]&lt;/span>) &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;after task&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接著重跑一次 &lt;code>invoke&lt;/code> 這個 task:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ bundle exec rake invoke
Hello, man.
Hello, Earth~
before task
Hello, world!
after task
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以發現 &lt;code>enhance&lt;/code> 的 dependency 會接在原先定義的 dependencies 後面。&lt;/p>
&lt;h3 id="如果-execute-一個被-enhance-的-task-會發生什麼事">如果 Execute 一個被 Enhance 的 Task 會發生什麼事？&lt;/h3>
&lt;p>前面有討論到，如果我們直接 &lt;code>execute&lt;/code> 一個 task，其 dependencies 都會被忽略。而 &lt;code>enhance&lt;/code> 也包含了定義 dependencies 和後方的 block 的部分。揪竟 &lt;code>enhance&lt;/code> 一個 task 會不會對其被 &lt;code>execute&lt;/code> 時產生影響呢？&lt;/p>
&lt;p>實驗一次就會知道了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ bundle exec rake execute
Hello, world!
after task
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>enhance&lt;/code> 的 dependencies 也被扔掉了。&lt;br>
然而其 block 內定義的 code 仍然會執行到。&lt;/p>
&lt;p>這個行為算是我覺得比較容易搞混的地方，老實說 &lt;code>enhance&lt;/code> 給人一種 monkey patch 的感覺，我個人是認為需要謹慎使用。&lt;/p>
&lt;h3 id="enhance-多次的影響">Enhance 多次的影響&lt;/h3>
&lt;p>附帶一提，一個 task 是可以被 &lt;code>enhance&lt;/code> 多次的，每次 &lt;code>enhance&lt;/code> 的結果會依照先後順序疊加：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">task &lt;span style="color:#e6db74">:before&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;before task&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
task &lt;span style="color:#e6db74">:before2&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;before task 2&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;hello:world&amp;#39;&lt;/span>&lt;span style="color:#f92672">].&lt;/span>enhance(&lt;span style="color:#e6db74">%w[before]&lt;/span>) &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;after task&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">Rake&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Task&lt;/span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;hello:world&amp;#39;&lt;/span>&lt;span style="color:#f92672">].&lt;/span>enhance(&lt;span style="color:#e6db74">%w[before2]&lt;/span>) &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;after task 2&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ bundle exec rake invoke
Hello, man.
Hello, Earth~
before task
before task &lt;span style="color:#ae81ff">2&lt;/span>
Hello, world!
after task
after task &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>本文中所有的 code 都放在&lt;a href="https://github.com/dwy6626/rake-experiment/">這個 repo&lt;/a> 的 &lt;code>hello.rake&lt;/code> 檔案內：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/dwy6626/rake-experiment/blob/master/lib/tasks/hello.rake">https://github.com/dwy6626/rake-experiment/blob/master/lib/tasks/hello.rake&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.rubydoc.info/gems/rake/Rake/Task">Rake::Task 官方文件&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dev.to/molly/rake-task-enhance-method-explained-3bo0">Rake::Task .enhance() Method Explained&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>如何在 Rails 中寫 Rake Tasks</title><link>https://dwye.dev/post/rake/</link><pubDate>Sun, 27 Jun 2021 13:41:25 +0800</pubDate><guid>https://dwye.dev/post/rake/</guid><description>
&lt;p>本文使用當下最新的 Ruby 3.0.1 和 Rails 6.1.4 作為示範&lt;/p>
&lt;h2 id="什麼是-rake">什麼是 Rake&lt;/h2>
&lt;p>Rake 就像是 Ruby 的 Make，或是 Golang 的 Mage，其實也就是可以讓我們寫一些基本的 task 和 build 程序的地方。&lt;/p>
&lt;p>在 Ruby on Rails 裡面，已經自帶了幾個常用的 rake tasks（有時候我們也會簡稱 rake）:&lt;/p>
&lt;pre>&lt;code>rake about
rake db:create
rake db:migrate
rake db:seed
&lt;/code>&lt;/pre>&lt;p>當然還有更多，可以用 &lt;code>rake -T&lt;/code> 來查看。&lt;/p>
&lt;h2 id="rails-的-rakefile">Rails 的 Rakefile&lt;/h2>
&lt;p>Rakefile 其實就是 Ruby 的 Makefile，是用來定義 rake 的地方。&lt;/p>
&lt;p>不過如果你在 Rails 的框架中打開 Rakefile，會發現只有簡單兩行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">require_relative &lt;span style="color:#e6db74">&amp;#34;config/application&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">Rails&lt;/span>&lt;span style="color:#f92672">.&lt;/span>application&lt;span style="color:#f92672">.&lt;/span>load_tasks
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你把 Rails 的原始碼打開，發現其中第二行會去讀取 &lt;code>lib/tasks&lt;/code> 裏面的所有檔案:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#75715e"># https://github.com/rails/rails/blob/v6.1.4/railties/lib/rails/engine.rb&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">load_tasks&lt;/span>(app &lt;span style="color:#f92672">=&lt;/span> self)
require &lt;span style="color:#e6db74">&amp;#34;rake&amp;#34;&lt;/span>
run_tasks_blocks(app)
self
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">run_tasks_blocks&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>) &lt;span style="color:#75715e">#:nodoc:&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>
paths&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;lib/tasks&amp;#34;&lt;/span>&lt;span style="color:#f92672">].&lt;/span>existent&lt;span style="color:#f92672">.&lt;/span>sort&lt;span style="color:#f92672">.&lt;/span>each { &lt;span style="color:#f92672">|&lt;/span>ext&lt;span style="color:#f92672">|&lt;/span> load(ext) }
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是說我們不只可以在 &lt;code>Rakefile&lt;/code> 寫 task，也可以在 &lt;code>lib/tasks&lt;/code> 寫，更方便大型專案的管理。&lt;/p>
&lt;p>附帶一提，因為 &lt;code>Rails.application&lt;/code> 繼承了上面的 &lt;code>Engine&lt;/code> class，他還會另外去讀取 &lt;a href="https://github.com/rails/rails/tree/v6.1.4/railties/lib/rails/tasks">Rails 自定義的常用 rake 們&lt;/a>，也就是剛剛提到的 &lt;code>db:create&lt;/code> 之類的 rakes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#75715e"># https://github.com/rails/rails/blob/v6.1.4/railties/lib/rails/application.rb#L526&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">run_tasks_blocks&lt;/span>(app) &lt;span style="color:#75715e">#:nodoc:&lt;/span>
railties&lt;span style="color:#f92672">.&lt;/span>each { &lt;span style="color:#f92672">|&lt;/span>r&lt;span style="color:#f92672">|&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>run_tasks_blocks(app) }
&lt;span style="color:#66d9ef">super&lt;/span>
load &lt;span style="color:#e6db74">&amp;#34;rails/tasks.rb&amp;#34;&lt;/span>
task &lt;span style="color:#e6db74">:environment&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;span style="color:#66d9ef">ActiveSupport&lt;/span>&lt;span style="color:#f92672">.&lt;/span>on_load(&lt;span style="color:#e6db74">:before_initialize&lt;/span>) { config&lt;span style="color:#f92672">.&lt;/span>eager_load &lt;span style="color:#f92672">=&lt;/span> config&lt;span style="color:#f92672">.&lt;/span>rake_eager_load }
require_environment!
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而且在 Rails 中最基本的 &lt;code>environment&lt;/code> rake 也是定義在這裡，他會去讀取 &lt;code>config/environment&lt;/code> 這個檔案。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#75715e"># https://github.com/rails/rails/blob/v6.1.4/railties/lib/rails/application.rb#L365&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">require_environment!&lt;/span> &lt;span style="color:#75715e">#:nodoc:&lt;/span>
environment &lt;span style="color:#f92672">=&lt;/span> paths&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;config/environment&amp;#34;&lt;/span>&lt;span style="color:#f92672">].&lt;/span>existent&lt;span style="color:#f92672">.&lt;/span>first
require environment &lt;span style="color:#66d9ef">if&lt;/span> environment
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="rake-怎麼寫">Rake 怎麼寫&lt;/h2>
&lt;p>實際打開一個 Rails 新專案，會發現 &lt;code>lib/tasks&lt;/code> 這個資料夾已經幫我們保留下來了。在裡面新增一個 rake task:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#75715e"># lib/tasks/hello.rake&lt;/span>
namespace &lt;span style="color:#e6db74">:hello&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
desc &lt;span style="color:#e6db74">&amp;#39;print hello world&amp;#39;&lt;/span>
task &lt;span style="color:#e6db74">:world&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;Hello, world!&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這裡出現了三個 function，或著是說，Rake 的 DSL:&lt;/p>
&lt;ul>
&lt;li>&lt;code>namespace&lt;/code>: 如其名，可以幫助 rake task 命名與分類管理&lt;/li>
&lt;li>&lt;code>desc&lt;/code>: &lt;code>rake -T&lt;/code> 時顯示的描述，rake 必須加上 &lt;code>desc&lt;/code> 才會顯示在 &lt;code>rake -T&lt;/code> 的列表中&lt;/li>
&lt;li>&lt;code>task&lt;/code>: 定義 task 名稱與內容&lt;/li>
&lt;/ul>
&lt;p>附上 Rake 的文件，裡面有更完整的用法：&lt;a href="https://ruby.github.io/rake/Rake/DSL.html">https://ruby.github.io/rake/Rake/DSL.html&lt;/a>&lt;/p>
&lt;p>執行剛寫好的 rake task:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ bundle exec rake hello:world
Hello, world!
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="task-dependencies">Task Dependencies&lt;/h3>
&lt;p>&lt;code>task&lt;/code> 這個 DSL 可以吃除了名稱之外的參數：&lt;/p>
&lt;pre>&lt;code>task task_name
task task_name: dependencies
task task_name, arguments → dependencies
&lt;/code>&lt;/pre>&lt;p>剛剛我們用的是第一個定義。&lt;br>
接下來介紹 dependencies，其實就是在執行這個 rake task 時，哪些 rake 需要被確保執行。&lt;/p>
&lt;p>我們舉最常用的 database 操作相關的 rake 為例子（只截取部分片段）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#75715e"># https://github.com/rails/rails/blob/v6.1.4/activerecord/lib/active_record/railties/databases.rake&lt;/span>
db_namespace &lt;span style="color:#f92672">=&lt;/span> namespace &lt;span style="color:#e6db74">:db&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
desc &lt;span style="color:#e6db74">&amp;#34;Creates the database, loads the schema, and initializes with the seed data (use db:reset to also drop the database first)&amp;#34;&lt;/span>
task &lt;span style="color:#e6db74">setup&lt;/span>: &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;db:create&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">:environment&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;db:schema:load&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">:seed&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這是 &lt;code>db:setup&lt;/code> 這個 rake task 的定義，傳給 task 的是個 hash，一個 key value pair，括號在這裡省略了，&lt;code>setup&lt;/code> 是 &lt;code>task_name&lt;/code>，而後面的 array 則是 &lt;code>dependencies&lt;/code>。&lt;br>
這段 code 的意思是說，當我執行 &lt;code>db:setup&lt;/code> 時，會需要&lt;strong>先&lt;/strong>跑 dependencies 裡面的 task。&lt;br>
這裡的「先」指的是和 task 後面接的 block 相比較，&lt;strong>會先跑 dependencies 才跑 block 內的東西&lt;/strong>。不巧 &lt;code>db:setup&lt;/code> 剛好沒有 block，所以就是把 &lt;code>db:create&lt;/code>、&lt;code>environment&lt;/code>、&lt;code>db:schema:load&lt;/code>、&lt;code>seed&lt;/code> 這幾個 rake 依序執行。&lt;/p>
&lt;p>我們可以修改剛剛的 &lt;code>hello:world&lt;/code> task 來測試 block 和 dependencies 的順序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#75715e"># lib/tasks/hello.rake&lt;/span>
namespace &lt;span style="color:#e6db74">:hello&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
desc &lt;span style="color:#e6db74">&amp;#39;print hello world&amp;#39;&lt;/span>
task &lt;span style="color:#e6db74">world&lt;/span>: &lt;span style="color:#e6db74">%w[hello:man]&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;Hello, world!&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
task &lt;span style="color:#e6db74">:man&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;Hello, man.&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>再跑一次 &lt;code>hello:world&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ bundle exec rake hello:world
Hello, man.
Hello, world!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>會發現寫在 dependencies 的 &lt;code>hello:man&lt;/code> 的確會先被執行，接著才執行 block 內的東西。&lt;/p>
&lt;p>那既然叫做 dependencies，如果被呼叫很多遍，會發生什麼事呢？&lt;br>
可以在同個 namespace 內再定義一個 rake 來實驗看看：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#75715e"># lib/tasks/hello.rake&lt;/span>
namespace &lt;span style="color:#e6db74">:hello&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
desc &lt;span style="color:#e6db74">&amp;#39;print hello world&amp;#39;&lt;/span>
task &lt;span style="color:#e6db74">world&lt;/span>: &lt;span style="color:#e6db74">%w[hello:man hello:earth]&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;Hello, world!&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
task &lt;span style="color:#e6db74">earth&lt;/span>: &lt;span style="color:#e6db74">%w[hello:man]&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;Hello, Earth~&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
task &lt;span style="color:#e6db74">:man&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
puts &lt;span style="color:#e6db74">&amp;#39;Hello, man.&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>現在 &lt;code>world&lt;/code> depends on &lt;code>man&lt;/code> 和 &lt;code>earth&lt;/code>，而 &lt;code>earth&lt;/code> 也 depends on &lt;code>man&lt;/code>。根據我們對 dependency （相依）這個詞的了解，&lt;code>hello:man&lt;/code> 應該只會被執行一遍。&lt;br>
而事實正是如此：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ bundle exec rake hello:world
Hello, man.
Hello, Earth~
Hello, world!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以使用 &lt;code>--trace&lt;/code> 來追蹤 rake task 彼此之間被 invoke 和執行的過程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ bundle exec rake hello:world --trace
** Invoke hello:world &lt;span style="color:#f92672">(&lt;/span>first_time&lt;span style="color:#f92672">)&lt;/span>
** Invoke hello:man &lt;span style="color:#f92672">(&lt;/span>first_time&lt;span style="color:#f92672">)&lt;/span>
** Execute hello:man
Hello, man.
** Invoke hello:earth &lt;span style="color:#f92672">(&lt;/span>first_time&lt;span style="color:#f92672">)&lt;/span>
** Invoke hello:man
** Execute hello:earth
Hello, Earth~
** Execute hello:world
Hello, world!
&lt;/code>&lt;/pre>&lt;/div></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>一次搞懂物件導向程式設計的特性</title><link>https://dwye.dev/post/oop-design-principles/</link><pubDate>Mon, 31 May 2021 00:41:25 +0800</pubDate><guid>https://dwye.dev/post/oop-design-principles/</guid><description>
&lt;p>會寫程式很簡單，寫出好的程式很難。上次寫了一篇 &lt;a href="https://dwye.dev/post/clean-code">Clean Code 筆記&lt;/a>，算是比較進階的，最近剛好複習了比較基本的一些物件導向相關原則與特性，於是就寫出了這篇。&lt;/p>
&lt;p>這些物件導向的基本觀念和 Clean Code 一樣，平常可以幫助自己讓 code 寫得更易懂且更好維護，而且 Code Review 時可以拿來嗆同事（Ｘ），同時也算是面試的熱門考題之一，因此一次整理成一篇記下來，希望能幫助到自己和其他剛好找到這篇的人。&lt;/p>
&lt;p>這邊主要以條列和簡單說明為主，因為我相信原則和定律皆由其簡單的解釋方式，若要更深的討論也是可以分別寫成文章的，但就不是這篇的目的了。&lt;/p>
&lt;p>如果你認為有寫錯或需要補充的，也歡迎留言或&lt;a href="https://dwye.dev/about">寄信&lt;/a>告訴我。&lt;/p>
&lt;h2 id="software-implementation-goal">Software Implementation Goal&lt;/h2>
&lt;ul>
&lt;li>Robustness 可以處理預料外的 input&lt;/li>
&lt;li>Adaptability 在不同平台與環境之間的變動越小越好（現在可以透過 docker 實現）&lt;/li>
&lt;li>Reusability 重複使用&lt;/li>
&lt;/ul>
&lt;h3 id="design-pattern-的面向">Design Pattern 的面向&lt;/h3>
&lt;p>Algorithms: Recursion / Divide-and-conquer / Amortization &amp;hellip;&lt;/p>
&lt;p>Software Design: Template method / Composition / Adapter / Decorator &amp;hellip;&lt;/p>
&lt;p>Software Architecture: MVC / Event Sourcing &amp;hellip;&lt;/p>
&lt;h2 id="物件導向程式設計object-oriented-programmingoop">物件導向程式設計（Object-Oriented Programming，OOP）&lt;/h2>
&lt;h3 id="三個-design-principle">三個 Design Principle&lt;/h3>
&lt;ul>
&lt;li>Abstraction 抽象化
&lt;ul>
&lt;li>將一個複雜的系統，用簡單的方式精準呈現，而不需要知道其實作細節
&lt;ul>
&lt;li>ADT abstract data type: 描述資料結構&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可藉由定義 Public interface 來實現&lt;/li>
&lt;li>Interface vs Class: Interface 是抽象的（what），Class 是細節的（how）
&lt;ul>
&lt;li>A class implements an interface&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Encapsulation 封裝
&lt;ul>
&lt;li>一個元件的內部狀態要可以被隱藏&lt;/li>
&lt;li>Public / Protected / Private
&lt;ul>
&lt;li>Protected 的子類別可以存取，而 Private 不行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Modularity 模組化
&lt;ul>
&lt;li>軟體的不同元件要被分散於不同 functional unit&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="hierarchical-organization">Hierarchical Organization&lt;/h2>
&lt;p>→ reusability&lt;/p>
&lt;ul>
&lt;li>Inheritance 繼承
&lt;ul>
&lt;li>Specialization: 於子類別 override 其 methods&lt;/li>
&lt;li>Extension: 於子類別新增 methods&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Polymorphism 多型
&lt;ul>
&lt;li>一個變數可以是多種型別&lt;/li>
&lt;li>同名 function 能根據其 Input 型別 去 call 不同 function → Overloading&lt;/li>
&lt;li>同名 method 能根據其 Class 去 call 實際上於不同 class 的 method → Duck Typing&lt;/li>
&lt;li>類似 functional programming 的 pattern matching&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>網路上常看到的三大特性：封裝、繼承、多型&lt;/p>
&lt;h2 id="solid-principle">SOLID Principle&lt;/h2>
&lt;p>目的：減少「改程式」。&lt;/p>
&lt;h3 id="single-responsibility-principle--srp-單一職責原則">Single Responsibility Principle / SRP 單一職責原則&lt;/h3>
&lt;p>一個 function 應該只有一個讓你去修改他的理由（一種職責）&lt;/p>
&lt;h3 id="open-closed-principle--ocp-開放閉合原則">Open Closed Principle / OCP 開放閉合原則&lt;/h3>
&lt;p>要設計得易於延展（例如：繼承、增加新 function），不用因新型態、新需求加入而改變原本的部分&lt;/p>
&lt;h3 id="liskov-substitution-principle--lsp-里氏替換原則">Liskov Substitution Principle / LSP 里氏替換原則&lt;/h3>
&lt;p>子類別要能夠完全支援父類別的功能&lt;/p>
&lt;h3 id="interface-segregation-principles--isp-介面隔離原則">Interface Segregation Principles / ISP 介面隔離原則&lt;/h3>
&lt;p>介面功能單一化，不要有龐大的介面&lt;/p>
&lt;h3 id="dependency-inversion-principle--dip-依賴反轉原則">Dependency Inversion Principle / DIP 依賴反轉原則&lt;/h3>
&lt;p>Dependency Injection 依賴注入：讓實作類別 (class) 依賴抽象類別 (interface)，不要讓兩個實作類別直接依賴&lt;/p>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>Data Structures and Algorithms in C++ 2/e by Michael T. Goodrich, Roberto Tamassia, David M. Mount&lt;/li>
&lt;li>&lt;a href="http://teddy-chen-tw.blogspot.com/2014/04/solid.html">SOLID：五則皆變 by 搞笑談軟工&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)">維基百科頁面&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Python 費氏數列解法（五）：不同解法的執行時間比較</title><link>https://dwye.dev/post/python-fibonacci-5/</link><pubDate>Sat, 29 May 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci-5/</guid><description>
&lt;p>終於來到最後一篇了，前面幾篇依序寫了各種不同費氏數列的寫法，包含：&lt;a href="https://dwye.dev/post/python-fibonacci">遞迴、迭代&lt;/a>、&lt;a href="https://dwye.dev/post/python-fibonacci-2">矩陣&lt;/a>、從矩陣衍生的&lt;a href="https://dwye.dev/post/python-fibonacci-3">Fast doubling&lt;/a>、以及最後&lt;a href="https://dwye.dev/post/python-fibonacci-4">公式解&lt;/a>和補充的&lt;a href="https://dwye.dev/post/python-decimal">精確版公式解&lt;/a>。&lt;/p>
&lt;p>從時間複雜度來看，從矩陣開始都是 $O(\lg n)$（如果我們把公式解內指數運算當作 $O(\lg n)$ 的話），那這三個哪個比較快呢？&lt;/p>
&lt;p>&lt;a href="https://yodalee.me/2019/02/2019_fibonacci/">這篇&lt;/a>文章裡面用 c 比較了 fast doubling 和公式解，發現號稱常數時間複雜度的公式解，反而慢上很多，而且還需要考慮精確度問題。&lt;/p>
&lt;p>所以，Fast doubling 勝。&lt;/p>
&lt;p>但在 Python 又是如何呢？前幾篇我們都在講 Python，因此所以我寫了一段 Python code 來做實驗，把這幾篇提到的方法全部一起比較了一下。&lt;/p>
&lt;h2 id="實驗結果">實驗結果&lt;/h2>
&lt;p>&lt;img src="https://i.imgur.com/emlCKFs.png" alt="fibonacci time comparison">&lt;/p>
&lt;p>對照如下：&lt;/p>
&lt;ul>
&lt;li>fib_binet: 公式解（Decimal 實作版本，&lt;a href="https://dwye.dev/post/python-decimal">補充篇&lt;/a>），時間複雜度 $O(\lg n)$&lt;/li>
&lt;li>fib_fast_double: 遞迴版本的 fast double（&lt;a href="(/post/python-fibonacci-3)">第三篇&lt;/a>），時間複雜度 $O(\lg n)$&lt;/li>
&lt;li>fib_fast_double_iter: 迭代版本的 fast double（&lt;a href="(/post/python-fibonacci-3)">第三篇&lt;/a>），時間複雜度 $O(\lg n)$，最快的一個&lt;/li>
&lt;li>fib_matrix: 矩陣解法（&lt;a href="(/post/python-fibonacci-2)">第二篇&lt;/a>），時間複雜度 $O(\lg n)$&lt;/li>
&lt;li>fib_iterative: 迭代解法（&lt;a href="(/post/python-fibonacci-1)">第一篇&lt;/a>），時間複雜度 $O(n)$&lt;/li>
&lt;li>fib_lru: 遞迴解法，加上 lru_cache（&lt;a href="(/post/python-fibonacci-1)">第一篇&lt;/a>），時間複雜度 $O(n)$&lt;/li>
&lt;/ul>
&lt;p>看看那個公式解浮在那個地方 XDDD&lt;/p>
&lt;p>可能是 Decimal 把精確度開高之後效能犧牲太多了，因為常數部分被拉了很高，曲線看起來很接近 $O(1)$。&lt;/p>
&lt;p>如果刪掉公式解之後，其他解法的結果如下：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/6WCIyFC.png" alt="fibonacci time comparison, binet removed">&lt;/p>
&lt;p>相較其他每個解法都跑得快多了，即便是 $O(n)$ 的基本遞迴和迭代也是，有趣的是，使用 lru_cache 的遞迴速度仍然比相同複雜度的迭代版本要來得慢不少，我猜也許是因為重複 call function 並處理 cache 所造成的的 overhead 在 Python 內還是不小，所以能不要偷懶還是不要偷懶，就改寫成 iterative 吧。&lt;/p>
&lt;p>矩陣解和 fast double 雖然都是 $O(lg n)$，但兩者常數也是插上很多，雖然增長速度都很慢，但 fast_double 快上一截，而且又以迭代版本的比遞迴版本的更快。&lt;/p>
&lt;p>最後附上實驗的原始碼：&lt;/p>
&lt;script src="https://gist.github.com/dwy6626/ca70c57da3b79daae1bd8df05e98d0c2.js">&lt;/script>
&lt;p>測試 CPU 是 4.00GHz 的 i7-6700K，作業系統是 ubuntu 18.04，Python 3.9.1。&lt;/p>
&lt;h2 id="後記">後記&lt;/h2>
&lt;p>拖稿了很久，終於來完成這系列文章了。&lt;/p>
&lt;p>原先只打算寫個兩篇，沒想到越深入研究就越拆越多篇出來。其實費氏數列相關的討論還有很多，也有負數、無理數甚至複數的推廣，但後面就是數學系的事情了，對於工數只有線性代數和一點點微分方程基礎的我還是先在此打住好了 XD&lt;/p>
&lt;p>可以來寫最近學的其他東西了～一坑開完又是一坑，這個系列實在有點解題+興趣導向，下次來寫點更實用的好了。&lt;/p>
&lt;h2 id="參考資料">參考資料：&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://hackmd.io/@sysprog/fibonacci-number">費氏數列分析&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yodalee.me/2019/02/2019_fibonacci/">關於費式數列的那些事&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers">Generalizations of Fibonacci numbers&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>使用 Decimal 提高浮點運算精確度</title><link>https://dwye.dev/post/python-decimal/</link><pubDate>Fri, 28 May 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-decimal/</guid><description>
&lt;p>在&lt;a href="https://dwye.dev/post/python-fibonacci-4/">第四篇&lt;/a>提到費氏數列的公式解會遇到浮點數問題，只能精準算到 122 位。因為浮點數是利用二進位的小數來做儲存，對於非二進位的數字會有誤差。而且其儲存位數有上限，對於無理數的運算，超過一定的大小就會出現精確度問題。&lt;/p>
&lt;p>所以這篇就要來簡單使用 Python 內建的 Decimal module 來拉高浮點數運算的精確度。&lt;/p>
&lt;h2 id="以費氏數列公式解為例">以費氏數列公式解為例&lt;/h2>
&lt;p>首先回顧一下公式：&lt;/p>
&lt;p>$$&lt;br>
F_n = \frac{1}{\sqrt{5}}\left( (\frac{1 + \sqrt{5}}{2})^n - (\frac{1 - \sqrt{5}}{2})^n \right)&lt;br>
$$&lt;/p>
&lt;p>可以注意到裡面有無理數，也就是黃金比例的部分。對無理數做 n 次方運算，當 n 放大後很明顯誤差也會樂乘越大。為了提高精確度，我們可以提高儲存的位元。&lt;/p>
&lt;h3 id="decimal-module">Decimal module&lt;/h3>
&lt;p>Python 提供了一個內建 module：&lt;code>Decimal&lt;/code>，是一個十進位運算模型，可以避免一些浮點數誤差問題：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">In [&lt;span style="color:#ae81ff">1&lt;/span>]: &lt;span style="color:#ae81ff">0.1&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0.3&lt;/span>
Out[&lt;span style="color:#ae81ff">1&lt;/span>]: &lt;span style="color:#66d9ef">False&lt;/span>
In [&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#f92672">from&lt;/span> decimal &lt;span style="color:#f92672">import&lt;/span> Decimal
&lt;span style="color:#f92672">...&lt;/span>:
In [&lt;span style="color:#ae81ff">3&lt;/span>]: Decimal(&lt;span style="color:#e6db74">&amp;#39;0.1&amp;#39;&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">==&lt;/span> Decimal(&lt;span style="color:#e6db74">&amp;#39;0.3&amp;#39;&lt;/span>)
Out[&lt;span style="color:#ae81ff">3&lt;/span>]: &lt;span style="color:#66d9ef">True&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意我們是使用 &lt;code>Decimal('0.1')&lt;/code> 而不是 &lt;code>Decimal(0.1)&lt;/code>，因為後者會把不精確的 float 0.1 丟到 Decimal，還是變得不精確：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">In [&lt;span style="color:#ae81ff">4&lt;/span>]: Decimal(&lt;span style="color:#ae81ff">0.1&lt;/span>)
Out[&lt;span style="color:#ae81ff">4&lt;/span>]: Decimal(&lt;span style="color:#e6db74">&amp;#39;0.1000000000000000055511151231257827021181583404541015625&amp;#39;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="套用到費氏數列公式解">套用到費氏數列公式解&lt;/h3>
&lt;p>原本的 code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fib_binet&lt;/span>(n):
golden_ratio &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#f92672">**&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
golden_ratio_alt &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#f92672">**&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> round((golden_ratio &lt;span style="color:#f92672">**&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> golden_ratio_alt &lt;span style="color:#f92672">**&lt;/span> n) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#f92672">**&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我們把數字用 Decimal 包起來：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">accurate_fib_binet&lt;/span>(n):
sqrt5 &lt;span style="color:#f92672">=&lt;/span> Decimal(&lt;span style="color:#ae81ff">5&lt;/span>) &lt;span style="color:#f92672">**&lt;/span> Decimal(&lt;span style="color:#e6db74">&amp;#39;0.5&amp;#39;&lt;/span>)
golden_ratio &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">+&lt;/span> sqrt5) &lt;span style="color:#f92672">/&lt;/span> Decimal(&lt;span style="color:#ae81ff">2&lt;/span>)
golden_ratio_alt &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&lt;/span> sqrt5) &lt;span style="color:#f92672">/&lt;/span> Decimal(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> round((golden_ratio &lt;span style="color:#f92672">**&lt;/span> Decimal(n) &lt;span style="color:#f92672">-&lt;/span> golden_ratio_alt &lt;span style="color:#f92672">**&lt;/span> Decimal(n)) &lt;span style="color:#f92672">/&lt;/span> sqrt5)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>並拿&lt;a href="https://dwye.dev/post/python-fibonacci-3/">矩陣解法&lt;/a>的 &lt;code>fib_fast_double_iter&lt;/code> 來比較：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>:
x &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
diff &lt;span style="color:#f92672">=&lt;/span> decimal_fib_binet(x) &lt;span style="color:#f92672">-&lt;/span> fib_fast_double_iter(x)
&lt;span style="color:#66d9ef">if&lt;/span> diff &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
print(x, diff)
&lt;span style="color:#66d9ef">break&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ python binet_de.py
&lt;span style="color:#ae81ff">123&lt;/span> -1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>嗯？跟原本一樣？&lt;/p>
&lt;p>主要是因為我們的問題最主要是儲存位數不夠，畢竟我們原本的數值就是無理數，用十進位也無法精確表示。&lt;/p>
&lt;p>然而 Decimal module 提供了我們提升精確度的方法：&lt;/p>
&lt;h3 id="以空間換取精確度">以空間換取精確度&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">from&lt;/span> decimal &lt;span style="color:#f92672">import&lt;/span> getcontext
getcontext()&lt;span style="color:#f92672">.&lt;/span>prec &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#75715e"># default is 28&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>把上面這段 code 加進去之後，原本的 while loop 就會跑很久&amp;hellip;，也就代表數字到很大的時候，還是可以算準。我自己測試約可以到四萬附近。&lt;/p>
&lt;p>不過精確度越大，就會算越久，可以從 &lt;code>MAX_PREC&lt;/code> 這個常數看最大可以設到多少：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">In [&lt;span style="color:#ae81ff">1&lt;/span>]: &lt;span style="color:#f92672">from&lt;/span> decimal &lt;span style="color:#f92672">import&lt;/span> MAX_PREC
&lt;span style="color:#f92672">...&lt;/span>: MAX_PREC
Out[&lt;span style="color:#ae81ff">1&lt;/span>]: &lt;span style="color:#ae81ff">999999999999999999&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>不要真的設到這麼大，不然會卡住 &amp;hellip;&lt;/p>
&lt;p>但實際上還是要看應用情境吧，對我來說如果不知道進來的數字會多大，不如直接使用公式解以外的算法比較保險。&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://docs.python.org/3/library/decimal.html">Decimal - Decimal fixed point and floating point arithmetic&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Python 費氏數列解法（四）：公式解與推導</title><link>https://dwye.dev/post/python-fibonacci-4/</link><pubDate>Sun, 09 May 2021 17:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci-4/</guid><description>
&lt;p>在&lt;a href="https://dwye.dev/post/python-fibonacci-2">第二篇&lt;/a>介紹了費氏數列的矩陣解法，不過費氏數列其實是可以直接用公式算出第 n 項的值的，這邊就來介紹並推導一下公式解，順便幫自己複習一下數學 XD&lt;/p>
&lt;h2 id="公式解binets-formula">公式解：Binet&amp;rsquo;s Formula&lt;/h2>
&lt;p>$$&lt;br>
F_n = \frac{1}{\sqrt{5}}\left( (\frac{1 + \sqrt{5}}{2})^n - (\frac{1 - \sqrt{5}}{2})^n \right)&lt;br>
$$&lt;/p>
&lt;p>是的，$\frac{1 + \sqrt{5}}{2}$，傳說中的黃金比例。&lt;/p>
&lt;p>但奇怪，費氏數列不是都是整數嗎？為什麼會跑出一堆根號呢？不信邪的話自己寫程式去跑，就會發現解剛好都是整數：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># binet.py&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fib_binet&lt;/span>(n):
golden_ratio &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#f92672">**&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
golden_ratio_alt &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#f92672">**&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> (golden_ratio &lt;span style="color:#f92672">**&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> golden_ratio_alt &lt;span style="color:#f92672">**&lt;/span> n) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#f92672">**&lt;/span> &lt;span style="color:#ae81ff">0.5&lt;/span>
&lt;span style="color:#75715e"># 一般來說，還是會轉換型態成 int:&lt;/span>
&lt;span style="color:#75715e"># return round((golden_ratio ** n - golden_ratio_alt ** n) / 5 ** 0.5)&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>:
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">30&lt;/span>):
print(fib_binet(i))
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ python binet.py
0.0
1.0
1.0
2.0
3.0
5.0
8.0
13.0
21.0
...
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="公式推導">公式推導&lt;/h2>
&lt;p>這邊需要一些基本的線性代數知識，主要是對角化的部分。&lt;/p>
&lt;p>對於從量子化學領域跳過來的我，解 eigenvalues 就像回母校一樣充滿了熟悉感 XD&lt;/p>
&lt;p>下面就只附上大概的流程，計算細節就都省略。&lt;/p>
&lt;p>讓我們從&lt;a href="https://dwye.dev/post/python-fibonacci-2">第二篇&lt;/a>的矩陣表示法開始：&lt;/p>
&lt;p>$$&lt;br>
\begin{bmatrix}&lt;br>
F(n+1)\\&lt;br>
F(n)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}^{n} \begin{bmatrix}&lt;br>
1\\&lt;br>
0&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>中間的矩陣我們令其為 A：&lt;/p>
&lt;p>$$&lt;br>
A = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>因為要算 A 的 n 次方，可以將其對角化，對角矩陣的 n 次方即是其每個值的 n 次方：&lt;/p>
&lt;p>$$&lt;br>
A^n = (Q\lambda Q^{-1})^n = Q\lambda^nQ^{-1}&lt;br>
$$&lt;/p>
&lt;p>而 A 的兩個 eigenvalues 為：&lt;/p>
&lt;p>$$&lt;br>
\frac{1 \pm \sqrt{5}}{2}&lt;br>
$$&lt;/p>
&lt;p>對應的 eigenvectors 分別為（$+$對$+$，$-$對$-$）：&lt;/p>
&lt;p>$$&lt;br>
t \begin{bmatrix}&lt;br>
1 \\&lt;br>
\frac{- 1 \pm \sqrt{5}}{2}&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>所以原本的 $A^n$ 就可以利用對角化展開：&lt;/p>
&lt;p>$$&lt;br>
A^n = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}^n = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
\frac{- 1 + \sqrt{5}}{2} &amp;amp; \frac{- 1 - \sqrt{5}}{2}&lt;br>
\end{bmatrix} \begin{bmatrix}&lt;br>
\frac{1 + \sqrt{5}}{2} &amp;amp; 0\\&lt;br>
0 &amp;amp; \frac{1 - \sqrt{5}}{2}&lt;br>
\end{bmatrix}^n \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
\frac{- 1 + \sqrt{5}}{2} &amp;amp; \frac{- 1 - \sqrt{5}}{2}&lt;br>
\end{bmatrix}^{-1}&lt;br>
$$&lt;/p>
&lt;p>帶回原本的式子：&lt;/p>
&lt;p>$$&lt;br>
\begin{bmatrix}&lt;br>
F(n+1)\\&lt;br>
F(n)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
\frac{- 1 + \sqrt{5}}{2} &amp;amp; \frac{- 1 - \sqrt{5}}{2}&lt;br>
\end{bmatrix} \begin{bmatrix}&lt;br>
\frac{1 + \sqrt{5}}{2} &amp;amp; 0\\&lt;br>
0 &amp;amp; \frac{1 - \sqrt{5}}{2}&lt;br>
\end{bmatrix}^n \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
\frac{- 1 + \sqrt{5}}{2} &amp;amp; \frac{- 1 - \sqrt{5}}{2}&lt;br>
\end{bmatrix}^{-1} \begin{bmatrix}&lt;br>
1\\&lt;br>
0&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>剩下就是高中數學的程度了，乘開簡化之後就可以得到公式解了。&lt;/p>
&lt;h2 id="公式解的-issues">公式解的 issues&lt;/h2>
&lt;h3 id="浮點數精確度">浮點數精確度&lt;/h3>
&lt;p>可以注意到，公式解多了很多浮點數運算。&lt;/p>
&lt;p>浮點數就是二進位的科學記號，所以當數值大的時候就會有精確度問題出現。因為我們最後會過一個 int，數值小的時候這個誤差其實是不會影響的，但數值夠大就可以看到誤差。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e"># ./binet.py&lt;/span>
&lt;span style="color:#75715e"># ...&lt;/span>
x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>:
x &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
diff &lt;span style="color:#f92672">=&lt;/span> fib_binet(x) &lt;span style="color:#f92672">-&lt;/span> fib_fast_double_iter(x)
&lt;span style="color:#66d9ef">if&lt;/span> diff &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
print(x, diff)
&lt;span style="color:#66d9ef">break&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ python binet.py
&lt;span style="color:#ae81ff">123&lt;/span> -1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>實際寫個 code 去跑就可以發現，在第 124 項之後就會出現誤差。&lt;/p>
&lt;p>其實用上一篇的&lt;a href="https://dwye.dev/post/python-fibonacci-3">fast doubling&lt;/a>來計算，不但沒有慢上多少，也不用擔心誤差問題。&lt;/p>
&lt;h3 id="常數時間">常數時間？&lt;/h3>
&lt;p>不是程式碼沒有迴圈就是常數時間，這個公式裡面有黃金比例次方：&lt;/p>
&lt;p>$$&lt;br>
(\frac{1 + \sqrt{5}}{2})^n&lt;br>
$$&lt;/p>
&lt;p>如果是二的次方，可以靠 shift 來達到常數時間運算，但這是個浮點數次方，以前篇提到的&lt;a href="https://dwye.dev/post/python-fibonacci-3">快速冪 fast doubling&lt;/a> 來計算也是要 $O(\lg n)$ 的複雜度，即便這個增長很小，在理論上也不是常數時間。&lt;/p>
&lt;h2 id="有趣的小故事">有趣的小故事&lt;/h2>
&lt;p>其實會來研究 Python 與費氏數列的，與幾年前一串 &lt;a href="https://www.facebook.com/groups/pythontw/permalink/10158445814613438/">Python Taiwan 的討論串&lt;/a>有關，可惜最熱鬧的那則已經被刪掉了。&lt;/p>
&lt;p>故事大致上就是有人在底下說了費氏數列公式解是 $O(1)$ 的言論，甚至提出只要把 $\pi$ 和 $e$ 等無理數都存在月球上的話，就能直接 $O(1)$ 解決很多問題，嗯&amp;hellip;&lt;/p>
&lt;p>其實 $O(1)$ 在這種時候已經變成迷思了，不然我大可以寫個 function，不管輸入是多少，我都故弄玄虛，算到一個超級大的值，然後再把相對應個輸出丟出去就好，就可以宣稱我是 $O(1)$ 解。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fib_fake_o1&lt;/span>(n):
max_n &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">300&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> n &lt;span style="color:#f92672">&amp;gt;=&lt;/span> max_n:
&lt;span style="color:#66d9ef">raise&lt;/span> &lt;span style="color:#a6e22e">Exception&lt;/span>(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#34;n must be &amp;lt; &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>max_n&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
f1, f2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>
res &lt;span style="color:#f92672">=&lt;/span> f2
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">2&lt;/span>, max_n):
f1, f2 &lt;span style="color:#f92672">=&lt;/span> f2, f1 &lt;span style="color:#f92672">+&lt;/span> f2
&lt;span style="color:#66d9ef">if&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> n:
res &lt;span style="color:#f92672">=&lt;/span> f2
&lt;span style="color:#66d9ef">return&lt;/span> res
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Big O 複雜度分析是把常數忽略的，但實務上那個常數也是重要的。&lt;/p>
&lt;h2 id="小結">小結&lt;/h2>
&lt;p>綜規以上來看，其實公式解也沒這麼厲害，而且也不是真的很省事（誤差問題）。&lt;/p>
&lt;p>不過實務上通常不會需要這麼大的 fibonacci number 吧&amp;hellip;，程式是死的，人是活的，還是要看情況決定哪種解法好。&lt;/p>
&lt;p>大部分時候甚至寫個 O(n) 解法就夠用了。（實際上我面試那天在寫出 O(n）解法之後也沒有再被追問了，畢竟也只是眾多面試題中的其中一個小問題。）&lt;/p>
&lt;h2 id="參考資料">參考資料：&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://blog.yangjerry.tw/2019/01/31/fibonacci-is-bigO1/">O (1) 的費氏數列？公式解就一定是 O (1)？ &lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dotblogs.com.tw/daniel/2018/11/10/161148">為什麼 Float 和 Double 會有誤差 (浮點數儲存原理)&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Python 費氏數列解法（三）：Fast Doubling</title><link>https://dwye.dev/post/python-fibonacci-3/</link><pubDate>Tue, 06 Apr 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci-3/</guid><description>
&lt;p>&lt;a href="https://dwye.dev/post/python-fibonacci-2">上篇&lt;/a>寫到費氏數列的矩陣解法來達成 $O(\lg n)$ 的時間複雜度，實際上可以再做一些變化來簡化計算。如果目標時間複雜度是 $O(\lg n)$，代表我們要能每次直接計算當 n 變成兩倍時的數值。&lt;/p>
&lt;p>下面介紹的 Fast Doubling 方法就是這個例子。&lt;/p>
&lt;h2 id="推導">推導&lt;/h2>
&lt;p>先直接從 2n+1 和 2n 的矩陣開始出發：&lt;/p>
&lt;p>$$&lt;br>
\begin{bmatrix}&lt;br>
F(2n+1)\\&lt;br>
F(2n)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}^{2n}\begin{bmatrix}&lt;br>
1\\&lt;br>
0&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>&lt;a href="https://dwye.dev/post/python-fibonacci-2">上篇&lt;/a>最後的公式告訴我們，中間 1 1 1 0 的矩陣 n 次方可以替換成費氏數 n 附近的矩陣：&lt;/p>
&lt;p>$$&lt;br>
\begin{bmatrix}&lt;br>
F(2n+1)\\&lt;br>
F(2n)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
F(n+1) &amp;amp; F(n)\\&lt;br>
F(n) &amp;amp; F(n-1)&lt;br>
\end{bmatrix}\begin{bmatrix}&lt;br>
F(n+1) &amp;amp; F(n)\\&lt;br>
F(n) &amp;amp; F(n-1)&lt;br>
\end{bmatrix}\begin{bmatrix}&lt;br>
1\\&lt;br>
0&lt;br>
\end{bmatrix}\\&lt;br>
= \begin{bmatrix}&lt;br>
F(n+1)^2 + F(n)^2\\&lt;br>
F(n)(F(n+1) + F(n-1))&lt;br>
\end{bmatrix}\\&lt;br>
= \begin{bmatrix}&lt;br>
F(n+1)^2 + F(n)^2\\&lt;br>
F(n)(2F(n+1) - F(n))&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>最後一次運算我們把 $F(n-1)$ 用費氏數列的定義替換掉了，即 $F(n-1) = F(n+1) - F(n)$。&lt;/p>
&lt;p>整理一下結果，對於奇數和偶數的不同算法如下：&lt;/p>
&lt;ul>
&lt;li>$F(2n+1) = F(n+1)^2 + F(n)^2$&lt;/li>
&lt;li>$F(2n) = F(n)(2F(n+1) - F(n))$&lt;/li>
&lt;/ul>
&lt;p>因此我們每次都可以把 n 變成兩倍，需要進行遞迴次數和&lt;a href="https://dwye.dev/post/python-fibonacci">第一篇&lt;/a>的遞迴解法相比，從 $O(n)$ 變成 $O(\lg n)$，所以時間複雜度也跟著變成 $O(\lg n)$。&lt;/p>
&lt;h2 id="實作">實作&lt;/h2>
&lt;h3 id="遞迴解法">遞迴解法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fibonacci&lt;/span>(n):
&lt;span style="color:#66d9ef">return&lt;/span> recursive(n)[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">recursive&lt;/span>(n):
&lt;span style="color:#75715e"># calculate f(n+1) and f(n)&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> n &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>
q, r &lt;span style="color:#f92672">=&lt;/span> divmod(n, &lt;span style="color:#ae81ff">2&lt;/span>)
f2, f1 &lt;span style="color:#f92672">=&lt;/span> recursive(q) &lt;span style="color:#75715e"># f2 is the larger one&lt;/span>
f2, f1 &lt;span style="color:#f92672">=&lt;/span> f1 &lt;span style="color:#f92672">**&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> f2 &lt;span style="color:#f92672">**&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>, f1 &lt;span style="color:#f92672">*&lt;/span> (&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> f2 &lt;span style="color:#f92672">-&lt;/span> f1)
&lt;span style="color:#66d9ef">if&lt;/span> r &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> f2, f1
&lt;span style="color:#66d9ef">return&lt;/span> f1 &lt;span style="color:#f92672">+&lt;/span> f2, f2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可能有個疑問是，這個遞迴解法會不會像&lt;a href="https://dwye.dev/post/python-fibonacci">第一篇&lt;/a>的遞迴那樣，做了許多重複計算？&lt;br>
答案是&lt;strong>不會&lt;/strong>，因為每次進入 &lt;code>recursive&lt;/code> 的數字一定是前一個的一半，而且 recursive tree 不會有增長，每次呼叫只會重複呼叫自己一次而已，因此不需要另外再做 cache 了。&lt;/p>
&lt;h3 id="迭代解法">迭代解法&lt;/h3>
&lt;p>迭代解法的思考方向，就是去分析我們在遞迴中每步做了什麼，並用迴圈代替。&lt;/p>
&lt;p>這邊比較麻煩的是，遞迴中有個邏輯判斷，當 &lt;code>recursive&lt;/code> 接受到的輸入是奇數時，必須多一個額外步驟，這樣結果才是正確的（因為奇數和偶數的算法不同，而我們預設的是偶數的計算公式）。&lt;/p>
&lt;p>所以我們將 n 往上增長時，會不確定下一步要算到的是 2n 還是 2n+1，不知道需不需要額外的步驟。&lt;/p>
&lt;p>簡單舉個例子，如果我們要計算的 n 是 21，則遞迴計算的是 [21, 10, 5, 2, 1]。用迭代做 bottom-up 的話，就會是 [1, 2, 5, 10, 21]。我們在計算到 2 的下一項時，沒辦法直接預測下一個要算的是 2n 的 4，還是 2n+1 的 5。&lt;/p>
&lt;p>如果沒辦法預測，就記起來就好了 XD&lt;/p>
&lt;p>所以解法就是建立一個 tracker，先記錄我們需要計算的值，然後 bottom-up 組回來。這邊的 tracker 其實就是個 stack，符合 LIFO 的特性（Last-in, First-out）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fib_fast_double_iter&lt;/span>(n):
&lt;span style="color:#75715e"># stack construction&lt;/span>
tracker &lt;span style="color:#f92672">=&lt;/span> []
&lt;span style="color:#66d9ef">while&lt;/span> n &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
tracker&lt;span style="color:#f92672">.&lt;/span>append(n)
n &lt;span style="color:#f92672">//=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#75715e"># initialization&lt;/span>
f1, f2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#75715e"># bottom-up&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> tracker:
n &lt;span style="color:#f92672">=&lt;/span> tracker&lt;span style="color:#f92672">.&lt;/span>pop()
f1, f2 &lt;span style="color:#f92672">=&lt;/span> f1 &lt;span style="color:#f92672">*&lt;/span> (&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> f2 &lt;span style="color:#f92672">-&lt;/span> f1), f1 &lt;span style="color:#f92672">**&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> f2 &lt;span style="color:#f92672">**&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> n &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
f1, f2 &lt;span style="color:#f92672">=&lt;/span> f2, f1 &lt;span style="color:#f92672">+&lt;/span> f2
&lt;span style="color:#66d9ef">return&lt;/span> f1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://chunminchang.github.io/blog/post/calculating-fibonacci-numbers-by-fast-doubling">這篇文章&lt;/a>還用了更進階的技巧，利用二進位表示法其實就是不斷除以二的餘數的特性，把 stack 也省下來了，只需要 $O(1)$ 的空間複雜度。這邊就不繼續探討，有興趣的可以自行去閱讀。&lt;/p>
&lt;h2 id="參考資料">參考資料：&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.geeksforgeeks.org/fast-doubling-method-to-find-the-nth-fibonacci-number/">Fast Doubling method to find the Nth Fibonacci number&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.nayuki.io/page/fast-fibonacci-algorithms">Fast Fibonacci algorithms&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://chunminchang.github.io/blog/post/calculating-fibonacci-numbers-by-fast-doubling">Calculating Fibonacci Numbers by Fast Doubling&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Hugo 排程發表文章</title><link>https://dwye.dev/post/hugo-scheduled-post/</link><pubDate>Sat, 03 Apr 2021 02:59:59 +0800</pubDate><guid>https://dwye.dev/post/hugo-scheduled-post/</guid><description>
&lt;p>不管是 FB 粉專，或是以前無名小站時代的部落格系統，都有提供排程發表文章的功能，讓寫手在靈感特別多的時候，或是行銷人員希望配合特定時程，可以預先寫好未來要發表的文章，並且在時間到的時候自動發表。&lt;/p>
&lt;p>問題來了，如果是使用像 Hugo 這種靜態網站產生器，能否實現相同的功能呢？&lt;/p>
&lt;p>答案是可以的，&lt;a href="//gohugo.io/troubleshooting/faq/#how-do-i-schedule-posts">官方網站&lt;/a>有提到：&lt;/p>
&lt;blockquote>
&lt;h3 id="how-do-i-schedule-posts">How do I schedule posts?&lt;/h3>
&lt;ol>
&lt;li>Set publishDate in the page Front Matter to a date in the future.&lt;/li>
&lt;li>Build and publish at intervals.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>就是叫你把日期設定在未來，然後每隔一段時間部署就好。&lt;/p>
&lt;p>這篇就是要來講我如何使用 GitHub Action 實現排程發表。&lt;/p>
&lt;h2 id="正文">正文&lt;/h2>
&lt;p>&lt;a href="https://dwye.dev/post/hugo-github-action">之前的文章&lt;/a>有提到我把 blog CD 轉換到 GitHub Action。&lt;/p>
&lt;p>&lt;a href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows">GitHub Action 的官方文件&lt;/a>提到，可以使用 cronjob 格式來設定排程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#75715e"># .github/workflows/deploy.yml&lt;/span>
&lt;span style="color:#f92672">on&lt;/span>:
&lt;span style="color:#f92672">push&lt;/span>:
&lt;span style="color:#f92672">branches&lt;/span>:
- &lt;span style="color:#ae81ff">master&lt;/span>
&lt;span style="color:#f92672">schedule&lt;/span>:
- &lt;span style="color:#f92672">cron&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;0 19 * * *&amp;#39;&lt;/span>
&lt;span style="color:#75715e"># 下略&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這邊的時間是 UTC，會在每天 19:00 UTC 跑一次部署，也就是 (19 + 8) % 24 = 台灣時間半夜三點跑 deploy job，重新部署我的 blog。&lt;/p>
&lt;blockquote>
&lt;p>：&lt;em>誰會想在凌晨三點部署部落格&lt;/em>&lt;br>
GitHub Action：&lt;em>歐好棒，三點了&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>我把兩個條件並列，就會變成 or 關係，任一個條件成立（push on master branch 或是每天的半夜三點），都會 trigger 這個 workflow，有了 CD 是不是很方便呢？&lt;/p>
&lt;p>一個需要注意的是，如果你設定的 interval 太短，會自動被拉長到每五分鐘執行一次。&lt;/p>
&lt;h2 id="預覽未來文章">預覽未來文章&lt;/h2>
&lt;p>因為 Hugo 預設會忽略未來與草稿文章，可以分別用 &lt;code>-F&lt;/code> 和 &lt;code>-D&lt;/code> 兩個 flag 來讓 Hugo 把這些文章也 build 起來：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ hugo serve -FD
&lt;/code>&lt;/pre>&lt;/div>&lt;p>想要知道有哪些未來文章可以使用 &lt;code>hugo list&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ hugo list future
&lt;/code>&lt;/pre>&lt;/div>&lt;p>同理，列出草稿：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ hugo list drafts
&lt;/code>&lt;/pre>&lt;/div></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Python 費氏數列解法（二）：矩陣解</title><link>https://dwye.dev/post/python-fibonacci-2/</link><pubDate>Wed, 31 Mar 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci-2/</guid><description>
&lt;p>在&lt;a href="https://dwye.dev/post/python-fibonacci">上篇&lt;/a>我們討論了費氏數列的各種基本解法。&lt;/p>
&lt;p>原本我也以為 O(n) 的迭代解就已經是標準解法了，直到被大神朋友指正：&lt;/p>
&lt;blockquote>
&lt;p>問費氏數列應該是想聽 $O(\lg n)$ 解法吧？&lt;/p>
&lt;/blockquote>
&lt;p>查了一下還真的有，&lt;a href="https://medium.com/fcamels-notes/%E8%B2%BB%E6%B0%8F%E6%95%B8%E5%88%97-o-logn-%E7%9A%84%E8%A7%A3%E6%B3%95-e36067e57baa">這篇文章&lt;/a>寫得蠻完整的，這篇會參考該篇文章來撰寫，但會用我自己的話以及 Python 寫出來。&lt;/p>
&lt;h2 id="哪來的矩陣">哪來的矩陣？&lt;/h2>
&lt;p>$$&lt;br>
\begin{bmatrix}&lt;br>
F(n)\\&lt;br>
F(n-1)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
F(n-1) + F(n-2) \\&lt;br>
F(n-1)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix} \begin{bmatrix}&lt;br>
F(n-1)\\&lt;br>
F(n-2)&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>其實就是將&lt;a href="https://dwye.dev/post/python-fibonacci">上篇&lt;/a>的尾遞迴方法及迭代法中每次的運算內容，使用矩陣乘法表達出來。&lt;/p>
&lt;h2 id="有了矩陣可以幹嘛公式推導">有了矩陣可以幹嘛（公式推導）&lt;/h2>
&lt;p>有了矩陣表示法，對於費氏數列第 n 項 $F(n)$ 就可以表示成：&lt;/p>
&lt;p>$$&lt;br>
\begin{bmatrix}&lt;br>
F(n)\\&lt;br>
F(n-1)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix} &amp;hellip; \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}\begin{bmatrix}&lt;br>
F(2)\\&lt;br>
F(1)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}^{n-2} \begin{bmatrix}&lt;br>
1\\&lt;br>
1&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>兩邊同乘中間那個 1 1 1 0 的矩陣：&lt;/p>
&lt;p>$$&lt;br>
\begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}&lt;br>
\begin{bmatrix}&lt;br>
F(n)\\&lt;br>
F(n-1)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
F(n+1)\\&lt;br>
F(n)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}^{n-1} \begin{bmatrix}&lt;br>
1\\&lt;br>
1&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>又：&lt;/p>
&lt;p>$$&lt;br>
\begin{bmatrix}&lt;br>
F(n)\\&lt;br>
F(n-1)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}^{n-1} \begin{bmatrix}&lt;br>
1\\&lt;br>
0&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>把 $F(n+1)$ 和 $F(n)$ 開頭的兩行做合併之後可以得到更漂亮的寫法：&lt;/p>
&lt;p>$$&lt;br>
\begin{bmatrix}&lt;br>
F(n+1) &amp;amp; F(n)\\&lt;br>
F(n) &amp;amp; F(n-1)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}^{n-1} \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}&lt;br>
$$&lt;/p>
&lt;p>得到最後的公式：&lt;/p>
&lt;p>$$&lt;br>
\begin{bmatrix}&lt;br>
F(n+1) &amp;amp; F(n)\\&lt;br>
F(n) &amp;amp; F(n-1)&lt;br>
\end{bmatrix} = \begin{bmatrix}&lt;br>
1 &amp;amp; 1\\&lt;br>
1 &amp;amp; 0&lt;br>
\end{bmatrix}^{n}&lt;br>
$$&lt;/p>
&lt;h2 id="矩陣的-n-次方真的可以-olg-n-嗎">矩陣的 n 次方真的可以 $O(\lg n)$ 嗎？&lt;/h2>
&lt;p>不同的例子不同，因為矩陣的乘法實際上並不會都是 $O(1)$，但是在這裡我們固定了矩陣的大小為 $2 \times 2$，只會對費氏數列的 n 做增長，因此矩陣乘法本身的複雜度並不會增長。&lt;/p>
&lt;p>這邊有個名詞是&lt;strong>快速冪&lt;/strong>，中文也許不好懂，英文就是 &lt;strong>exponentiation by squaring&lt;/strong>，就是把高次方的 power 用 2 的次方去組合。或著是說，用其二進位時數值是 1 的位元來做組合。&lt;br>
因此算某數的 n 次方，我們只需要進行 $O(\lg n)$ 次計算即可。&lt;/p>
&lt;p>舉個簡單的例子，當計算 x 的 23 次方時，我們知道 23 的二進位可以表示成 10111，因為：&lt;/p>
&lt;p>$$&lt;br>
23 = 2^4 + 2^2 + 2^1 + 2^0&lt;br>
$$&lt;/p>
&lt;p>所以實際上我們只要計算：&lt;/p>
&lt;p>$$&lt;br>
x^{23} = x^{2^4 + 2^2 + 2^1 + 2^0} = x^{16}x^4x^2x&lt;br>
$$&lt;/p>
&lt;p>其中四個數值的次方計算為：&lt;/p>
&lt;ul>
&lt;li>$x^{16} = x^8x^8$&lt;/li>
&lt;li>$x^{8} = x^4x^4$&lt;/li>
&lt;li>$x^{4} = x^2x^2$&lt;/li>
&lt;li>$x^{2} = xx$&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>時間複雜度&lt;/strong>和&lt;strong>空間複雜度&lt;/strong>都是 $O(\lg n)$&lt;/p>
&lt;p>拿來應用在矩陣上，就是所謂&lt;strong>矩陣快速冪&lt;/strong>&lt;/p>
&lt;h2 id="說了這麼多給我-code-吧">說了這麼多，給我 code 吧&lt;/h2>
&lt;p>這裡參考了 &lt;a href="https://leetcode.com/problems/fibonacci-number/solution/">leetcode 的官方解法&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fibonacci&lt;/span>(n):
A &lt;span style="color:#f92672">=&lt;/span> [[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>], [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>]]
power(A, n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> A[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">power&lt;/span>(A, n):
&lt;span style="color:#66d9ef">if&lt;/span> n &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> A
q, r &lt;span style="color:#f92672">=&lt;/span> divmod(n, &lt;span style="color:#ae81ff">2&lt;/span>)
power(A, q)
multiply(A, A)
&lt;span style="color:#66d9ef">if&lt;/span> r &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
multiply(A, [[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>], [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>]])
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">multiply&lt;/span>(A, B):
x &lt;span style="color:#f92672">=&lt;/span> A[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> B[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> A[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> B[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>]
y &lt;span style="color:#f92672">=&lt;/span> A[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> B[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> A[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> B[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>]
z &lt;span style="color:#f92672">=&lt;/span> A[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> B[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> A[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> B[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>]
w &lt;span style="color:#f92672">=&lt;/span> A[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> B[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> A[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">*&lt;/span> B[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>]
A[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> x
A[&lt;span style="color:#ae81ff">0&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> y
A[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> z
A[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> w
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因為要進行矩陣運算，我們必須另外實作相關 code，所以才多了 &lt;code>power&lt;/code> 和 &lt;code>multiply&lt;/code> 兩個 function。&lt;br>
當然，也可以直接使用 numpy：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fibonacci&lt;/span>(n):
&lt;span style="color:#75715e"># 但我自己測試，這個會有精確度問題&lt;/span>
A &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>array([[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>], [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>]])
&lt;span style="color:#66d9ef">return&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>linalg&lt;span style="color:#f92672">.&lt;/span>matrix_power(A, n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上就是費氏數列的 $O(\lg n)$ 矩陣解法。&lt;/p>
&lt;p>不過其實這個方法還能進一步改善，就留到&lt;a href="https://dwye.dev/post/python-fibonacci-3">下一篇&lt;/a>再說明吧。&lt;/p>
&lt;h2 id="參考資料">參考資料：&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://medium.com/fcamels-notes/%E8%B2%BB%E6%B0%8F%E6%95%B8%E5%88%97-o-logn-%E7%9A%84%E8%A7%A3%E6%B3%95-e36067e57baa">Medium 文章：費氏數列 O (LogN) 的解法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/fibonacci-number/solution/">LeetCode 509. Fibonacci Number 的 Solution&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Google Domain 客製化 Email Address</title><link>https://dwye.dev/post/google-domain-mail/</link><pubDate>Tue, 30 Mar 2021 16:01:56 +0800</pubDate><guid>https://dwye.dev/post/google-domain-mail/</guid><description>
&lt;p>&lt;a href="https://dwye.dev/post/github-page-google-domain">在 Google Domain 買了網域之後&lt;/a>，就覺得該多利用一下這個新的個人網域 &lt;code>dwye.dev&lt;/code>。&lt;/p>
&lt;p>最簡單的事情就是做一個 email address。&lt;/p>
&lt;p>原本以為會需要配合 Google Workspace (原本的 G Suite，畢竟在 Google Domain 一直出現他的廣告&amp;hellip;)，後來才發現其實 Google Domain 可以直接免費設置轉信到現有信箱。&lt;/p>
&lt;p>&lt;strong>還可以 100 筆。&lt;/strong>&lt;/p>
&lt;p>又是 100，跟之前 Blogger 的一個帳號最多 100 個 blog 一樣，100 是什麼 magic number 嗎？&lt;/p>
&lt;h2 id="正文">正文&lt;/h2>
&lt;ul>
&lt;li>進入 Google Domain，選擇你的網域&lt;/li>
&lt;li>在側邊欄選擇電子郵件&lt;/li>
&lt;li>忽略 Google Workspace 的廣告，捲到底下有個「電子郵件轉寄」，直接給他新增一個電子郵件別名&lt;/li>
&lt;/ul>
&lt;p>然後&amp;hellip;就沒了ˊˋ&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/beV5sj3.png" alt="customized email address in google domain">&lt;/p>
&lt;p>用起來又是意外的簡單，感謝 Google Domain 讓我洗文章（Ｘ&lt;/p>
&lt;p>&lt;del>可以去更新履歷了（不是才剛找完工作&lt;/del>&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Python 費氏數列解法（一）</title><link>https://dwye.dev/post/python-fibonacci/</link><pubDate>Sun, 28 Mar 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci/</guid><description>
&lt;p>面試被問到的題目，雖然是很基本的題目，但相關延伸也有不少，寫篇文章記錄一下。&lt;/p>
&lt;h2 id="遞迴最基本又直觀的解法">遞迴：最基本又直觀的解法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fibonacci&lt;/span>(n):
&lt;span style="color:#66d9ef">if&lt;/span> n &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> fibonacci(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> fibonacci(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="時間複雜度">時間複雜度&lt;/h3>
&lt;p>$O(2^n)$，每次呼叫 &lt;code>fibonacci(n)&lt;/code> 都會進行額外兩次呼叫，n 每次會 -1，直到 n == 2。整個呼叫會是高度 n 的二元樹的子集合，而每次運行時間都是 $O(1)$，因此整體時間的 upper bound 就是二元樹的節點數量：&lt;/p>
&lt;p>$$&lt;br>
2^0 + 2^1 + 2^2 + &amp;hellip; + 2^{n-1} = \frac{2^n - 1}{2 - 1}&lt;br>
$$&lt;/p>
&lt;h3 id="空間複雜度">空間複雜度&lt;/h3>
&lt;p>$O(1)$&lt;/p>
&lt;h2 id="遞迴優化利用-hash-減少計算次數">遞迴優化：利用 Hash 減少計算次數&lt;/h2>
&lt;p>在原本的解法中，會有很多次重複計算 &lt;code>fibonacci(n-1)&lt;/code>, &lt;code>fibonacci(n-2)&lt;/code> &amp;hellip; 等，因此可以把計算結果儲存起來，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fibonacci&lt;/span>(n):
table &lt;span style="color:#f92672">=&lt;/span> {}
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fib_table&lt;/span>(n):
&lt;span style="color:#66d9ef">if&lt;/span> n &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
table[n] &lt;span style="color:#f92672">=&lt;/span> fib_table(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> fib_table(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> table[n]
&lt;span style="color:#66d9ef">return&lt;/span> fib_table(n)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這邊我利用了 Python 變數 scope 的 LEGB 特性，也就是查找順序為：local, enclosed, global, built-in。可以參見&lt;a href="https://docs.python.org/3/tutorial/classes.html">官方 document&lt;/a>，有趣的是 LEGB 並不是官方名詞而是社群流傳的口訣。&lt;/p>
&lt;p>也許聽起來很複雜，但其實也就是簡單的&lt;strong>往外查找&lt;/strong>規則罷了。&lt;/p>
&lt;p>因此 &lt;code>table&lt;/code> 雖然是在外部的 &lt;code>fibonacci&lt;/code> 定義的，但 &lt;code>fib_table&lt;/code> 內（local）沒有另外定義 &lt;code>table&lt;/code> 變數的情況下，會往外查找，因此可以讀取外部的 &lt;code>table&lt;/code>（enclosed）。&lt;/p>
&lt;p>可能有人會問，我有 assign 值到 &lt;code>table&lt;/code> 內部啊，這樣不用宣告 &lt;code>global table&lt;/code> 嗎？答案是不需要的，在 Python 中，&lt;code>table&lt;/code> 變數存的是物件的 reference，因此改變物件內的屬性並不會影響 &lt;code>table&lt;/code> 這個變數。而 &lt;code>table[n] = fib_table(n-1) + fib_table(n-2)&lt;/code> 這行實際上是呼叫了 &lt;code>table&lt;/code> 指向的物件的 &lt;code>__setitem__&lt;/code> 方法，改變物件內部的屬性。&lt;/p>
&lt;h3 id="時間複雜度-1">時間複雜度&lt;/h3>
&lt;p>$O(n)$，對每個 n 只需要算一遍，不會每次都要往 n-1，n-2 展開。&lt;/p>
&lt;h3 id="空間複雜度-1">空間複雜度&lt;/h3>
&lt;p>$O(n)$，&lt;code>table&lt;/code> 需要存 &lt;code>fib_table(3)&lt;/code> 到 &lt;code>fib_table(n)&lt;/code> 的結果。&lt;/p>
&lt;h2 id="遞迴優化使用-cache">遞迴優化：使用 Cache&lt;/h2>
&lt;p>Python 有內建的 Cache 可以記錄函式呼叫結果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#a6e22e">@cache&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fibonacci&lt;/span>(n):
&lt;span style="color:#66d9ef">if&lt;/span> n &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> fibonacci(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> fibonacci(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這其實就是第一個解法加上一行 &lt;code>@cache&lt;/code> 而已。&lt;/p>
&lt;p>在函式開頭加上 &lt;code>@something&lt;/code> 的寫法是呼叫 Python 中的 decorator，是 Python 中一個重要的特性。在 Python 語言中，函式是一等公民，也就是函式可以被當作變數 assign，也可以當作參數傳遞。 decorator 實際上就是把他裝飾的函式傳到 decorator 內部再做一些事情，以這邊的 &lt;code>@cache&lt;/code> 為例，decorator 會自動幫忙把 &lt;code>fibonacci&lt;/code> 這個函式的呼叫結果記錄起來，並回傳&lt;strong>包裝後的函數&lt;/strong>，我們最後拿到的 &lt;code>fibonacci&lt;/code> 實際上會多了包裝後的方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">&amp;gt;&lt;/span> fibonacci&lt;span style="color:#f92672">.&lt;/span>__dir__()
[&lt;span style="color:#e6db74">&amp;#39;cache_parameters&amp;#39;&lt;/span>,
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;cache_info&amp;#39;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#39;cache_clear&amp;#39;&lt;/span>,
&lt;span style="color:#f92672">...&lt;/span>
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>比自己用 hash 實作簡單多了。&lt;/p>
&lt;p>這邊的 &lt;code>cache&lt;/code> 實際上是 &lt;code>functools.lru_cache(maxsize=None)&lt;/code>，一個不限制大小的 LRU Cache，如果想要限制大小可以在修改 &lt;code>maxsize&lt;/code> 發揮 LRU 的功能。&lt;/p>
&lt;p>學會了這招才是真正的 Pythonist。&lt;/p>
&lt;h3 id="cache-size-要設定成多少">Cache Size 要設定成多少？&lt;/h3>
&lt;p>既然可以設定 cache size，我們真的需要一直記著每次計算的結果嗎？&lt;/p>
&lt;p>當計算第 n 項時，只需要 n-1 和 n-2 兩項結果，所以就設成 2 就好了對吧？但如果直接這樣改，會發現程式跑的時間還是會變很長。&lt;/p>
&lt;p>實際上當計算 n-1 時，需要知道 n-2 和 n-3 的值，先計算 n-2 後計算 n-3。因此最後 cache 內記錄的會是 n-1 和 n-3 的值。&lt;br>
所以會在接下來算 n-2 時造成一個 cache miss。&lt;/p>
&lt;p>如果不改其他部分，可以把 &lt;code>maxsize&lt;/code> 設成 3，就可以避免掉這個 cache miss。&lt;/p>
&lt;p>但仔細思考，其實會有這個 miss，歸根究底是我們先計算比較靠近 n 的 n-1，後計算比較遠離 n 的 n-2 造成的。那何不將兩者交換呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#a6e22e">@lru_cache&lt;/span>(maxsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fibonacci&lt;/span>(n):
&lt;span style="color:#66d9ef">if&lt;/span> n &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> fibonacci(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> fibonacci(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>做完簡單的修改，一樣漂亮的 code，可以給出不錯的時間複雜度和常數的空間複雜度。&lt;/p>
&lt;h3 id="時間複雜度-2">時間複雜度&lt;/h3>
&lt;p>$O(n)$，不會有 cache miss，每個 n 只需要計算一次。&lt;/p>
&lt;h3 id="空間複雜度-2">空間複雜度&lt;/h3>
&lt;p>$O(1)$，因為 cache size 最大是 2。&lt;/p>
&lt;h2 id="尾遞迴-tail-recursive--tail-call">尾遞迴 Tail Recursive / Tail Call&lt;/h2>
&lt;p>當函式本身在回傳時會呼叫自己即為尾遞迴，可以說是遞迴中的特例。&lt;/p>
&lt;p>要撰寫尾遞迴，需要思考每次遞迴時我們往前取了什麼資訊。在上一個 LRU cache 的解法中知道，我們只需要紀錄 n-2 和 n-1 兩個值即可。分別命名為 &lt;code>f1&lt;/code> 和 &lt;code>f2&lt;/code>，每次呼叫我們把 n 減 1，把 &lt;code>f1&lt;/code> 指定為 &lt;code>f2&lt;/code>，並把 &lt;code>f2&lt;/code> 改為 &lt;code>f1 + f2&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fibonacci&lt;/span>(n):
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fib_tail_recursive&lt;/span>(n, f1, f2):
&lt;span style="color:#66d9ef">if&lt;/span> n &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> f2
&lt;span style="color:#66d9ef">return&lt;/span> fib_tail_recursive(n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, f2, f1 &lt;span style="color:#f92672">+&lt;/span> f2)
&lt;span style="color:#66d9ef">return&lt;/span> fib_tail_recursive(n, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>尾遞迴的版本我認為比較不好理解，但是為了下一個迭代法，還是練習了一下尾遞迴的解法。&lt;/p>
&lt;p>下面對於不同的 n 做分析：&lt;/p>
&lt;ul>
&lt;li>初始時 &lt;code>f1&lt;/code> 和 &lt;code>f2&lt;/code> 分別代表第一項和第二項，都是 1。&lt;/li>
&lt;li>當 n &amp;lt; 3 時直接回傳 &lt;code>f1&lt;/code> 為 1&lt;/li>
&lt;li>當 n = 3 時，會跑一次尾遞迴，此時 n 變成 2，&lt;code>f1&lt;/code> 變成 1， &lt;code>f2&lt;/code> 變成 1 + 1 = 2，接著回傳 &lt;code>f2&lt;/code> 即為 2&lt;/li>
&lt;/ul>
&lt;p>以下依此類推&amp;hellip;&lt;/p>
&lt;h3 id="時間複雜度-3">時間複雜度&lt;/h3>
&lt;p>$O(n)$，從 n 呼叫到 2。&lt;/p>
&lt;h3 id="空間複雜度-3">空間複雜度&lt;/h3>
&lt;p>$O(1)$，沒有額外的 cache 或是查表。&lt;/p>
&lt;h2 id="迭代法使用迴圈攤平遞迴">迭代法：使用迴圈，攤平遞迴&lt;/h2>
&lt;p>尾遞迴是攤平遞迴的中間做法，可以寫成尾遞迴的函式，就能快速改寫成迭代形式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fibonacci&lt;/span>(n):
f1, f2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">2&lt;/span>, n): &lt;span style="color:#75715e"># 當 n &amp;lt; 3 時不會進入迴圈&lt;/span>
f1, f2 &lt;span style="color:#f92672">=&lt;/span> f2, f1 &lt;span style="color:#f92672">+&lt;/span> f2
&lt;span style="color:#66d9ef">return&lt;/span> f2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>做的事情和尾遞迴版本一模一樣。&lt;/p>
&lt;p>也因此有些語言對於尾遞迴有做優化，當編譯器看到尾遞迴，會自動幫你攤平成迴圈（用 GOTO 實現），稱為尾遞迴優化（Tail Call Optimization）。主要會在以 functional programming 為主的語言中看到，例如 erlang 或是 haskell。&lt;/p>
&lt;p>很可惜，Python 是沒有支援的那部分。&lt;/p>
&lt;h3 id="時間複雜度-4">時間複雜度&lt;/h3>
&lt;p>$O(n)$，只有一個迴圈，迴圈內部運算都是 $O(1)$&lt;/p>
&lt;h3 id="空間複雜度-4">空間複雜度&lt;/h3>
&lt;p>$O(1)$，只用了固定兩個變數&lt;/p>
&lt;h2 id="其他解法">其他解法&lt;/h2>
&lt;p>雖然到這邊已經說明完正常的解法，但其實費氏數列還有更多有趣的解法。&lt;/p>
&lt;p>時間複雜度更短的 $O(\lg n)$ 的：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dwye.dev/post/python-fibonacci-2/">矩陣解&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dwye.dev/post/python-fibonacci-3/">快速冪&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dwye.dev/post/python-fibonacci-4/">疑似（？）常數時間但其實最多也只能到 $O(\lg n)$ 的公式解&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>以及&lt;a href="https://dwye.dev/post/python-fibonacci-5/">所有解法的執行時間比較&lt;/a>&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>GitHub Page + Google Domain 設定個人化網域</title><link>https://dwye.dev/post/github-page-google-domain/</link><pubDate>Sat, 27 Mar 2021 19:01:56 +0800</pubDate><guid>https://dwye.dev/post/github-page-google-domain/</guid><description>
&lt;p>以前在 KK 實習時，跟 RD 們聊過自架 blog 的事情，並聽說了這個很潮的 &lt;code>.dev&lt;/code> 網域，就把購買個人網域列為將來想嘗試的事之一。&lt;br>
找工作的事情告一段落了（其實也只是在原本實習的公司轉正職 XD），有了固定收入就可以來養個人品牌了 XD。&lt;/p>
&lt;h2 id="需要做的事情">需要做的事情&lt;/h2>
&lt;ul>
&lt;li>購買一個你喜歡的個人網域，我在 Google Domain 購買&lt;/li>
&lt;li>在 Google Domain 設定你的 GitHub Page url&lt;/li>
&lt;li>在 GitHub Repo 設定你的個人網域以及 HTTPS&lt;/li>
&lt;li>修改 Repo 內相關設定&lt;/li>
&lt;/ul>
&lt;h2 id="google-domain">Google Domain&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://domains.google.com/">https://domains.google.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Google 自家的網域供應商，也提供了 DNS 服務，Google 雖然 do evil 但他們家服務的可靠性還是直得讚賞的，也不會跟你搞奇怪的首年特價第二年漲價。我二話不說直接選了 Google Domain 來購買個人網域。&lt;/p>
&lt;p>&lt;code>dwye.dev&lt;/code>，就決定是你了！&lt;/p>
&lt;p>&lt;code>.dev&lt;/code> 網域的一年價格是 12 USD，大約 350 台幣附近，其他網域結尾的價格可以參考 &lt;a href="https://support.google.com/domains/answer/6010092">Google 的說明&lt;/a>。&lt;/p>
&lt;p>比較需要注意的是 Google Domain 目前沒有開放台灣地區購買，但也不限制你用外幣結帳，但就要付跨區交易的手續費。&lt;/p>
&lt;p>中間會另外需要填寫一次給 ICANN（網際網路名稱與數字位址分配機構）的個人資訊，這些資訊不會被公開，最好填寫真實的（就算跨區了，寫台灣也沒問題）。&lt;/p>
&lt;h2 id="google-domain-設定">Google Domain 設定&lt;/h2>
&lt;p>購買完成之後，回到 Google Domain 就會出現「my domain」選項，為了連接到 GitHub Page，需要做一些 DNS 資源設定：&lt;/p>
&lt;h3 id="base-domain-apex-domain">Base Domain (Apex Domain)&lt;/h3>
&lt;p>為了支援 GitHub Page 的 HTTPS 設定，根據&lt;a href="https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-a-records-with-your-dns-provider">官方文件&lt;/a>，需要在 DNS 中將 base domain 設定至下列 IP：&lt;/p>
&lt;pre>&lt;code>185.199.108.153
185.199.109.153
185.199.110.153
185.199.111.153
&lt;/code>&lt;/pre>&lt;p>具體做法是在 DNS 頁面中下方 Custom resource records 中，選擇 resource type: A，並新增上述四組 IP：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/1P3zHXX.png" alt="DNS apex domain setting">&lt;/p>
&lt;p>DNS 設定需要一段時間生效，Google Domain 算是很快的，只讓我等了幾分鐘而已，下列指令可以確定剛剛的設定是否生效：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ dig dwye.dev +nostats +nocomments +nocmd
; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; dwye.dev +nostats +nocomments +nocmd
;; global options: +cmd
;dwye.dev. IN A
dwye.dev. 3599 IN A 185.199.111.153
dwye.dev. 3599 IN A 185.199.109.153
dwye.dev. 3599 IN A 185.199.108.153
dwye.dev. 3599 IN A 185.199.110.153
&lt;/code>&lt;/pre>&lt;/div>&lt;p>出現了上面的 IP 代表生效了。&lt;/p>
&lt;h3 id="cname">CNAME&lt;/h3>
&lt;p>CNAME (canonical name) 就是真實名稱的意思，在 DNS 這裡的作用是將個人化網域 map 到真實網域，以我的例子來說，要將 &lt;code>dwye.dev&lt;/code> map 到 &lt;code>dwy6626.github.io&lt;/code>，因此一樣在 DNS 頁面中下方 Custom resource records 中，選擇 resource type: DNS，並輸入真實名稱 &lt;code>dwy6626.github.io&lt;/code>：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/CfdasYG.png" alt="DNS CNAME setting">&lt;/p>
&lt;h2 id="github-repo-設定">GitHub Repo 設定&lt;/h2>
&lt;p>這邊是架設 GitHub Page 的 repo，以我的例子來說是這個 repo：&lt;/p>
&lt;p>&lt;a href="https://github.com/dwy6626/dwy6626.github.io">https://github.com/dwy6626/dwy6626.github.io&lt;/a>&lt;/p>
&lt;p>在 Setting 第一頁找到 &lt;strong>GitHub Pages&lt;/strong> 設定，並在 custom domain 填入個人化網域 &lt;code>dwye.dev&lt;/code>，就這麼簡單。&lt;/p>
&lt;p>不過如果你做得太快，Google Domain 的 DNS 設定還沒生效的話，會暫時無法使用 HTTPS，一樣等個幾分鐘再回來打勾就好。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/kcZgbaZ.png" alt="GitHub Repo Setting Custom Domain">&lt;/p>
&lt;p>到這邊基本上大致上就完成了，然而修改完了設定之後，code base 以及 CI/CD 也有需要修改的地方，這樣才能保證下次部署後資料是正常的。&lt;/p>
&lt;h2 id="repo-內修改">Repo 內修改&lt;/h2>
&lt;p>我是用 &lt;a href="https://dwye.dev/hugo-github-action">Hugo + GitHub Action&lt;/a> 產生並透過 CI/CD 自動部署靜態網站，裡面也有相關的設定需要修改：&lt;/p>
&lt;h3 id="hugo">Hugo&lt;/h3>
&lt;p>修改 config 中 baseURL 設定：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-toml" data-lang="toml">&lt;span style="color:#75715e"># config.toml&lt;/span>
&lt;span style="color:#a6e22e">baseURL&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;https://dwye.dev/&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="github-action">GitHub Action&lt;/h3>
&lt;p>因為我使用的是 &lt;code>peaceiris/actions-gh-pages@v3&lt;/code> 這個 Action，已經內建支援設定 CNAME 了，只需要加上去就好：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#75715e"># .github/workflows/deploy.yml&lt;/span>
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Deploy&lt;/span>
&lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">peaceiris/actions-gh-pages@v3&lt;/span>
&lt;span style="color:#f92672">with&lt;/span>:
&lt;span style="color:#f92672">external_repository&lt;/span>: &lt;span style="color:#ae81ff">dwy6626/dwy6626.github.io&lt;/span>
&lt;span style="color:#f92672">deploy_key&lt;/span>: &lt;span style="color:#ae81ff">${{ secrets.ACTIONS_DEPLOY_KEY }}&lt;/span>
&lt;span style="color:#f92672">publish_dir&lt;/span>: &lt;span style="color:#ae81ff">./public&lt;/span>
&lt;span style="color:#f92672">publish_branch&lt;/span>: &lt;span style="color:#ae81ff">master&lt;/span>
&lt;span style="color:#f92672">cname&lt;/span>: &lt;span style="color:#ae81ff">dwye.dev&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後那行即是 CNAME 設定，部署完成後就會自動產生一個 CNAME 檔案在 GitHub Page Repo 內。&lt;/p>
&lt;h2 id="結語">結語&lt;/h2>
&lt;p>完成上面所有步驟之後，就可以連去你的網誌看看了，網址變短變的有個性，就是爽 XDDD&lt;/p>
&lt;p>所以個人化網域，其實就是花錢買個爽（Ｘ），當然還有個人品牌經營的部分，但對我來說比較是個人興趣吧。&lt;/p>
&lt;p>留一些 TO-DO：&lt;/p>
&lt;ul>
&lt;li>Google Search Console 以及 Google Analytics 更新（應該會寫在下篇）&lt;/li>
&lt;li>&lt;a href="https://dwye.dev/post/google-domain-mail">個人化 email 網址&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>GitHub Action 自動化部署 Hugo 網站</title><link>https://dwye.dev/post/hugo-github-action/</link><pubDate>Sun, 14 Mar 2021 22:01:56 +0800</pubDate><guid>https://dwye.dev/post/hugo-github-action/</guid><description>
&lt;p>在今天之前，這個 blog 是&lt;a href="https://dwye.dev/post/hugo-wercker">用 Wercker 做自動化部署&lt;/a>，當時對於 CI/CD 工具沒有太多比較，就直接使用了。&lt;/p>
&lt;p>在 2018 年底，&lt;a href="https://github.blog/2018-10-16-future-of-software/">GitHub 公開了他們的自有 CI/CD 工具 GitHub Action&lt;/a>，並於 2019 年底正式推出。這個工具經過了兩年多的發展，如今也有一定成熟度，社群有很多相關的工具發展起來，當然也不乏 Hugo 的自動化部署。如果 repo 使用 GitHub，那整合 GitHub 自家 CI/CD 當然是最方便的。&lt;/p>
&lt;p>因此去年在公司實習時，主管就叫我研究一下 GitHub Action 套用在當時開發的 Rails 專案，我只參考了官方文件並套用了一些社群貢獻的 GitHub Action，就成功完成任務，包含在開 PR 時自動跑 coding style review (rubocop) 以及 push 時跑單元測試 (RSpec)。&lt;del>人生又往 YAML 工程師前進了一步。&lt;/del>&lt;/p>
&lt;h2 id="正文">正文&lt;/h2>
&lt;p>這邊就不多介紹 GitHub Action 了，接下來就記錄我如何從 Wercker 搬遷到 GitHub Action（說是搬遷，實際上就是參考原本的 CI/CD 建立一個新的 CI/CD）。&lt;/p>
&lt;p>首先我們先來看之前 wercker 設定檔：&lt;/p>
&lt;script src="https://gist.github.com/dwy6626/d072c4809db1e04e02e4eab9365e567e.js">&lt;/script>
&lt;p>把 CI/CD 自動化的事情整理一下：&lt;/p>
&lt;p>每次 Push 時：&lt;/p>
&lt;ul>
&lt;li>更新 submodule 把 theme 拉下來（這邊是我修改自 Blackburn 主題的 &lt;a href="https://github.com/dwy6626/dw-favored-blackburn">dw-favored-blackburn&lt;/a>）&lt;/li>
&lt;li>&lt;code>hugo&lt;/code> 產生靜態網站&lt;/li>
&lt;li>把 build 後在 &lt;code>./public&lt;/code> 資料夾內的檔案推到另一個公開 repo&lt;/li>
&lt;/ul>
&lt;p>對應的 GitHub Action 如下：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/actions/checkout">actions/checkout&lt;/a>，官方 action，checkout repo 讓 workflow 可以存取 code，這邊可以直接設定 checkout 後要連 submodule 一起拉下來&lt;/li>
&lt;li>&lt;a href="https://github.com/peaceiris/actions-hugo">peaceiris/actions-hugo&lt;/a>，幫你裝 Hugo（之後還是要自己跑 &lt;code>hugo&lt;/code> 來產生靜態網站）&lt;/li>
&lt;li>&lt;a href="https://github.com/peaceiris/actions-gh-pages">peaceiris/actions-gh-pages&lt;/a>，幫你把某個資料夾下的檔案推到特定分支，也支援推到別的 GitHub repo，完全符合我的需求，只是需要另外在外部 repo 設定 deploy key 讓 action 可以把檔案推過去&lt;/li>
&lt;/ul>
&lt;p>把這三個照著 &lt;a href="https://docs.github.com/en/actions/reference">workflow syntax&lt;/a> 寫好之後其實就大功告成了：&lt;/p>
&lt;script src="https://gist.github.com/dwy6626/da652c1b3bb54651064c42d407abbebe.js">&lt;/script>
&lt;p>雖然整體看起來比原本長，不過對於觸發時機以及觸發分支的管理（on push, master）也集中到這個檔案了，就不用再 GitHub 和 Wercker 兩邊跑，全部集中在這個檔案（除了設定一些敏感資訊之外），因此我覺得還是比較方便。&lt;/p>
&lt;p>當 push 到 master 分支之後結果如下：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/XovsZ48.png" alt="workflow results">&lt;/p>
&lt;h2 id="關於-deploy-key">關於 Deploy Key&lt;/h2>
&lt;p>這邊是稍微比較複雜的地方，這個 deploy key 是需要自己產生自己放上 GitHub 的。產生的方法不外乎使用 &lt;code>ssh-keygen&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ssh-keygen
&lt;/code>&lt;/pre>&lt;/div>&lt;p>照著指示做就好，之後會生成一組 public-private key。Private key 是沒有副檔名的，public key 則有附檔名 &lt;code>.pub&lt;/code>。&lt;/p>
&lt;p>Hugo 原始碼的 repo 要放 private key，放在 action secrets 供 action 存取（注意要把整個檔案內容，包含頭尾兩行 &lt;code>-----BEGIN OPENSSH PRIVATE KEY-----&lt;/code> 等一起貼上去）：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/bx9WQK9.png" alt="put private key in hugo repo&amp;rsquo;s action secret">&lt;/p>
&lt;p>要架設 GitHub Page 的外部 repo 則是要設定 deploy key，把 public key 整個檔案貼過去：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/HP3EQBB.png" alt="put public key to outer repo&amp;rsquo;s deploy key">&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Python 實作 Disjoint Set 與 Union Find</title><link>https://dwye.dev/post/python-union-find/</link><pubDate>Mon, 22 Feb 2021 18:41:25 +0800</pubDate><guid>https://dwye.dev/post/python-union-find/</guid><description>
&lt;h2 id="使用情境">使用情境&lt;/h2>
&lt;p>在 Leetcode 寫到一題：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://leetcode.com/problems/number-of-operations-to-make-network-connected/">1319. Number of Operations to Make Network Connected&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>現在有 n 台電腦以及一些 cables 將電腦點對點連接，問需要移動至少幾條 cable 才能讓在所有電腦連成單一網路。&lt;br>
以 graph 的角度來看，電腦就是 nodes，cables 就是 edges。&lt;/p>
&lt;p>要將整張 graph 連接起來，至少需要 n-1 個 edges。若一個 graph 裡面有超過 n-1 個 edges，剩下的就是多出來的 edges，可以供我們拿來移動的 edges。&lt;br>
所以第一件事就是要&lt;strong>檢查 edges 數量 &amp;gt;= n-1&lt;/strong>。&lt;/p>
&lt;p>當檢查完畢之後，我們有至少 n-1 條 edges，一定可以用這些 edges 將所有 nodes 連接起來。&lt;br>
因為題目只問需要移動幾條 edges，我們可以假設我們移動的都是多出來的 edges，不必去動原本的 n-1 個 edges。&lt;/p>
&lt;p>假設原本的 graph 被切分成分離的 m 塊 connected components，則我們需要移動 m-1 個 edges 去連接，因此問題變成了&lt;strong>找出目前有幾塊 connected components&lt;/strong>。&lt;/p>
&lt;p>這個問題的一個標準做法就是使用 disjoint set：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">makeConnected&lt;/span>(self, n: int, connections: List[List[int]]) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> int:
&lt;span style="color:#75715e"># 檢查 edges 數量 &amp;gt;= n-1&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> len(connections) &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#75715e"># 找出目前有幾塊 connected components&lt;/span>
ds &lt;span style="color:#f92672">=&lt;/span> DisjointSet(range(n))
&lt;span style="color:#66d9ef">for&lt;/span> u, v &lt;span style="color:#f92672">in&lt;/span> connections:
ds&lt;span style="color:#f92672">.&lt;/span>union(u, v)
&lt;span style="color:#66d9ef">return&lt;/span> ds&lt;span style="color:#f92672">.&lt;/span>count_sets() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="實作-disjoint-set">實作 Disjoint Set&lt;/h2>
&lt;p>Disjoint set 的特性，是將一個大集合裡面分為 n 個子集合，這些子集合本身是 disjoint，無交集的。並提供兩個方法：&lt;/p>
&lt;ul>
&lt;li>&lt;code>find/1&lt;/code>：查找某個元素在哪個集合，實務上會選擇其中一個「家長」當作代表&lt;/li>
&lt;li>&lt;code>union/2&lt;/code>：將兩個元素所在的集合合併&lt;/li>
&lt;/ul>
&lt;p>在上個部分，我假設 &lt;code>DisjointSet&lt;/code> 已經寫好了，而我們要實作的則是 initialization 和 &lt;code>union&lt;/code> 方法，而 &lt;code>union&lt;/code> 會需要查找輸入的元素所在的集合，因此 &lt;code>find&lt;/code> 當然也必須實作。&lt;/p>
&lt;p>教科書做法是使用 set forest 實作，也就是每個子集合都是一個 tree，每個 node 只需要一個 pointer 指向其 parent，root 為「家長」。這樣上面的方法所做的事情就是：&lt;/p>
&lt;ul>
&lt;li>&lt;code>find/1&lt;/code>：一路網上查找「家長」&lt;/li>
&lt;li>&lt;code>union/2&lt;/code>：將兩棵樹合併，找到家長之後，將其中一個的 parent 指向另一個&lt;/li>
&lt;/ul>
&lt;p>如果是這樣的話我們可以這樣實作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DisjointSet&lt;/span>:
&lt;span style="color:#66d9ef">def&lt;/span> __init__(self, elements):
self&lt;span style="color:#f92672">.&lt;/span>parents &lt;span style="color:#f92672">=&lt;/span> [n &lt;span style="color:#66d9ef">for&lt;/span> n &lt;span style="color:#f92672">in&lt;/span> elements]
self&lt;span style="color:#f92672">.&lt;/span>count &lt;span style="color:#f92672">=&lt;/span> len(self&lt;span style="color:#f92672">.&lt;/span>parents)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(self, element):
n &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>parents[element]
&lt;span style="color:#66d9ef">while&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>parents[n] &lt;span style="color:#f92672">!=&lt;/span> n:
n &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>parents[n]
&lt;span style="color:#66d9ef">return&lt;/span> n
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">union&lt;/span>(self, u, v):
u &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>find(u)
v &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>find(v)
&lt;span style="color:#66d9ef">if&lt;/span> u &lt;span style="color:#f92672">!=&lt;/span> v:
self&lt;span style="color:#f92672">.&lt;/span>parents[u] &lt;span style="color:#f92672">=&lt;/span> v
self&lt;span style="color:#f92672">.&lt;/span>count &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">count_sets&lt;/span>(self):
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>count
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="進一步優化">進一步優化&lt;/h2>
&lt;p>但其實這個物件還有可以優化的地方：&lt;code>find&lt;/code> 會重複執行，如果 tree 很深，&lt;code>find&lt;/code> 的時間就會越來越長。由於 node 在 tree 內部的位置並不是重點，我們希望能夠讓向上查找家長這件事變快，也就是保持 tree 越淺越好。為此可以做兩件事：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>加入 rank 概念&lt;/strong>，代表該子集合的最大可能深度，保持每個 set 深度的平衡，避免某個 tree 的深度太高。把 rank 記錄在家長的 node 即可&lt;/li>
&lt;li>&lt;strong>Path compression&lt;/strong>，有點像是把每次 &lt;code>find&lt;/code> 的結果存起來，做法是當 &lt;code>find&lt;/code> 做完時，把沿路找到的 node 都掛載家長下方，這樣下次在這個子集合裡跑 find 時就會加速許多。&lt;/li>
&lt;/ul>
&lt;p>所以 &lt;code>DisjointSet&lt;/code> 改寫為：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DisjointSet&lt;/span>: &lt;span style="color:#75715e"># with rank and path compression&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> __init__(self, elements):
self&lt;span style="color:#f92672">.&lt;/span>sets &lt;span style="color:#f92672">=&lt;/span> [Node(n) &lt;span style="color:#66d9ef">for&lt;/span> n &lt;span style="color:#f92672">in&lt;/span> elements]
self&lt;span style="color:#f92672">.&lt;/span>count &lt;span style="color:#f92672">=&lt;/span> len(self&lt;span style="color:#f92672">.&lt;/span>sets)
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(self, element):
n &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>sets[element]
path_node &lt;span style="color:#f92672">=&lt;/span> []
&lt;span style="color:#66d9ef">while&lt;/span> n&lt;span style="color:#f92672">.&lt;/span>parent &lt;span style="color:#f92672">!=&lt;/span> n:
n &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">.&lt;/span>parent
path_node&lt;span style="color:#f92672">.&lt;/span>append(n) &lt;span style="color:#75715e"># 記錄路上的 nodes&lt;/span>
&lt;span style="color:#75715e"># path compression&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> v &lt;span style="color:#f92672">in&lt;/span> path_node:
v&lt;span style="color:#f92672">.&lt;/span>parent &lt;span style="color:#f92672">=&lt;/span> n
&lt;span style="color:#66d9ef">return&lt;/span> n
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">union&lt;/span>(self, u, v):
u &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>find(u)
v &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>find(v)
&lt;span style="color:#66d9ef">if&lt;/span> u &lt;span style="color:#f92672">!=&lt;/span> v:
&lt;span style="color:#75715e"># 把 rank 小的掛到 rank 大的下方&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> u&lt;span style="color:#f92672">.&lt;/span>rank &lt;span style="color:#f92672">&amp;lt;&lt;/span> v&lt;span style="color:#f92672">.&lt;/span>rank:
u&lt;span style="color:#f92672">.&lt;/span>parent &lt;span style="color:#f92672">=&lt;/span> v
&lt;span style="color:#66d9ef">else&lt;/span>:
v&lt;span style="color:#f92672">.&lt;/span>parent &lt;span style="color:#f92672">=&lt;/span> u
&lt;span style="color:#66d9ef">if&lt;/span> v&lt;span style="color:#f92672">.&lt;/span>rank &lt;span style="color:#f92672">==&lt;/span> u&lt;span style="color:#f92672">.&lt;/span>rank:
u&lt;span style="color:#f92672">.&lt;/span>rank &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
self&lt;span style="color:#f92672">.&lt;/span>count &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">count_sets&lt;/span>(self):
&lt;span style="color:#66d9ef">return&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>count
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這邊用到了 Node 物件，其實就是 C 的 struct 的概念。其實也可以只使用 tuple，但我選擇寫成物件比較清楚：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span>:
&lt;span style="color:#66d9ef">def&lt;/span> __init__(self, n):
self&lt;span style="color:#f92672">.&lt;/span>parent &lt;span style="color:#f92672">=&lt;/span> self
self&lt;span style="color:#f92672">.&lt;/span>rank &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以 leetcode 實測，前後執行時間分別為 1748 ms 及 560 ms，相差了三倍。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>MY FIRST STORY 《あいことば》 中文歌詞翻譯</title><link>https://dwye.dev/post/aikotoba/</link><pubDate>Wed, 30 Dec 2020 00:24:00 +0800</pubDate><guid>https://dwye.dev/post/aikotoba/</guid><description>
&lt;p>2020 要結束了，今年該死的發生了很多事，很多一輩子大概也意想不到的事情&lt;br>
寫碩士論文寫到沒時間認真寫文章，隨手發一下渣翻&lt;br>
畢業之後再修吧。&lt;/p>
&lt;p>是說 Hiro / 森內寬樹要個人出道了，新釋出的兩首 cover 都蠻好聽的，之後應該會買他的翻唱專輯支持一下。&lt;/p>
&lt;hr>
&lt;h3 id="あいことば">あいことば&lt;/h3>
&lt;p>&lt;strong>暗號 / 愛語&lt;/strong>&lt;br>
（日文中漢字是同音的）&lt;/p>
&lt;p>作詞：Hiro&lt;br>
作曲：Nob&lt;/p>
&lt;p>&lt;br>
二人で過ごしてた時間も&lt;br>
兩個人一起度過的時間&lt;/p>
&lt;p>君と歩いた帰り道も&lt;br>
與你一起走過的回家的路&lt;/p>
&lt;p>何気ない日々が 何時までも 続くと思ってたけど&lt;br>
思考著假裝著沒事的日子何時會持續到什麼時候呢&lt;/p>
&lt;p>&lt;br>
君のモノで溢れてる部屋&lt;br>
房間裡還有很多屬於你的東西&lt;/p>
&lt;p>何もかも捨てられないまま&lt;br>
一項也捨不得丟棄&lt;/p>
&lt;p>全て 思い出に出来るほど&lt;br>
全部都滿溢著回憶&lt;/p>
&lt;p>強くはなれずに 切なくなる&lt;br>
無法變得堅強 只感到難受&lt;/p>
&lt;p>&lt;br>
僕の目に映る景色を 全部&lt;br>
在我眼中映出的景色&lt;/p>
&lt;p>君一人だけにしたかったのにな&lt;br>
只需要有你一個就足夠了啊&lt;/p>
&lt;p>一人で幸せになれる様に&lt;br>
期許著一個人也能幸福生活&lt;/p>
&lt;p>君が 僕に 伝えた あいことば&lt;br>
是你曾經對我傳達過的暗號&lt;/p>
&lt;p>&lt;br>
君と二人で観てたドラマ&lt;br>
與你一起追過的連續劇&lt;/p>
&lt;p>まだ終わる気配はないけど&lt;br>
好像沒有要完結的樣子&lt;/p>
&lt;p>何故か一人では 観る事が出来ずに 諦めたまま&lt;br>
為何沒有辦法自己繼續看下去呢 只能不斷放棄&lt;/p>
&lt;p>&lt;br>
二人仲良く笑った写真&lt;br>
照片裡開心笑著的我們&lt;/p>
&lt;p>見返すたびに苦しくなる&lt;br>
每次拿起來看都感到痛苦&lt;/p>
&lt;p>今更 手遅れ過ぎるから&lt;br>
事到如今也許已經太遲了&lt;/p>
&lt;p>無駄だと思えれば 楽なのに&lt;br>
去認清已經沒用的話 應該就要能感到輕鬆的啊&lt;/p>
&lt;p>&lt;br>
君の手を握る役目は いつも&lt;br>
能夠握起你的手的人&lt;/p>
&lt;p>僕一人だけのはずだったのにな&lt;br>
本該只會有我一人的啊&lt;/p>
&lt;p>二人じゃ幸せになれないから&lt;br>
如果兩個人在一起沒辦法變得幸福的話&lt;/p>
&lt;p>他の人に 戻れる あいことば&lt;br>
就去尋找其他人吧 暗號&lt;/p>
&lt;p>&lt;br>
まだ一人の夜は明けず&lt;br>
一個人的夜晚沒有黎明&lt;/p>
&lt;p>同じ夢を見続けてるんだ&lt;br>
重複著相同的夢境&lt;/p>
&lt;p>もう ずっとずっと そばにいて&lt;br>
因為想要永遠永遠待在身邊&lt;/p>
&lt;p>ただ もっともっと あいたくて&lt;br>
只是想繼續見到一面&lt;/p>
&lt;p>「何時までだって一緒にいて欲しいだけなんだ」ってさ、&lt;br>
「不管多久都只想和你待在一起」這種任性的話&lt;/p>
&lt;p>また君に言えたらな&amp;hellip;&lt;br>
想要再次對你訴說&lt;/p>
&lt;p>&lt;br>
僕の心の中にいた人は&lt;br>
在我心裡讓我朝思暮想的人&lt;/p>
&lt;p>紛れもなく君一人だけでした&lt;br>
毫無疑問的只有你一人&lt;/p>
&lt;p>僕の目に映る景色を 全部&lt;br>
在我眼中映出的景色&lt;/p>
&lt;p>君一人だけにしたかったのにな&lt;br>
只需要有你一個就足夠了啊&lt;/p>
&lt;p>一人で幸せになれる様に&lt;br>
期許著一個人也能幸福生活&lt;/p>
&lt;p>忘れようとしたけど&lt;br>
雖然努力去忘記了&lt;/p>
&lt;p>僕は 君を 今でも&lt;br>
我啊，直到現在都&lt;/p>
&lt;p>愛してる&lt;br>
還是愛著你&lt;/p>
&lt;p>愛してる&lt;br>
我愛你&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Clean Code 心得</title><link>https://dwye.dev/post/clean-code/</link><pubDate>Tue, 08 Sep 2020 00:41:25 +0800</pubDate><guid>https://dwye.dev/post/clean-code/</guid><description>
&lt;p>因為公司有這本書的中文版，在各種等待時間，慢慢把這本看完了，同時也一邊寫些自己認為的重點。&lt;/p>
&lt;p>其實我覺得 Clean Code 適合的閱讀對象，是從來沒有接觸過任何 Coding Style 的人。&lt;/p>
&lt;p>如果你跟我一樣，有和別人合作過，平常有遵守一些準則（例如 PEP8），或是使用包含 Styling 的 linter (pylint / eslint / rubocop &amp;hellip;)，這本書還是能找到能學習的地方，例如命名原則、封裝的部分、模組的拆分、測試撰寫等等，這些開發準則以及自動化的 formatter 沒辦法告訴你的部分。&lt;/p>
&lt;p>也難怪第一次聽到別人推薦大家看這本書的時候，把它歸類在「選讀」，卻又說裡面的內容&lt;strong>很重要&lt;/strong>。因為很多觀念在現在已經是日常了。&lt;/p>
&lt;p>比較後面的章節，從系統、平行化開始，討論了一些比較深入的知識，Java code 也開始變難懂了，而持續精鍊、JUnit 等章節，就真的是針對 Java 的實例做說明，而非原則介紹的部分，這些對我來說讀起來就比較吃力一點。而平常會聽到大家討論的，也都是前面章節討論一些基本原則的部分。因此對於時間比較少的人或許可以先點到為止。&lt;/p>
&lt;p>&lt;del>我看網路上的心得也很少人真的讀完後面 XD&lt;/del>&lt;/p>
&lt;h3 id="列舉一下我覺得比較重要的章節">列舉一下我覺得比較重要的章節：&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Chp. 1 ~ Chp.10&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Chp. 12&lt;/strong> 簡單的總結&lt;/li>
&lt;li>&lt;strong>Chp. 17&lt;/strong> 一個清單，其實包含了 Chp. 14-16 的一些啟發&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>我認為重要順序是倒著的，完全沒時間可以先看 Chp. 17&lt;/strong>&lt;/p>
&lt;p>另外 Chp. 11 其實也蠻重要的，但是裡面太多 Java 的部分了，如果以後學 Java 再來細看吧。&lt;/p>
&lt;p>大概是這樣，下面就附上我紀錄的每章節重點吧。&lt;/p>
&lt;hr>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>Clean code 是一門學派，不是絕對正確&lt;/p>
&lt;p>減少閱讀程式碼的時間&lt;/p>
&lt;p>程式清楚明白，不要隱藏意圖&lt;/p>
&lt;p>童子軍規則：離開營地前，讓營地比使用前更乾淨&lt;/p>
&lt;h2 id="變數命名">變數命名&lt;/h2>
&lt;ul>
&lt;li>避免無意義的字：the, variable, name&lt;/li>
&lt;li>避免跟形態衝突的字（會誤導），除非他真的是那個形態：list, array&lt;/li>
&lt;li>能搜尋&lt;/li>
&lt;li>能唸出來&lt;/li>
&lt;li>意義區別
&lt;ul>
&lt;li>e.g. &lt;code>source&lt;/code>, &lt;code>destination&lt;/code> 取代 &lt;code>a1&lt;/code>, `a2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>同一概念統一字詞&lt;/li>
&lt;li>在命名內加入 context，或是用 Class 包起來&lt;/li>
&lt;/ul>
&lt;h3 id="善用詞性">善用詞性&lt;/h3>
&lt;p>類別：&lt;strong>名詞&lt;/strong>&lt;br>
方法：&lt;strong>動詞&lt;/strong>&lt;/p>
&lt;h2 id="函式">函式&lt;/h2>
&lt;ul>
&lt;li>多型 &amp;gt; switch case&lt;/li>
&lt;li>參數越少越好
&lt;ul>
&lt;li>可以把參數包在類別裡，例如 &lt;code>point&lt;/code> 取代 &lt;code>x, y&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>No side effect
&lt;ul>
&lt;li>不要做名字以外的事情&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>讓物件改變自己，而不是讓函式輸入物件&lt;/li>
&lt;li>查改分離（Commend / Query 分離）&lt;/li>
&lt;li>用&lt;strong>例外處理&lt;/strong>取代 if 回傳錯誤碼
&lt;ul>
&lt;li>try&amp;hellip;finally block 應該&lt;strong>獨佔&lt;/strong>函式（就是一件事）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="single-responsibility-principle-srp-單一職責原則">Single Responsibility Principle, SRP 單一職責原則&lt;/h3>
&lt;p>一個類別或一個模組，應該只有一個讓你去修改他的理由（一種職責）&lt;/p>
&lt;p>要能有簡潔的命名，否則就該拆開成兩個類別 / 兩個模組&lt;/p>
&lt;ul>
&lt;li>只有一個層次的抽象概念&lt;/li>
&lt;li>不要傳 flag（true/false）進函數讓他做兩件事&lt;/li>
&lt;/ul>
&lt;h3 id="open-closed-principle-ocp-開放閉合原則">Open Closed Principle, OCP 開放閉合原則&lt;/h3>
&lt;p>要設計得易於延展（例如：繼承），不用因新型態、新需求加入而改變原本的部分&lt;/p>
&lt;h2 id="註解">註解&lt;/h2>
&lt;p>彌補程式碼&lt;strong>表達意圖的失敗&lt;/strong>&lt;br>
常常會沒有跟著程式碼一起改到（&lt;strong>只有程式碼是真的&lt;/strong>）&lt;/p>
&lt;p>透過修改程式碼來移除註解&lt;/p>
&lt;p>版本日誌 / 程式碼修改 / 作者等資訊，在 VCS 的努力下不需要被留在註解了&lt;br>
（git: am I a joke to you?）&lt;/p>
&lt;h3 id="註解應該最少只留必要的註解">註解應該最少，只留必要的註解&lt;/h3>
&lt;ul>
&lt;li>法律型註解&lt;/li>
&lt;li>資訊型註解
&lt;ul>
&lt;li>function doc&lt;/li>
&lt;li>formatter 會挑出的格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>意圖的解釋
&lt;ul>
&lt;li>一段複雜 / magic code 是為了解決什麼&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>後果告誡
&lt;ul>
&lt;li>e.g. 為什麼不跑這個測試&lt;/li>
&lt;li>thread unsafety&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TODO&lt;/li>
&lt;li>&lt;strong>下面這行很重要，因為&amp;hellip;&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="編排">編排&lt;/h2>
&lt;p>寫 code，像編排一頁報紙&lt;/p>
&lt;h3 id="vertical">Vertical&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>空行&lt;/strong>分隔：package / class / function&lt;/li>
&lt;li>關聯的 code 要連續（script / function &amp;hellip;）
&lt;ul>
&lt;li>互相呼叫 / 引用&lt;/li>
&lt;li>Concept 相近&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>local variable 宣告盡可能靠近使用的地方&lt;/li>
&lt;li>Instance variable 宣告在最上方 (也可以依照 C++ 的 Scissors rule 放在最下方)&lt;/li>
&lt;/ul>
&lt;h3 id="horizontal">Horizontal&lt;/h3>
&lt;ul>
&lt;li>寬度 ~100-120 以下，以不要捲動畫面為主&lt;/li>
&lt;li>assignment 兩端空白
&lt;ul>
&lt;li>&lt;code>user_name = 'david'&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用空白來強調運算子的優先序
&lt;ul>
&lt;li>&lt;code>return b*b - 4*a*c&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>不要&lt;/strong>水平對齊，會需要水平對齊代表列表太長&lt;/li>
&lt;/ul>
&lt;h2 id="物件與資料結構">物件與資料結構&lt;/h2>
&lt;ul>
&lt;li>OOP 容易添加新的類別（duck-typing）&lt;/li>
&lt;li>Struct 容易添加新的 function&lt;/li>
&lt;/ul>
&lt;h3 id="the-law-of-demeter--principle-of-least-knowledge">The Law of Demeter / Principle of Least Knowledge&lt;/h3>
&lt;p>Loose coupling&lt;/p>
&lt;p>Abstraction: 模組&lt;strong>不該&lt;/strong>知道它所操作的物件的&lt;strong>內部運作&lt;/strong>&lt;/p>
&lt;h3 id="火車事故-train-wreck">火車事故 (train wreck)&lt;/h3>
&lt;p>一連串的連續呼叫，對於物件 &lt;code>get_options&lt;/code> 內部理解太深&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">output_dir &lt;span style="color:#f92672">=&lt;/span> obj&lt;span style="color:#f92672">.&lt;/span>get_options()&lt;span style="color:#f92672">.&lt;/span>get_scratch_dir()&lt;span style="color:#f92672">.&lt;/span>get_absolute_path()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Clean Code 認為違反了 Law of Demeter，以下列方式分割：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">opt &lt;span style="color:#f92672">=&lt;/span> obj&lt;span style="color:#f92672">.&lt;/span>get_options()
scratch_dir &lt;span style="color:#f92672">=&lt;/span> opt&lt;span style="color:#f92672">.&lt;/span>get_scratch_dir()
output_dir &lt;span style="color:#f92672">=&lt;/span> scratch_dir&lt;span style="color:#f92672">.&lt;/span>get_absolute_path()
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="資料傳輸物件-data-transfer-objects-dto">資料傳輸物件 Data Transfer Objects (DTO)&lt;/h3>
&lt;p>只有 public variable&lt;br>
沒有 method&lt;/p>
&lt;p>e.g. active record&lt;/p>
&lt;p>作者還批評了一般 Model 寫法，說應該要把 Bussiness rule 和 DTO 分開 XD&lt;/p>
&lt;h2 id="錯誤處理">錯誤處理&lt;/h2>
&lt;ul>
&lt;li>提供 error message&lt;/li>
&lt;li>從 caller 的角度，定義 Exception 的類別&lt;/li>
&lt;li>利用特殊類別配合 duck typing 來處理特殊情況，不用總是用 &lt;code>try&lt;/code>&amp;hellip;&lt;code>catch&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="return-null">Return Null?&lt;/h3>
&lt;p>盡量避免，改成：&lt;/p>
&lt;ul>
&lt;li>empty array for iteration&lt;/li>
&lt;li>在函式內部做 assertion 來避免會造成 null 的結果&lt;/li>
&lt;/ul>
&lt;h2 id="interface">Interface&lt;/h2>
&lt;p>你的 code 和 3rd-party 的 code 的 interface&lt;/p>
&lt;p>最小化會依賴於 3rd-party 的部分&lt;/p>
&lt;h3 id="adapter">Adapter&lt;/h3>
&lt;ul>
&lt;li>把 3rd-party 封裝起來，不要直接在 code 內傳遞他&lt;/li>
&lt;/ul>
&lt;h2 id="unit-test">Unit Test&lt;/h2>
&lt;p>測試也要好維護&lt;/p>
&lt;p>讓你的測試變得很好閱讀：封裝細節&lt;/p>
&lt;h3 id="test-driven-delopment">Test-Driven Delopment&lt;/h3>
&lt;p>三大法則&lt;/p>
&lt;ul>
&lt;li>寫測試 -&amp;gt; 寫程式&lt;/li>
&lt;li>只寫剛好無法通過的測試&lt;/li>
&lt;li>只寫剛好能透過當前測試的程式&lt;/li>
&lt;/ul>
&lt;h3 id="styling">Styling&lt;/h3>
&lt;ul>
&lt;li>Given-When-Then&lt;/li>
&lt;li>One Assert per example (原則上)&lt;/li>
&lt;li>One concept per example&lt;/li>
&lt;/ul>
&lt;h3 id="first">F.I.R.S.T.&lt;/h3>
&lt;ul>
&lt;li>Fast: 測試程式不能跑太慢，不然你會不想跑 XD&lt;/li>
&lt;li>Independent: 區塊間不應該互相依賴，可以獨立跑某些測試，而且不能因為一個 fail 導致後續的 fail&lt;/li>
&lt;li>Repeatable: 在 Test / Development / Production 都能跑&lt;/li>
&lt;li>Self-validating: 通過 / 失敗 要明確，不要把重要結果放 log 裡面&lt;/li>
&lt;li>Timely: 即時寫測試，不要拖到寫完功能之後&lt;/li>
&lt;/ul>
&lt;h2 id="class">Class&lt;/h2>
&lt;h3 id="封裝">封裝&lt;/h3>
&lt;p>Keep private 除非需要開放給測試或其他 module&lt;/p>
&lt;h3 id="凝聚性">凝聚性&lt;/h3>
&lt;p>盡量減少你的 instance variables&lt;/p>
&lt;ul>
&lt;li>當一群 Instance variables 在一些 methods 都需要用到時，也許他們該被拆出去變成一個新類別&lt;/li>
&lt;/ul>
&lt;h3 id="dependency-inversion-principle-dip">Dependency Inversion Principle (DIP)&lt;/h3>
&lt;p>類別要 depends on 抽象概念，不要 depends on 具體細節&lt;/p>
&lt;h2 id="system">System&lt;/h2>
&lt;p>將所有&lt;strong>關注的事&lt;/strong>分開&lt;/p>
&lt;p>每個關注領域分開成不同模組，並以 interface 整合&lt;/p>
&lt;ul>
&lt;li>Lazy initialization 同時進行了「initialize」和「執行」，少用&lt;/li>
&lt;li>使用一個主程式 Main 來建造物件，並讓物件各司其職&lt;/li>
&lt;li>使用 Dependency Injection 來減少元件之間的 Coupling&lt;/li>
&lt;li>善用 DSL (Domain-Specific Language) 來增加可讀性&lt;/li>
&lt;/ul>
&lt;p>註：這張多講了很多專有名詞，所以我是跳著看的（畢竟我跟 Java 不熟）。&lt;/p>
&lt;h2 id="羽化-emergence">羽化 Emergence&lt;/h2>
&lt;p>其實就是個小結。&lt;/p>
&lt;h3 id="四個簡單準則">四個簡單準則&lt;/h3>
&lt;p>重要性由上而下：&lt;/p>
&lt;ul>
&lt;li>執行完所有測試&lt;/li>
&lt;li>沒有重複的部分&lt;/li>
&lt;li>表達 Programmer 的本意&lt;/li>
&lt;li>最少的類別與方法&lt;/li>
&lt;/ul>
&lt;h3 id="執行完所有測試">執行完所有測試&lt;/h3>
&lt;ul>
&lt;li>能夠撰寫測試，類別自然較為小型且單一用途&lt;/li>
&lt;li>方便重構&lt;/li>
&lt;/ul>
&lt;h2 id="平行化">平行化&lt;/h2>
&lt;p>將「做什麼」和「何時做」分離，讓你的 code 可以隨插即用 &lt;del>（跟寫輪眼一樣）&lt;/del>&lt;/p>
&lt;h3 id="一些聲明">一些聲明&lt;/h3>
&lt;ul>
&lt;li>平行化會帶來額外負擔&lt;/li>
&lt;li>正確的平行化是複雜的，即使原本的問題很簡單&lt;/li>
&lt;li>平行化程式的錯誤不容易重複出現，容易被忽略&lt;/li>
&lt;li>常常需要根本性的修改&lt;/li>
&lt;/ul>
&lt;h3 id="能夠幫助平行化的原則">能夠幫助平行化的原則&lt;/h3>
&lt;ul>
&lt;li>SRP 單一職責原則&lt;/li>
&lt;li>限制資料的視野&lt;/li>
&lt;li>使用資料的 copy 而不要直接共享&lt;/li>
&lt;li>讓 thread 盡可能獨立運行&lt;/li>
&lt;/ul>
&lt;p>當然還有了解當下語言的相關函式庫，撰寫各種順序的測試，讀一下作業系統相關章節等等&lt;/p>
&lt;h2 id="最後的清單程式碼的氣味">最後的清單：程式碼的氣味&lt;/h2>
&lt;p>一些會讓人修改 code 的原因，只寫下我覺得前面沒記錄到的：&lt;/p>
&lt;ul>
&lt;li>多步驟才能 Build / Test&lt;/li>
&lt;li>一個檔案多種語言（例如說不要再 &lt;code>.py&lt;/code> 裡面硬寫 HTML）&lt;/li>
&lt;li>Boundary Condition 壞掉（想起那個二分搜尋法&amp;hellip;）
&lt;ul>
&lt;li>封裝他們&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>無視安全規範（例如：關掉失敗的測試、警告等）&lt;/li>
&lt;li>Magic Number: 出現在 Code 裡面的意義不明的數字（給個名字吧）&lt;/li>
&lt;li>Configuration 要放在高的抽象層&lt;/li>
&lt;li>Scope 大，變數名稱拉長&lt;/li>
&lt;/ul>
&lt;h2 id="延伸閱讀">延伸閱讀&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/ryanmcdermott/clean-code-javascript">Clean Code JavaScript&lt;/a>，如果是寫 JS 的很推薦閱讀這個 repo&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>用 zsh + zim + powerlevel10k 讓你的 Terminal 潮又快</title><link>https://dwye.dev/post/zsh-zim-powerlevel10k/</link><pubDate>Mon, 07 Sep 2020 11:41:25 +0800</pubDate><guid>https://dwye.dev/post/zsh-zim-powerlevel10k/</guid><description>
&lt;p>在開始之前，還是要先知道為什麼需要這些工具，就先上圖吧：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/YWNPQiG.png" alt="zsh + zim + powerlevel10k demo">&lt;/p>
&lt;ul>
&lt;li>在 Terminal 內顯示你想要的資訊：git / 時間 / 自訂路徑 / conda / rvm / nvm / 執行結果顯示等等，應有盡有。&lt;/li>
&lt;li>更方便的自動補完，可以直接用 tab 或方向鍵選擇想要補完的結果。&lt;/li>
&lt;li>可以輸入部分指令，就顯示之前打過的指令，也可以用方向鍵上下搜尋&lt;/li>
&lt;/ul>
&lt;p>&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>可能還有更多我還沒挖掘出來的方便性，但光是這三點，就足以讓我在每個工作環境都裝上 zsh + zim + powerlevel10k 了。&lt;/p>
&lt;p>寫這篇的原因，是因為目前看到主要的文章都還是透過 oh-my-zsh 安裝，但其實根本就不需要 XD&lt;/p>
&lt;p>甚至有的還是推薦 powerlevel9k，但是根據我自己的經驗，真的&amp;hellip;很慢，體感上的慢。然而若直接繞過 oh-my-zsh 使用 powerlevel10k，會少了一些客製化的方便性，所以這邊就來推薦 Zsh IMproved FrameWork (zim)，真的不太需要再做任何修改，就能享受常用到自動補完、選擇歷史指令等等功能。&lt;/p>
&lt;h2 id="安裝-zsh">安裝 zsh&lt;/h2>
&lt;h3 id="masos">masOS&lt;/h3>
&lt;p>系統有內建了，可以跳過。&lt;/p>
&lt;h3 id="ubuntu">Ubuntu&lt;/h3>
&lt;pre>&lt;code>sudo apt install zsh
&lt;/code>&lt;/pre>&lt;h2 id="切換預設-shell">切換預設 Shell&lt;/h2>
&lt;pre>&lt;code>chsh -s $(which zsh)
&lt;/code>&lt;/pre>&lt;p>也可以手動切過去：&lt;/p>
&lt;pre>&lt;code>exec zsh
&lt;/code>&lt;/pre>&lt;h2 id="安裝-zim">安裝 zim&lt;/h2>
&lt;p>根據他們 GitHub 的說明，就是希望&lt;strong>快&lt;/strong>，而且能包含常用的補全功能等等，號稱能比其他 framework 快上一倍：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/zimfw/zimfw/wiki/Speed">https://github.com/zimfw/zimfw/wiki/Speed&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>安裝方式極其簡單，可以利用 curl 或是 wget 一行解決。&lt;/p>
&lt;pre>&lt;code>curl -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh
&lt;/code>&lt;/pre>&lt;p>另外如果有些人不喜歡常常被問要不要更新，可以透過下面的指令來取消檢查（通常不太建議&amp;hellip;畢竟每 30 天才會問一次）：&lt;/p>
&lt;pre>&lt;code>zstyle ':zim' disable-version-check yes
&lt;/code>&lt;/pre>&lt;h2 id="安裝-powerlevel10k">安裝 Powerlevel10k&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>zsh 主題，讓你的 zsh 變得更美。&lt;/p>
&lt;h3 id="在-zim-中加入設定">在 zim 中加入設定&lt;/h3>
&lt;p>有了 zim 之後，就直接使用 zim 內建的 &lt;code>~/.zimrc&lt;/code> 來安裝吧。首先在 &lt;code>~/.zimrc&lt;/code> 加入這行：&lt;/p>
&lt;pre>&lt;code>zmodule romkatv/powerlevel10k
&lt;/code>&lt;/pre>&lt;p>如果你還沒有一個好的文字編輯器（但是建議你去找一個&amp;hellip;不想用純文字介面的可以使用 &lt;a href="https://code.visualstudio.com/docs/setup/mac">VSCode 的 Shell command&lt;/a>），也可以用懶人方式，直接用 echo 指令把文字加在檔案後面：&lt;/p>
&lt;pre>&lt;code>echo &amp;quot;zmodule romkatv/powerlevel10k&amp;quot; &amp;gt;&amp;gt; ~/.zimrc
&lt;/code>&lt;/pre>&lt;h3 id="接著安裝它">接著安裝它&lt;/h3>
&lt;pre>&lt;code>zimfw install
&lt;/code>&lt;/pre>&lt;p>然後就可以直接輸入 &lt;code>exec zsh&lt;/code> 切換過去測試了！第一次會有一些步驟要設定，當然也能直接跳過，之後自己在 &lt;code>.zshrc&lt;/code> 改就好。&lt;/p>
&lt;p>如果不小心錯過了起始的設定小程式，也可以透過 &lt;code>p10k configure&lt;/code> 重跑一次設定。&lt;/p>
&lt;h2 id="安裝特殊字體-nerd-font">安裝特殊字體 Nerd Font&lt;/h2>
&lt;p>其實就是一般的字體，只是加上了些特殊符號當作 Icons。如果沒有安裝，可能會看到有些東西是亂碼，那些就是 Icons，而我們原本的字體並沒有包含這些 Icons 所以會顯示亂碼。&lt;/p>
&lt;p>&lt;code>p10k configure&lt;/code> 的第一步就可以選擇是否直接安裝字體，很方便。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/OfNhvjE.png" alt="p10k configure install font?">&lt;/p>
&lt;h3 id="自己安裝字體">自己安裝字體&lt;/h3>
&lt;p>如果想要使用其他的 Nerd font 可以到 &lt;a href="https://nerdfonts.com/">https://nerdfonts.com/&lt;/a> 裡面的 Downloads 分頁找，有蠻多字體可以選擇。&lt;/p>
&lt;p>我自己是 patch 內建的 &lt;code>Monaco&lt;/code> 字體，步驟稍微複雜，可能需要另外拆開一篇分享。所以這邊就先從裡面挑一個吧，powerlevel10k 官方推薦的字體是 &lt;code>Meslo Nerd Font&lt;/code>。&lt;/p>
&lt;p>安裝完之後幫 Terminal 套上字型設定，就大功告成了。&lt;/p>
&lt;p>macOS 可以使用 Homebrew 的 &lt;code>cask&lt;/code> 來安裝：&lt;/p>
&lt;pre>&lt;code>brew tap homebrew/cask-fonts
brew cask install font-meslo-lg-nerd-font
&lt;/code>&lt;/pre>&lt;p>如果你碰到舊版的 &lt;code>caskroom/fonts&lt;/code>，也許會在安裝時碰上衝突：&lt;/p>
&lt;pre>&lt;code>Error: Cask font-meslo-lg-nerd-font exists in multiple taps:
&lt;/code>&lt;/pre>&lt;p>這時候把舊的 tap 刪掉就好了（關於 tap 可以參考:&lt;a href="https://docs.brew.sh/Taps">Taps (Third-Party Repositories)&lt;/a>）&lt;/p>
&lt;pre>&lt;code>brew untap caskroom/fonts
&lt;/code>&lt;/pre>&lt;p>能用 &lt;code>brew cask&lt;/code> 安裝的完整清單可以上他們的 GitHub 找：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/Homebrew/homebrew-cask-fonts/tree/master/Casks">https://github.com/Homebrew/homebrew-cask-fonts/tree/master/Casks&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>安裝完之後到 iTerm2 裡面套用：&lt;/p>
&lt;p>選單 &amp;gt; Preferences &amp;gt; Profiles &amp;gt; Text 找到 Font 設定：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/K67dFs3.png" alt="iTerm2 字型設定">&lt;/p>
&lt;h2 id="小結">小結&lt;/h2>
&lt;p>到這邊其實只是初始設定完成，其實後面還有很多個人化設定可以研究，不過其實原始的預設值就很夠用了！&lt;/p>
&lt;p>因為我是從 powerlevel9k 來的使用者，所以我自己還習慣使用 powerlevel9k 的設定如下：&lt;/p>
&lt;pre>&lt;code># ~/.zshrc
POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir vcs) # &amp;lt;= left prompt
POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status anaconda) # &amp;lt;= right prompt
POWERLEVEL9K_ANACONDA_LEFT_DELIMITER=
POWERLEVEL9K_ANACONDA_RIGHT_DELIMITER=
POWERLEVEL9K_SHORTEN_DELIMITER=&amp;quot;.&amp;quot;
&lt;/code>&lt;/pre>&lt;p>(是說今天才看到 powerlevel9k 已經停止維護了 XD)&lt;/p>
&lt;p>當然如果你是新使用者，建議還是直接修改他們的專用設定檔 &lt;code>~/.p10k.zsh&lt;/code>&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>THE ORAL CIGARETTES 《Shine Holder》 中文歌詞</title><link>https://dwye.dev/post/shine-holder/</link><pubDate>Sun, 16 Aug 2020 15:05:40 +0800</pubDate><guid>https://dwye.dev/post/shine-holder/</guid><description>
&lt;p>不是每個人都是聖人，每個人都有低潮與錯誤的時候。&lt;br>
願每個人都能善待彼此。&lt;/p>
&lt;p>Shine Holder.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/RMAEK1NvMQ8" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;hr>
&lt;h3 id="shine-holder">Shine Holder&lt;/h3>
&lt;p>THE ORAL CIGARETTES&lt;/p>
&lt;p>作詞：山中拓也&lt;br>
作曲：山中拓也&lt;/p>
&lt;p>&lt;br>
私このまま底から抜け出して&lt;br>
我就這樣從底層掙脫&lt;/p>
&lt;p>目にも止まらぬ速さで加速して&lt;br>
加速到目光追不上的快速&lt;/p>
&lt;p>私は　真実だから&lt;br>
因為我就是真實的&lt;/p>
&lt;p>誰かが作ったこの世は不条理で&lt;br>
是誰製作出來這個沒有道理的世界&lt;/p>
&lt;p>息も出来ないくらいに肥大して&lt;br>
嘆息已經膨脹到無法吐出的程度&lt;/p>
&lt;p>私は　真実だから&lt;br>
因為我就是真實的&lt;/p>
&lt;p>&lt;br>
光止めないで&lt;br>
別停止散發光芒&lt;/p>
&lt;p>期待もたないで&lt;br>
也別抱持期待&lt;/p>
&lt;p>なんて言うつもりもまだないけどね&lt;br>
也還不知道打算說些什麼&lt;/p>
&lt;p>きっとこのままじゃ&lt;br>
若這樣下去的話&lt;/p>
&lt;p>掴むことすら出来ない&lt;br>
一定連抓住什麼都辦不到&lt;/p>
&lt;p>&lt;br>
Shine Holder&lt;/p>
&lt;p>いつまで　誰か抑えて&lt;br>
要遭受其他人的壓抑到何時&lt;/p>
&lt;p>周りの評価をして罵倒して&lt;br>
對周圍的人批判與惡言&lt;/p>
&lt;p>自分の立場なんかは　見られないな&lt;br>
連自己的立場都沒辦法看清楚&lt;/p>
&lt;p>Shine Holder&lt;/p>
&lt;p>このまま　何も変わらない&lt;br>
這樣下去什麼都不會改變的&lt;/p>
&lt;p>勇気あるものに光与えて&lt;br>
將光芒給予有勇氣的事物吧&lt;/p>
&lt;p>気づかないふりするのは嫌　嫌&lt;br>
假裝沒有發覺是最讓人生厭的&lt;/p>
&lt;p>&lt;br>
しがらみに囚われては&lt;br>
被困在柵欄內&lt;/p>
&lt;p>アホ隠し&lt;br>
就愚蠢的躲藏&lt;/p>
&lt;p>数え切れない不祥事&lt;br>
面對數不清的醜聞&lt;/p>
&lt;p>神隠し&lt;br>
就行蹤不明&lt;/p>
&lt;p>私は　許せないから&lt;br>
我是無法原諒這些的&lt;/p>
&lt;p>&lt;br>
敗退さ　呑気なもんね&lt;br>
挫敗，安閑以對&lt;/p>
&lt;p>毎回さ　こうしないとね&lt;br>
每次，不這樣做不行&lt;/p>
&lt;p>敗退さ　呑気なもんね&lt;br>
挫敗，安閑以對&lt;/p>
&lt;p>繰り返しザマを&lt;br>
不斷重複的狼狽模樣&lt;/p>
&lt;p>感情で　ごまかして&lt;br>
用情感欺騙過去&lt;/p>
&lt;p>愛情で　リズムとって&lt;br>
熱情地調整節奏&lt;/p>
&lt;p>最低で　最高だって&lt;br>
以最少達到最好&lt;/p>
&lt;p>いまさら&lt;br>
從今開始&lt;/p>
&lt;p>&lt;br>
急ぐことないと&lt;br>
不需要著急&lt;/p>
&lt;p>イカレタ鈍間の　言うことなど聴く訳ないでしょう&lt;br>
古怪的遲鈍傢伙說出口的話也沒有聽的理由吧&lt;/p>
&lt;p>競う場所すらもう　間違えてしまった&lt;br>
甚至連競爭的地方本身都搞錯了&lt;/p>
&lt;p>&lt;br>
昨日だろうが明日だろうがって&lt;br>
昨日也好、明日也好&lt;/p>
&lt;p>やるべきことは見えてる&lt;br>
能看見必須要做的事了&lt;/p>
&lt;p>だって&lt;br>
因為&lt;/p>
&lt;p>未来時点でどうなろうか&lt;br>
未來會發生什麼&lt;/p>
&lt;p>考えた&lt;br>
考慮過了&lt;/p>
&lt;p>私このまま感じてやってきた&lt;br>
我就這樣靠著這份感覺一路走過來了&lt;/p>
&lt;p>止められない想い&lt;br>
無法停止的這份想法&lt;/p>
&lt;p>諦められんだろ&lt;br>
是不會輕易放棄的&lt;/p>
&lt;hr>
&lt;p>這首歌描述一個人被嫉妒的感情淹沒，在黑暗的感情中掙扎的心境，他們傷害別人，也被別人傷害。&lt;/p>
&lt;p>中間穿插的寫著遺書的新聞，「已經太累了」，以及電視裡的手掌象徵著掙扎，後面也有各式群體對於個人的中傷描寫。也有一幕是 FB 的「讚」與相反的「倒讚」符號，以及穿插閃過的數位印象，可能也是譬喻在網路世界每個人恣意對周圍做出批判吧。&lt;/p>
&lt;p>整首歌雖然充斥負面的描寫，卻也同時給了不少激勵的話語。正視自己心中的熱情，朝著自己想要前進的方向去行動，對那討厭的世界大喊：&lt;/p>
&lt;blockquote>
&lt;p>SUCK MY WORLD!!! (專輯名稱)&lt;/p>
&lt;/blockquote>
&lt;p>是一首激勵人的歌曲呢。&lt;/p>
&lt;p>不過 MV 最後一幕，Takuya 倒在血泊裡啊&amp;hellip;&lt;/p>
&lt;p>很喜歡這首歌，聽了很多次還是如此迷人。但實在是很難翻譯，修了好幾次之後還是現在這個樣子（汗），理學院的中文能力就到次為止了呢 XD&lt;/p>
&lt;p>希望大家能善待這個爛翻譯（w&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>為什麼有些人離開 Notion 了</title><link>https://dwye.dev/post/notion-privacy-concerns/</link><pubDate>Sun, 09 Aug 2020 00:41:23 +0800</pubDate><guid>https://dwye.dev/post/notion-privacy-concerns/</guid><description>
&lt;ol>
&lt;li>偷看用戶資料&lt;/li>
&lt;li>中國防火長城的快速解封&lt;/li>
&lt;/ol>
&lt;p>來說說為什麼這些會被認為是有疑慮的：&lt;/p>
&lt;h3 id="偷看用戶資料">偷看用戶資料&lt;/h3>
&lt;p>當然有問題，尤其是有人出面指控 Notion 為了商業利益，偷看了某公司資料之後，還跟公司提案合作。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/aqoZrXM.png" alt="notion privacy discussion">&lt;/p>
&lt;p>圖片截圖自 &lt;a href="https://www.facebook.com/groups/notion.so.taiwan/permalink/650523105498836/">Notion Taiwan FB 社團的公開文章&lt;/a>&lt;/p>
&lt;p>還有人指出 &lt;a href="https://www.notion.so/3468d120cf614d4c9014c09f6adc9091">Notion 隱私政策&lt;/a>本來就允許他們偷看你的內容，只要能和他們商業利益有關：&lt;/p>
&lt;blockquote>
&lt;p>Business Development and Strategic Partnerships: We may collect personal information from individuals and third parties to assess and pursue potential business opportunities.&lt;/p>
&lt;/blockquote>
&lt;h3 id="中國防火長城的快速解封">中國防火長城的快速解封&lt;/h3>
&lt;p>被中國防火長城擋起來的服務非常多，然而 Notion 在被封&lt;strong>不到一個月&lt;/strong>就解封了。就開始有人懷疑，是不是私下和中國達成什麼交易。&lt;/p>
&lt;p>俗話說，&lt;strong>便宜的最貴&lt;/strong>，&lt;strong>資料就是金錢&lt;/strong>。&lt;/p>
&lt;h2 id="notion-官方的回應">Notion 官方的回應&lt;/h2>
&lt;p>基於這把火在台灣燒得蠻旺的，所以有人就去和 Notion 公司聯絡，得到了官方的回應：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.notion.so/Notion-1c9a7142157147b484bc381c3e3b35d9">Notion 官方聲明稿&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>關於隱私權內商業策略的條款也已經刪除了。不過那個&lt;a href="https://www.notion.so/Personal-Use-Terms-of-Service-00e4e5d0f2b9411cbee6493f15779500">Terms of Service&lt;/a>裡面的資料收集部分還是寫的很精彩，在意的話不妨去看看。&lt;/p>
&lt;blockquote>
&lt;p>Notion Content &amp;amp; Use Policy and Monitoring Content: You agree that your use and all User Content will comply with &lt;a href="https://www.notion.so/Content-Use-Policy-1b9a773d5583486cb5c1d39a8d777a55">Notion’s Content &amp;amp; Use Policy&lt;/a>. Although we’re not obligated to monitor access to or use of the Service or Content or to review or edit any Content, we have the right to do so for the purpose of operating the Service, to ensure compliance with these Terms and to comply with applicable law or other legal requirements. We reserve the right, but are not obligated, to remove or disable access to any Content, including User Content, at any time and without notice, including, but not limited to, if we, at our sole discretion, consider any Content to be objectionable or in violation of these Terms. We have the right to investigate violations of these Terms or conduct that affects the Services. We may also consult and cooperate with law enforcement authorities to prosecute users who violate the law.&lt;/p>
&lt;/blockquote>
&lt;p>他們保留了所有能夠看使用者資料的權力，並也有把使用者資料移除或是讓你無法存取資料的權力。&lt;/p>
&lt;h2 id="其他類似的服務">其他類似的服務&lt;/h2>
&lt;p>如果你要逃了，在相關討論串看到別人推薦的一些 Notion 的替代方案，我還沒有空研究，如果有人有心得歡迎分享：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://joplinapp.org/">Joplin&lt;/a>：開源，可以自架或使用 Dropbox 同步&lt;/li>
&lt;li>&lt;a href="https://nimbusweb.me/">Nimbus Note&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://coda.io/welcome">Coda&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://clickup.com/">ClickUp&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>只有在 Mac / iOS 上的話可以考慮：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://bear.app/">Bear&lt;/a>&lt;/li>
&lt;li>原生 Apple 備忘錄&lt;/li>
&lt;/ul>
&lt;p>當然你也可以試試原本的老品牌們&lt;/p>
&lt;ul>
&lt;li>OneNote&lt;/li>
&lt;li>Evernote&lt;/li>
&lt;/ul>
&lt;p>如果你在手機上編輯的需求不大的話（像是我這種永遠戴著筆電跑來跑去的人），我也很推薦台灣出產的線上共筆軟體：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://hackmd.io/">HackMD&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>它的功能開始越來越豐富了，而且有&lt;a href="https://hackmd.io/s/features-tw">完整的中文教學&lt;/a>，想要用 Markdown 寫筆記的話一定要試試！&lt;/p>
&lt;h2 id="我的選擇">我的選擇&lt;/h2>
&lt;p>因為沒有時間研究（文章產出都減量了&amp;hellip;這篇還拖搞這麼久才出），加上官方有釋出善意，所以我決定先暫時留在 Notion + HackMD 的組合。&lt;/p>
&lt;p>防火長城問題，本來就是中國愛怎樣就怎樣。而隱私問題，除非筆記軟體主打 E2E 加密到資料庫（進資料庫前也會加密），不然你也很難保證公司不會去看你的筆記內容。Reddit 上的討論也大多傾向把 Notion 拿來純做筆記，而不要把任何敏感資料（商業機密 / 密碼）放在上頭。我自己的也是拿來做個人筆記而已。&lt;/p>
&lt;p>但每個人都能有自己的選擇，如果你看到這些問題，而你認為某個服務不會有這些問題，那就跳槽吧，這樣也能鞭策 Notion 做得更好。&lt;/p>
&lt;p>這才是自由民主的真諦啊。&lt;/p>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.facebook.com/racklin1002/posts/3345364142149274">Rack Lin 的 FB 文章&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.plurk.com/p/nud4kj">Plurk 偷偷說討論串&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>HackMD 彩蛋：讓你的文字充滿力量</title><link>https://dwye.dev/post/hackmd-konami-code/</link><pubDate>Mon, 03 Aug 2020 00:41:00 +0800</pubDate><guid>https://dwye.dev/post/hackmd-konami-code/</guid><description>
&lt;p>&lt;img src="https://dwye.dev/img/HackMD-Power.gif" alt="hackmd komami code">&lt;/p>
&lt;p>在 HackMD 畫面中輸入知名的 &lt;a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E4%B9%90%E7%BE%8E%E7%A7%98%E6%8A%80">Konami Code（科樂美秘技）&lt;/a>：&lt;strong>上上下下左右左右BA&lt;/strong>，就會啟動 POWER MODE，讓你打字的時候充滿力量！！&lt;/p>
&lt;h3 id="關於-power-mode">關於 Power Mode&lt;/h3>
&lt;p>&lt;del>在輸入文字的時候感受到力量注入編輯器&lt;/del>&lt;/p>
&lt;p>這個 Power Mode 其實不是 HackMD 原創，其實很多 IDE 或是其他文字輸入的地方都有類似的功能，可以參考這個列表：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/codeinthedark/awesome-power-mode">https://github.com/codeinthedark/awesome-power-mode&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>例如說我拿來寫這篇文章的 VSCode 也有 Power Mode 的 Extension（外掛）可以使用：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=hoovercj.vscode-power-mode">https://marketplace.visualstudio.com/items?itemName=hoovercj.vscode-power-mode&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>寫扣到厭煩的時候不妨裝來玩看看吧 XD&lt;/p>
&lt;h3 id="如果想關掉-power-mode-怎麼辦">如果想關掉 Power Mode 怎麼辦&lt;/h3>
&lt;p>我試過再輸入一次&lt;strong>上上下下左右左右BA&lt;/strong>，結果沒有發生任何事。&lt;/p>
&lt;p>還好官方雖然愛玩梗但是也有提供解答：&lt;br>
「&lt;a href="https://hackmd.io/c/tutorials-tw/%2F%40docs%2Fdisable-activate-power-mode-tw">如何關閉 Activate Power Mode&lt;/a>」這篇寫到，其實可以在下方設定直接把勾勾取消掉就好了。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/XksMXrC.png" alt="Disable Power Mode HackMD">&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Mrs. GREEN APPLE 《StaRt》 中文歌詞</title><link>https://dwye.dev/post/start/</link><pubDate>Wed, 22 Apr 2020 17:05:40 +0800</pubDate><guid>https://dwye.dev/post/start/</guid><description>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/OTUtF7ZxRN8" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>打 BanG Dream 遇到的很喜歡的一首歌，能夠真正給悲傷的人力量的一首。&lt;/p>
&lt;hr>
&lt;h3 id="start">StaRt&lt;/h3>
&lt;p>Mrs. GREEN APPLE&lt;/p>
&lt;p>作詞：大森元貴&lt;br>
作曲：大森元貴&lt;/p>
&lt;p>&lt;br>
やっとこさ　幕開けだ&lt;br>
終於啊　拉開序幕&lt;/p>
&lt;p>ほら　寄って集って！　お手を拝借！&lt;br>
嘿　過來集合　鼓掌吧！&lt;/p>
&lt;p>スタートラインに立った今&lt;br>
站在起始線的現在&lt;/p>
&lt;p>そう　武装と創と造で登場！！！！！&lt;br>
沒錯　武裝與創造的登場！&lt;/p>
&lt;p>&lt;br>
ここは遊び心で満ちよう！&lt;br>
在這裡滿足玩樂之心吧&lt;/p>
&lt;p>敢えての策略なの ラララララ♪&lt;br>
鼓起勇氣的策略　啦啦啦啦啦♪&lt;/p>
&lt;p>一人でも多くのマヌケが居るなら&lt;br>
不想要多一個笨蛋的話&lt;/p>
&lt;p>正すことから始めましょう。&lt;br>
就從改正它開始吧&lt;/p>
&lt;p>&lt;br>
幸せな時間をどれだけ過ごせるかは…&lt;br>
快樂的時間能夠持續多久呢&amp;hellip;&lt;/p>
&lt;p>微々たるものでも愛に気づけるか。&lt;br>
決定於你能發現多少微小的愛&lt;/p>
&lt;p>さあ　試されよう&lt;br>
來吧　嘗試這個說法吧&lt;/p>
&lt;p>パッパッパッ　晴れた町に&lt;br>
PA PA PA　在放晴的小鎮&lt;/p>
&lt;p>チャプチャプチャプ　雨の心&lt;br>
嘩啦啦　下雨的心&lt;/p>
&lt;p>独りじゃないと否定出来るように&lt;br>
為了能夠說出「你不是一個人」[1]&lt;/p>
&lt;p>僕は探すんだ&lt;br>
我會去尋找的&lt;/p>
&lt;p>&lt;br>
静けさと 1 対 1&lt;br>
與「平和」一對一&lt;/p>
&lt;p>そう「俄然負けん気」お手を拝借！&lt;br>
向那樣的「突然的不認輸」鼓掌 [2]&lt;/p>
&lt;p>スタート合図は鳴り止まなく&lt;br>
起步槍的聲響沒有停下&lt;/p>
&lt;p>もう　苦悩と煩と悩は上等！&lt;br>
如今　苦惱與煩與惱皆是上等！&lt;/p>
&lt;p>&lt;br>
ここは時既に戦の場&lt;br>
這裡已經是戰場了&lt;/p>
&lt;p>敢えて名を付けるなら　ナニヶ原？&lt;br>
勉強幫它取名字的話　叫個「什麼原」的？&lt;br>
&lt;em>（大概是捏他 關原&lt;/em>&lt;/p>
&lt;p>一人でも多くなで肩が泣くなら&lt;br>
若有不少人為了斜肩而落淚的話&lt;/p>
&lt;p>なで肩ブームでイイでしょう！？&lt;br>
讓斜肩成為流行也不錯吧？&lt;/p>
&lt;p>&lt;br>
「忘れたくないなぁ」を如何に増やせるかだ。&lt;br>
「不想要忘記啊」要如何增加呢？&lt;/p>
&lt;p>微々たるものでも愛に気づけぬなら&lt;br>
因為你沒能發現微小的愛&lt;/p>
&lt;p>&lt;strong>スタート&lt;/strong>に戻ろう&lt;br>
回到&lt;strong>起點&lt;/strong>吧&lt;/p>
&lt;p>パッパッパッ　晴れた町に&lt;br>
PA PA PA　在放晴的小鎮&lt;/p>
&lt;p>チャプチャプチャプ　雨の心&lt;br>
嘩啦啦　下雨的心&lt;/p>
&lt;p>独りじゃないと否定してくれる貴方を&lt;br>
能對我說出「你不是一個人」的你&lt;/p>
&lt;p>僕は探すんだ&lt;br>
我會去尋找的&lt;/p>
&lt;p>&lt;br>
I can, You can, We can, って&lt;br>
I can, You can, We can 這些話&lt;/p>
&lt;p>耳にタコが出来る程聞いた&lt;br>
一直重複聽到耳朵都長垢了&lt;/p>
&lt;p>I love you の言葉だって&lt;br>
I love you 這句話&lt;/p>
&lt;p>どこから信じればいいの？&lt;br>
要如何來相信呢？&lt;/p>
&lt;p>箱に荷物を詰めただけ&lt;br>
只往箱子裡塞滿了行李&lt;/p>
&lt;p>気持ちが軽くなった様だ&lt;br>
心情就變得輕鬆一樣&lt;/p>
&lt;p>悲しみも仕舞うべきところに&lt;br>
悲傷也應該要在收行李的時候&lt;/p>
&lt;p>仕舞うべきだ&lt;br>
跟著收進去啊&lt;/p>
&lt;p>&lt;br>
幸せと思える貴重な時間をどれだけ過ごせるかは…&lt;br>
感到快樂的珍貴時間能夠持續多久呢&amp;hellip;&lt;/p>
&lt;p>「いつでも&lt;strong>スタート&lt;/strong>で居よう」&lt;br>
「不管何時都保持著&lt;strong>初心&lt;/strong>吧」&lt;/p>
&lt;p>パッパッパッ　晴れた町に&lt;br>
PA PA PA　在放晴的小鎮&lt;/p>
&lt;p>パッパッパッ　晴れた笑顔&lt;br>
PA PA PA　綻放的笑容&lt;/p>
&lt;p>独りじゃないと否定出来るように&lt;br>
為了能夠說出「你不是一個人」&lt;/p>
&lt;p>明日も唄うんだ&lt;br>
明天也唱著歌吧&lt;/p>
&lt;hr>
&lt;h3 id="註">註&lt;/h3>
&lt;p>[1] 看起來像是雙重否定，但我覺得「否定」是指執行「じゃない」的部分，所以只有一次否定，這樣翻譯比較通順（不過也可以想成是否定「一個人 = 孤獨」這件事）&lt;br>
[2] 俄然：受到什麼外界刺激而突然變成那樣&lt;/p>
&lt;h3 id="大致上就是在說">大致上就是在說：&lt;/h3>
&lt;ul>
&lt;li>不要害怕自己的缺點與短處，讓那些成為你的特點吧&lt;/li>
&lt;li>永遠保持著「開始」的那種感覺，不管什麼事情都好，就開始去做吧&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>世界不是缺乏美好的東西，是缺少發現&lt;/li>
&lt;li>去尋找更多的美好的事情，就不用讓自己困在過去了&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>MY FIRST STORY 《LET IT DIE》 中文歌詞 + 心得</title><link>https://dwye.dev/post/this-is-my-final-words/</link><pubDate>Fri, 27 Mar 2020 00:26:00 +0800</pubDate><guid>https://dwye.dev/post/this-is-my-final-words/</guid><description>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/m6tQm4rOge0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>網路上原本的中文歌詞翻譯不見了，趁還有印象的時候趕快把這首很喜歡的歌的歌詞再翻譯一遍，順便記錄一下自己一直以來的觀察。&lt;/p>
&lt;hr>
&lt;h3 id="let-it-die">LET IT DIE&lt;/h3>
&lt;p>作詞 / 作曲：MY FIRST STORY&lt;/p>
&lt;p>&lt;br>
She changes like a black &lt;strong>labyrinth&lt;/strong> every time alone&lt;br>
每次她的改變就像曲折的黑色圖騰&lt;/p>
&lt;p>Begin to doubt if I love you more &amp;amp; more&lt;br>
開始懷疑我對你的愛是否更多&lt;/p>
&lt;p>We&amp;rsquo;re getting nowhere now&lt;br>
我們現在已經沒有去處了&lt;/p>
&lt;p>&lt;br>
今　心から憎み合えたのに&lt;br>
如今，明明能打從心底互相憎恨&lt;/p>
&lt;p>&lt;strong>もう一回　愛し合ってしまえば終われないの&lt;/strong>？&lt;br>
若能再一次墜入愛河的話，就能夠永遠不結束了嗎？&lt;/p>
&lt;p>GAME OVER&lt;/p>
&lt;p>&lt;br>
君との思い出は&lt;strong>掻き消せた&lt;/strong>筈なのに&lt;br>
對你的想念明明已經能夠馬上消逝&lt;/p>
&lt;p>何故か「また会いたい」って心の声がした&lt;br>
為何心中還有「想要再次見面」的聲音&lt;/p>
&lt;p>&lt;strong>もう一度　&amp;ldquo;I wanna be with you&amp;rdquo;??&lt;/strong>&lt;br>
想要再次與你在一起&lt;/p>
&lt;p>&lt;strong>もう二度と　&amp;ldquo;I can&amp;rsquo;t get back with you&amp;rdquo;&lt;/strong>&lt;br>
卻無法再次回到你身邊&lt;/p>
&lt;p>何時になっても言えなかった「最後の言葉」を告げるから&lt;br>
並告訴你那一直沒辦法說出的「最後的話語」&lt;/p>
&lt;p>&lt;strong>We are just breaking up&lt;/strong>&lt;br>
我們正在失去彼此&lt;/p>
&lt;p>&lt;br>
何億回も絡み付いてた&lt;br>
在過去有著數不清的糾纏&lt;/p>
&lt;p>僕と君の赤い糸はパッと切れた&lt;br>
我與你之間的紅線轉眼間就斷裂了&lt;/p>
&lt;p>&lt;br>
She keeps making up excuses and lies,&lt;br>
她讓自己充斥著藉口與謊言&lt;/p>
&lt;p>&lt;strong>HACK &amp;amp; SLASH&lt;/strong>&lt;br>
劈斬與砍殺&lt;/p>
&lt;p>We will get killed by &lt;strong>JACKLAS&lt;/strong>&lt;br>
我們都將會被 Jackals 殺死&lt;/p>
&lt;p>今すぐに　LET IT DIE&lt;br>
現在馬上讓其死去吧&lt;/p>
&lt;p>&lt;br>
真っ黒に染まる世界の中で僕は&lt;br>
染上漆黑色彩的世界裡的我&lt;/p>
&lt;p>生きるのが&lt;ruby>恐&lt;rt>うれ&lt;/rt>&lt;/ruby>くなって歩き方を変えた&lt;br>
因為對活著這件事感到不安而改變了步伐&lt;/p>
&lt;p>真っ白に染まる世界の中で僕は&lt;br>
染上全白色彩的世界裡的我&lt;/p>
&lt;p>死ねる事が嬉しくって歩くのを止めて走り出した&lt;br>
對於能夠死去感到喜悅而奔跑了起來&lt;/p>
&lt;p>We are just breaking up&lt;br>
我們正在失去彼此&lt;/p>
&lt;p>&lt;br>
To be continued…?&lt;/p>
&lt;p>&lt;br>
枯れ果てた心は何と言う？&lt;br>
枯竭的心靈能夠說出什麼？&lt;/p>
&lt;p>I don&amp;rsquo;t know what to do? what to do? 決められずに…&lt;br>
不知道該做什麼？該做什麼？沒有辦法決定&amp;hellip;&lt;/p>
&lt;p>変わりゆく日々を変えたくて&lt;br>
希望能夠改變這逐漸變化的時光&lt;/p>
&lt;p>I don&amp;rsquo;t know what to do? what to do?&lt;br>
不知道該做什麼？該做什麼？&lt;/p>
&lt;p>I don&amp;rsquo;t know what to do? what to do?&lt;br>
不知道該做什麼？該做什麼？&lt;/p>
&lt;p>&lt;br>
&lt;strong>「僕の心が一人になりたがってる」&lt;/strong>&lt;br>
我的心想要變成獨自一人&lt;/p>
&lt;p>こんな嘘　悲しくって涙で濡らしていた&lt;br>
這樣的謊言實在太過悲傷，不禁流出了淚水&lt;/p>
&lt;p>もう一度　愛したい&lt;br>
還想要再愛一次&lt;/p>
&lt;p>もう二度と失いたくない&lt;br>
不想要再度失去了&lt;/p>
&lt;p>僕が本当に言いたかった「最後の言葉」は…&lt;br>
我一開始真正想要說的「最後的話語」是&amp;hellip;&lt;/p>
&lt;p>&lt;br>
君との思い出は掻き消せた筈なのに&lt;br>
對你的想念明明已經能夠馬上消逝&lt;/p>
&lt;p>何故か「また会いたい」って心の声がした&lt;br>
為何心中還有「想要再次見面」的聲音&lt;/p>
&lt;p>もう一度　&amp;ldquo;I wanna be with you&amp;rdquo;??&lt;br>
想要再次與你在一起&lt;/p>
&lt;p>もう二度と　&amp;ldquo;I can&amp;rsquo;t get back with you&amp;rdquo;&lt;br>
卻無法再次回到你身邊&lt;/p>
&lt;p>何時になっても言えなかった「最後の言葉」を告げるから&lt;br>
並告訴你那一直沒辦法說出的「最後的話語」&lt;/p>
&lt;p>&lt;br>
&lt;strong>I love you as a friend&lt;/strong>&lt;br>
我愛你，以朋友的身份&lt;/p>
&lt;p>&lt;br>
To be continued…?&lt;/p>
&lt;hr>
&lt;h3 id="trivia">Trivia&lt;/h3>
&lt;p>一樣提一些個人認為歌詞比較有趣的點&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/Labyrinth.png" alt="">&lt;/p>
&lt;ol>
&lt;li>第一句的「labyrinth」雖然翻譯成迷宮，但其實點進&lt;a href="https://en.wikipedia.org/wiki/Labyrinth">維基百科&lt;/a>就會發現這邊的迷宮並不是我們一般玩遊戲遇到的那種迷宮（通常英文是 &lt;a href="https://en.wikipedia.org/wiki/Maze">maze&lt;/a>），而是一個從&lt;strong>外部到中心只有一條唯一路徑的複雜圖䲢&lt;/strong>（如上圖）。這邊歌詞想講的意思應該是女生的心跟圖騰的路徑一樣，不斷的曲折改變。&lt;/li>
&lt;li>也是第一句的「alone」總是想不出適合的意思，因此沒有特地寫在翻譯裡面。但個人猜測應該是強調每次「分開」又見面時女生都會改變。&lt;/li>
&lt;li>「もう一回愛し合ってしまえば終われないの？」這句的「終われない」是「無法結束」的意思。如果直翻會變成「若能再一次墜入愛河的話，就能無法結束了嗎？」，看起來不是很通順。個人猜測這背後的意思應該是因為主角是被女生斷開關係的一方，因此他希望若次再次彼此墜入愛河，&lt;strong>女生會因為這份「愛」的情感而無法主動讓這份關係結束&lt;/strong>。&lt;/li>
&lt;li>副歌的「もう一度 “I wanna be with you”??」沒有人聽過 Hiro 唱出「I wanna be」的部分，鬼隱的歌詞 XD&lt;/li>
&lt;li>下一句的「もう二度と “I can’t get back with you”」如果日文和英文分開看會很難理解，要先翻譯成日文「&lt;strong>もう二度と君の側に戻れない&lt;/strong>」，這樣意思就會很清楚了。&lt;/li>
&lt;li>「We are just breaking up」這句，「break up」使用了現在進行式，比起「分手」或是字面翻譯成「現在分手」，個人猜測更是強調主角和女生的連結正在互相分開（breaking up 原本的意思）。但也不排除是 Hiro 寫得很順沒想很多 XD&lt;/li>
&lt;li>第二段主歌的「HACK &amp;amp; SLASH」兩個字的本意都是「砍殺」，歌詞上可以接在前面那句變成「She keeps making up excuses and lies, hack and slash.」。然而這句又相關於英文的「砍殺遊戲」，同時「&lt;a href="https://letitdie.gamepedia.com/Jackals">Jackals&lt;/a>」是同名的砍殺遊戲「LET IT DIE」的敵對角色之一，終於有遊戲主題曲的感覺了。&lt;/li>
&lt;li>倒數第二段副歌的「僕の心が一人になりたがってる」用到了第三人稱的「想要」（たがってる，正在想要做什麼），假裝旁觀自己。&lt;/li>
&lt;/ol>
&lt;h3 id="這首歌傳達的">這首歌傳達的&lt;/h3>
&lt;p>主角對一個曾經相愛過的女生，抱持著矛盾的心情，想要做點什麼挽回失去的對方，卻不知道能做什麼。&lt;/p>
&lt;p>雖然是遊戲的同名主題曲，但是歌詞只有稍微點一下遊戲內容，大致上還是在說別的事情 XD&lt;/p>
&lt;p>「I love you as a friend」這句最後想回到女生身邊說的話，一般來說給人把對方打入 Friend Zone（朋友區）的意思，代表兩人之間的愛是屬於「朋友」的愛。個人猜測可以理解成「如果已經完全 game over 的話，至少還是希望能夠回到朋友關係（因為無法回到女生身邊傳達最後的話，可以推斷主角和女生已經斷絕了所有關係）」，主角也希望自己能夠以朋友關係愛著對方。&lt;/p>
&lt;p>然而「To be continued…?」&lt;del>（來個 JOJO 的 BGM）&lt;/del>，也許主角最終的心願仍然是回到彼此相愛的時候，「I love you as a friend」是矛盾的他的另外一個自己，為了防止自己繼續受傷而假裝想要獨自一人，而分離出的自己。也許主角也不知道自己最初真正想要說的「最後的話語」要是什麼。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Matplotlib 中文字體亂碼問題</title><link>https://dwye.dev/post/matplotlib-font/</link><pubDate>Tue, 03 Mar 2020 23:41:25 +0800</pubDate><guid>https://dwye.dev/post/matplotlib-font/</guid><description>
&lt;p>花了一段時間解決這個問題，發篇文章記錄一下。&lt;/p>
&lt;h2 id="嘗試">嘗試&lt;/h2>
&lt;p>一開始想到的是字型設定，所以就看一下系統有哪些中文字型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">fc-list :lang&lt;span style="color:#f92672">=&lt;/span>zh
&lt;/code>&lt;/pre>&lt;/div>&lt;p>挑一個字體在畫圖前修改 font family：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Python" data-lang="Python">plt&lt;span style="color:#f92672">.&lt;/span>rcParams[&lt;span style="color:#e6db74">&amp;#39;font.family&amp;#39;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Noto Sans CJK TC&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然後就炸了&amp;hellip;噴出錯誤訊息：&lt;br>
&lt;code>/usr/local/lib/python3.7/site-packages/matplotlib/font_manager.py:1241: UserWarning: findfont: Font family ['Noto Sans CJK TC'] not found. Falling back to DejaVu Sans.&lt;/code>&lt;/p>
&lt;p>後來找到「&lt;a href="https://medium.com/marketingdatascience/f7b3773a889b">解決 Python 3 Matplotlib 與 Seaborn 視覺化套件中文顯示問題&lt;/a>」這篇文章，裡面提供兩種方法，一種是直接套絕對路徑，另一種則是手動去改設定檔，兩個方法對我而言都蠻麻煩的。&lt;/p>
&lt;h2 id="解法">解法&lt;/h2>
&lt;p>想說能不能動到最少的 code 來解決這個問題，於是換個想法，可能是 &lt;code>Matplotlib&lt;/code> 沒有找到 &lt;code>fc-list&lt;/code> 列出來的字體，所以就來查到底哪些字體是 &lt;code>Matplotlib&lt;/code> 吃得到的呢？&lt;/p>
&lt;p>於是就找到這篇 stackoverflow：「&lt;a href="https://stackoverflow.com/questions/18821795/">How can i get list of font family (or Name of Font) in matplotlib&lt;/a>」&lt;br>
底下的人回答用這個方式可以列出 &lt;code>Matplotlib&lt;/code> 找得到的 &lt;code>.ttf&lt;/code> 字體：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Python" data-lang="Python">&lt;span style="color:#f92672">import&lt;/span> matplotlib.font_manager
[f&lt;span style="color:#f92672">.&lt;/span>name &lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> matplotlib&lt;span style="color:#f92672">.&lt;/span>font_manager&lt;span style="color:#f92672">.&lt;/span>fontManager&lt;span style="color:#f92672">.&lt;/span>ttflist]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>不過列出來很大一串，所以稍微修改一下，用集合去掉重複的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Python" data-lang="Python">&lt;span style="color:#f92672">from&lt;/span> matplotlib &lt;span style="color:#f92672">import&lt;/span> font_manager
font_set &lt;span style="color:#f92672">=&lt;/span> {f&lt;span style="color:#f92672">.&lt;/span>name &lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> font_manager&lt;span style="color:#f92672">.&lt;/span>fontManager&lt;span style="color:#f92672">.&lt;/span>ttflist}
&lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> font_set:
print(f)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>就可以找到所有可用的 font family 了，再也不會被 Falling back to DejaVu Sans 了。&lt;/p>
&lt;p>最後找到的是「AR PL UMing CN」這個字體，居然是用 CN 結尾，而沒有 TW 的，真是神奇。但是至少可以用了。&lt;/p>
&lt;p>順便提供一段簡單的測試代碼：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Python" data-lang="Python">&lt;span style="color:#f92672">from&lt;/span> matplotlib &lt;span style="color:#f92672">import&lt;/span> pyplot &lt;span style="color:#66d9ef">as&lt;/span> plt
plt&lt;span style="color:#f92672">.&lt;/span>rcParams[&lt;span style="color:#e6db74">&amp;#39;font.family&amp;#39;&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;AR PL UMing CN&amp;#39;&lt;/span>
plt&lt;span style="color:#f92672">.&lt;/span>text(&lt;span style="color:#ae81ff">.5&lt;/span>, &lt;span style="color:#ae81ff">.5&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;中文&amp;#39;&lt;/span>, fontsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">50&lt;/span>)
plt&lt;span style="color:#f92672">.&lt;/span>show()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面這是我後來用 macOS 補截圖的，字型和上面不一樣，是正常的&lt;strong>新細明體&lt;/strong> &lt;code>PMingLiU&lt;/code>&lt;br>
&lt;img src="https://i.imgur.com/XhFWbE9.png" alt="matplotlib chinese demo">&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>表單大戰 10 週年</title><link>https://dwye.dev/post/form-war/</link><pubDate>Fri, 14 Feb 2020 14:00:00 +0800</pubDate><guid>https://dwye.dev/post/form-war/</guid><description>
&lt;p>十年前的 3/4，「&lt;strong>表單大戰&lt;/strong>」誕生了。&lt;/p>
&lt;p>於師大附中電算社，展出至少四屆成發（2010~2013）、以及三屆資訊營 Visual Basic 課程的展示作品（2010~2012）的表單大戰，今年終於十歲啦！！&lt;/p>
&lt;p>因此，我在此宣佈，表單大戰 10 週年計畫，正式展開！&lt;/p>
&lt;p>&lt;del>Visual Basic 再戰十年&lt;/del>&lt;/p>
&lt;h2 id="主要項目如下">主要項目如下：&lt;/h2>
&lt;ol>
&lt;li>表單大戰正式開源！請參考： &lt;a href="https://github.com/dwy6626/FormWar">https://github.com/dwy6626/FormWar&lt;/a>&lt;br>
（若要參考 2013 成發展出的版本，可以從 tag 選 &lt;code>v1.3.1.2&lt;/code>）&lt;/li>
&lt;li>發表 &lt;code>v1.4.5.3&lt;/code> 版更新：&lt;br>
&lt;a href="https://github.com/dwy6626/FormWar/releases/download/v1.4.5.3/FormWar.exe">下載點&lt;/a>
&lt;ul>
&lt;li>Code 大幅簡化（減少 copy paste）&lt;/li>
&lt;li>更厲害的表單分身&lt;/li>
&lt;li>更多移動方式&lt;/li>
&lt;li>更多的攻擊方式！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="所以關於表單大戰">所以關於表單大戰&lt;/h2>
&lt;p>我於 2010 年在師大附中電算社用 VB 實作的小程式，而他是一個以 Visual Basic 2008 （VB）寫成的小遊戲（也因為是 VB 所以是 Windows only）。&lt;/p>
&lt;p>簡單來說，就是使用滑鼠追逐奔跑的 Windows Form（表單）的小遊戲。&lt;/p>
&lt;p>表單，其實就是 Windows Form 的 Form 的中文直譯，比較接近現在常用的「視窗」的意思。（後來 Google 表單出現之後，表單這個名詞更常被拿去當作一個需要填寫內容回答問題並送出的線上文件。但是此表單並非彼表單）&lt;/p>
&lt;p>「&lt;strong>表單大戰&lt;/strong>」可以說是我人生第一個自主 Side Project（？）。當時是師大附中電算社高一的我，在社團主要學的是 VB（畢竟當時是第一次接觸程式語言的小孩，對於能夠馬上做出 GUI 程式的比較感興趣。）也因此自己照著社團指導老師李啟龍老師寫的「Visual Basic 2008 程式設計 16 堂特訓」開始跟著範例慢慢跑。&lt;/p>
&lt;p>而當時書中有一個範例程式，是使用滑鼠點選表單，表單就會跑到別的位置。經過一陣腦補之後就成了現在的樣子了。&lt;/p>
&lt;p>還記得發布時最陽春的第一版，一點開程式就是一個 Windows Form （表單）在畫面上奔跑，玩家要用滑鼠去點表單上面的數字，每點一次數字就會 -1，當數字歸零時就結束了。而當數字變小，表單也不會就乖乖讓你點，會放出各種招式妨礙玩家。因為要用滑鼠一直追擊表單，如果沒點好就會不小心點到桌面上各種捷徑（高中生的惡趣味十足）。&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/formwar.gif" alt="form war game play">&lt;/p>
&lt;p>後來新的版本才出現了背景計時、主選單、難度選擇等 Features，版本號也往前推進，因為熟練（？）的玩家數量增加，因此出了個超級難的「&lt;strong>不可能的任務&lt;/strong>」難度，連作者都花了 9 分鐘才全破，自虐意味十足。&lt;/p>
&lt;p>但是這樣自己創造新遊戲然後給自己玩，應該也算是我一直以來的興趣，從最初的 LF2 改版研究了好幾年，出了一版「YDW-LF2」，主打劇情模式，但是平衡炸裂，畢竟是小學生作品（也因為是太久之前，檔案備份我也不存在了，消失的童年，真可惜）。之後是紅色警戒 2 的改版，在素材網搜集素材、利用規則 INI 編寫屬性及 AI 等，然後再做來自己挑戰&amp;hellip;。也許就是這樣的成長歷程，才會有「&lt;strong>表單大戰&lt;/strong>」的誕生吧？&lt;/p>
&lt;h3 id="icon">Icon&lt;/h3>
&lt;p>&lt;img src="https://i.imgur.com/SBuBWW9.png" alt="表單大戰 Icon">&lt;/p>
&lt;p>「&lt;strong>表單大戰&lt;/strong>」的 Icon 其實是由「&lt;strong>Message Box 攻擊！&lt;/strong>」時會出現的警示符號與錯誤符號組成，參考「&lt;strong>終極動員令二：泰伯倫之日&lt;/strong>」的 Icon 排列組成：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/ngAcTSl.png" alt="終極動員令二：泰伯倫之日，圖片取自網路">&lt;/p>
&lt;h2 id="為什麼會有十週年計畫">為什麼會有十週年計畫&lt;/h2>
&lt;p>因為最近在幫實驗室寫互動實驗程式的 GUI，因此就想參考一下以前自己是怎麼寫的，把高中的舊 Code 從雲端全部挖了出來。&lt;/p>
&lt;p>結果 Code 一片慘不忍賭，各種複製貼上，才想到我當時根本沒有學過真正的物件導向，也沒有 Class 和 Function 的概念，原本還想說搞不好可以當自己的作品集，可是這種程度如果放上 GitHub 根本給人笑 QQ。當時也沒有用 Git 進行版控，所以就會有各種不同版本的資料夾，於是決定就趁這個機會花點時間整理一下。&lt;/p>
&lt;p>所有的舊 Project 中最具代表性的當然就是這篇的主角「&lt;strong>表單大戰&lt;/strong>」了，因此就成了我第一個開刀的目標，剛好今年又是第一版發行的十週年，因此就有了這個突發奇想的計畫。&lt;/p>
&lt;p>例如說這個片段，是控制表單移動的部分：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-vbnet" data-lang="vbnet">Randomize()
&lt;span style="color:#66d9ef">If&lt;/span> Val(Label1.Text) &lt;span style="color:#f92672">&amp;lt;&lt;/span> 15 &lt;span style="color:#66d9ef">Then&lt;/span>
&lt;span style="color:#66d9ef">If&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">&amp;lt;&lt;/span> 800 &lt;span style="color:#f92672">And&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">&amp;lt;&lt;/span> 600 &lt;span style="color:#f92672">And&lt;/span> x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span> &lt;span style="color:#f92672">And&lt;/span> y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
&lt;span style="color:#66d9ef">Me&lt;/span>.SetDesktopLocation(&lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">+&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50) &lt;span style="color:#f92672">+&lt;/span> 10, &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">+&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50) &lt;span style="color:#f92672">+&lt;/span> 10)
&lt;span style="color:#66d9ef">ElseIf&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">&amp;gt;&lt;/span> 50 &lt;span style="color:#f92672">And&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">&amp;lt;&lt;/span> 600 &lt;span style="color:#f92672">And&lt;/span> x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span> &lt;span style="color:#f92672">And&lt;/span> y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
&lt;span style="color:#66d9ef">Me&lt;/span>.SetDesktopLocation(&lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">-&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50) &lt;span style="color:#f92672">+&lt;/span> 10, &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">+&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50) &lt;span style="color:#f92672">+&lt;/span> 10)
&lt;span style="color:#66d9ef">ElseIf&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">&amp;gt;&lt;/span> 50 &lt;span style="color:#f92672">And&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">&amp;gt;&lt;/span> 50 &lt;span style="color:#f92672">And&lt;/span> x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span> &lt;span style="color:#f92672">And&lt;/span> y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
&lt;span style="color:#66d9ef">Me&lt;/span>.SetDesktopLocation(&lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">-&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50) &lt;span style="color:#f92672">+&lt;/span> 10, &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">-&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50) &lt;span style="color:#f92672">+&lt;/span> 10)
&lt;span style="color:#66d9ef">ElseIf&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">&amp;lt;&lt;/span> 800 &lt;span style="color:#f92672">And&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">&amp;gt;&lt;/span> 50 &lt;span style="color:#f92672">And&lt;/span> x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span> &lt;span style="color:#f92672">And&lt;/span> y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
&lt;span style="color:#66d9ef">Me&lt;/span>.SetDesktopLocation(&lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">+&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50) &lt;span style="color:#f92672">+&lt;/span> 10, &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">-&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50) &lt;span style="color:#f92672">+&lt;/span> 10)
&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">If&lt;/span>
&lt;span style="color:#66d9ef">Else&lt;/span>
&lt;span style="color:#66d9ef">If&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">&amp;lt;&lt;/span> 800 &lt;span style="color:#f92672">And&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">&amp;lt;&lt;/span> 600 &lt;span style="color:#f92672">And&lt;/span> x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span> &lt;span style="color:#f92672">And&lt;/span> y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
&lt;span style="color:#66d9ef">Me&lt;/span>.SetDesktopLocation(&lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">+&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50), &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">+&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50))
&lt;span style="color:#66d9ef">ElseIf&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">&amp;gt;&lt;/span> 50 &lt;span style="color:#f92672">And&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">&amp;lt;&lt;/span> 600 &lt;span style="color:#f92672">And&lt;/span> x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span> &lt;span style="color:#f92672">And&lt;/span> y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
&lt;span style="color:#66d9ef">Me&lt;/span>.SetDesktopLocation(&lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">-&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50), &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">+&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50))
&lt;span style="color:#66d9ef">ElseIf&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">&amp;gt;&lt;/span> 50 &lt;span style="color:#f92672">And&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">&amp;gt;&lt;/span> 50 &lt;span style="color:#f92672">And&lt;/span> x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span> &lt;span style="color:#f92672">And&lt;/span> y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
&lt;span style="color:#66d9ef">Me&lt;/span>.SetDesktopLocation(&lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">-&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50), &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">-&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50))
&lt;span style="color:#66d9ef">ElseIf&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">&amp;lt;&lt;/span> 800 &lt;span style="color:#f92672">And&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">&amp;gt;&lt;/span> 50 &lt;span style="color:#f92672">And&lt;/span> x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span> &lt;span style="color:#f92672">And&lt;/span> y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
&lt;span style="color:#66d9ef">Me&lt;/span>.SetDesktopLocation(&lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">+&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50), &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">-&lt;/span> Int(Rnd() &lt;span style="color:#f92672">*&lt;/span> 50))
&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">If&lt;/span>
&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">If&lt;/span>
&lt;span style="color:#66d9ef">If&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">&amp;gt;&lt;/span> 800 &lt;span style="color:#f92672">And&lt;/span> x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;span style="color:#66d9ef">ElseIf&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">&amp;gt;&lt;/span> 600 &lt;span style="color:#f92672">And&lt;/span> y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;span style="color:#66d9ef">ElseIf&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.Y &lt;span style="color:#f92672">&amp;lt;&lt;/span> 50 &lt;span style="color:#f92672">And&lt;/span> y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
y_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;span style="color:#66d9ef">ElseIf&lt;/span> &lt;span style="color:#66d9ef">Me&lt;/span>.Location.X &lt;span style="color:#f92672">&amp;lt;&lt;/span> 50 &lt;span style="color:#f92672">And&lt;/span> x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span> &lt;span style="color:#66d9ef">Then&lt;/span>
x_add &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">If&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>就是相當冗長又充滿複製貼上的代碼，而且每個分身表單都有這麼一段。因此這次的一項工程，就是把分身表單的 Code 集中起來，每次召喚分身都從同一個物件 New 一個新的出來而不是直接寫很多份 Code。&lt;/p>
&lt;p>而經過一些簡單的修改之後，這段 Code 變成：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-vbnet" data-lang="vbnet">&lt;span style="color:#66d9ef">Public&lt;/span> &lt;span style="color:#66d9ef">Sub&lt;/span> &lt;span style="color:#a6e22e">FormMove&lt;/span>(&lt;span style="color:#66d9ef">ByRef&lt;/span> form)
Randomize()
form.SetDesktopLocation(
form.Location.X &lt;span style="color:#f92672">+&lt;/span> form.x_sign &lt;span style="color:#f92672">*&lt;/span> SpeedScale,
form.Location.Y &lt;span style="color:#f92672">+&lt;/span> form.y_sign &lt;span style="color:#f92672">*&lt;/span> SpeedScale
)
&lt;span style="color:#66d9ef">If&lt;/span> form.Location.X &lt;span style="color:#f92672">+&lt;/span> form.Size.Width &lt;span style="color:#f92672">&amp;gt;&lt;/span> screenw &lt;span style="color:#f92672">And&lt;/span> form.x_sign &lt;span style="color:#f92672">=&lt;/span> 1 &lt;span style="color:#66d9ef">Then&lt;/span>
form.x_sign &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1
&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">If&lt;/span>
&lt;span style="color:#66d9ef">If&lt;/span> form.Location.Y &lt;span style="color:#f92672">+&lt;/span> form.Size.Height &lt;span style="color:#f92672">&amp;gt;&lt;/span> screenh &lt;span style="color:#f92672">And&lt;/span> form.y_sign &lt;span style="color:#f92672">=&lt;/span> 1 &lt;span style="color:#66d9ef">Then&lt;/span>
form.y_sign &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1
&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">If&lt;/span>
&lt;span style="color:#66d9ef">If&lt;/span> form.Location.Y &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0 &lt;span style="color:#f92672">And&lt;/span> form.y_sign &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1 &lt;span style="color:#66d9ef">Then&lt;/span>
form.y_sign &lt;span style="color:#f92672">=&lt;/span> 1
&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">If&lt;/span>
&lt;span style="color:#66d9ef">If&lt;/span> form.Location.X &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0 &lt;span style="color:#f92672">And&lt;/span> form.x_sign &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1 &lt;span style="color:#66d9ef">Then&lt;/span>
form.x_sign &lt;span style="color:#f92672">=&lt;/span> 1
&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">If&lt;/span>
&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">Sub&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然後讓分身與本尊都來調用這個 Function：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-vbnet" data-lang="vbnet">FormMove(&lt;span style="color:#66d9ef">Me&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>原本的數字 &lt;code>15&lt;/code> 以下會加速的設定，就可以改成另外去修改 &lt;code>SpeedScale&lt;/code> 這個變數：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-vbnet" data-lang="vbnet">&lt;span style="color:#66d9ef">If&lt;/span> Val(Label1.Text) &lt;span style="color:#f92672">&amp;lt;&lt;/span> levelSpeedUp &lt;span style="color:#66d9ef">Then&lt;/span> &lt;span style="color:#75715e">&amp;#39;這邊設定成 15
&lt;/span>&lt;span style="color:#75715e">&lt;/span> SpeedScale &lt;span style="color:#f92672">*=&lt;/span> 1.5
&lt;span style="color:#66d9ef">End&lt;/span> &lt;span style="color:#66d9ef">If&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>維護起來容易很多。（雖然我以後也不一定會繼續來維護了&amp;hellip;XD）&lt;/p>
&lt;p>其實有更好的寫法，利用繼承的方式共同繼承自一個基礎的表單類別，然後把 &lt;code>FormMove&lt;/code> 寫成 Method，不過因為工程浩大，&lt;del>錢不夠多（誤）&lt;/del>，因此就沒有這樣改了。&lt;/p>
&lt;h3 id="小結">小結&lt;/h3>
&lt;p>結論就是這是一個作者自嗨的 Side Project 以及自嗨的十週年計畫，希望大家能夠真的因為這個小遊戲得到一點娛樂，也希望沒有螢幕鍵盤滑鼠因為這個程式受到傷害（？）。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/WDxYswo.png" alt="FormWar Playing">&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Notion 小技巧</title><link>https://dwye.dev/post/notion-tricks/</link><pubDate>Thu, 30 Jan 2020 19:11:23 +0800</pubDate><guid>https://dwye.dev/post/notion-tricks/</guid><description>
&lt;p>這裡搜集了一些我會用到的 Notion 的小技巧。&lt;/p>
&lt;h2 id="換行">換行&lt;/h2>
&lt;p>跟 FB 對話框一樣，如果你想要換行，但不想產生新的 Block，&lt;br>
就按 &lt;code>shift&lt;/code> + &lt;code>enter&lt;/code>，就會在同一個 Block 內換行，可以發現這行和上行距離比較小。&lt;/p>
&lt;p>而且不用像原生 Markdown 一樣要硬要加兩個空白在後面（十分違反直覺），很方便。&lt;/p>
&lt;h2 id="link-a-page-和-mention-a-page-的差別">Link a page 和 mention a page 的差別&lt;/h2>
&lt;p>Linked page 會被視為 subpage，會出現在 sidebar，所以一個 page 內不能多次重複 link 同一個 page。&lt;/p>
&lt;p>但是 mention a page 不會將其視為 subpage，所以可以一直提到那個 page。&lt;/p>
&lt;p>&lt;del>因為很重要所以可以 mention 很多次。&lt;/del>&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="en" dir="ltr">A linked page will be shown as a subpage, a mentioned page will not. For this reason, you can &lt;a href="https://twitter.com/Mention?ref_src=twsrc%5Etfw">@mention&lt;/a> the same page multiple times on a single page, but you can only include one linked page. Does that make sense?&lt;/p>&amp;mdash; Notion (@NotionHQ) &lt;a href="https://twitter.com/NotionHQ/status/1103489598758350848?ref_src=twsrc%5Etfw">March 7, 2019&lt;/a>&lt;/blockquote> &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;h2 id="全域搜尋">全域搜尋&lt;/h2>
&lt;p>Quick Find 在頁面右上角，很遠對吧，又不能用 &lt;code>cmd&lt;/code> + &lt;code>f&lt;/code>（會叫出文章內搜尋），沒關係，可以用 &lt;code>cmd&lt;/code> + &lt;code>p&lt;/code> 來快速使用全域搜尋（老實說有點難記 XD）&lt;br>
（因為我的電腦是 mac，在 windows 系統的話，應該是 &lt;code>ctrl&lt;/code> + &lt;code>p&lt;/code>）&lt;/p>
&lt;h2 id="編輯頁面的熱鍵組合">編輯頁面的熱鍵組合&lt;/h2>
&lt;p>寫上幾個比較實用的，剩下放在連結裡：&lt;/p>
&lt;ul>
&lt;li>&lt;code>cmd&lt;/code> + &lt;code>option&lt;/code> + &lt;code>1~8&lt;/code> 可以轉換 Block 格式（ &lt;code>9&lt;/code> 會變成新的頁面）&lt;/li>
&lt;li>按著 &lt;code>option&lt;/code> 拖拉 Block 可以直接拉出一個新的內容一樣的 Block&lt;/li>
&lt;li>&lt;code>cmd&lt;/code> + &lt;code>a&lt;/code> 可以全選整個 Block 內容，如果按第二次，會全選整個頁面&lt;/li>
&lt;li>和其他文字編輯器一樣，可以用 &lt;code>option&lt;/code> 或 &lt;code>cmd&lt;/code> + &lt;code>→&lt;/code> 或 &lt;code>←&lt;/code> 快速移動游標&lt;/li>
&lt;li>&lt;code>Esc&lt;/code> 可以快速選取整個 Block，如果要刪除就在選取 Block 的時候按 &lt;code>Del&lt;/code> 或 &lt;code>Backspace&lt;/code> 就好了，就不需要用到滑鼠&lt;/li>
&lt;/ul>
&lt;p>（因為我的電腦是 mac，在 windows 系統的話，應該把 &lt;code>cmd&lt;/code> 換成 &lt;code>ctrl&lt;/code> 就可以了）&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>從備忘錄搬移到 Notion</title><link>https://dwye.dev/post/apple-note-to-notion/</link><pubDate>Thu, 30 Jan 2020 17:41:24 +0800</pubDate><guid>https://dwye.dev/post/apple-note-to-notion/</guid><description>
&lt;h2 id="匯出成-md-檔">匯出成 .md 檔&lt;/h2>
&lt;p>首先我們需要一個小幫手：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://falcon.star-lord.me/exporter/">Notes Exporter&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>這個 app 可以一鍵幫你匯出備忘錄裡面所有的筆記，UI 美美的，操作起來也方便，按下去之後等就好~~，真的很有中國人的風格 XD~~&lt;/p>
&lt;p>原先是在 &lt;a href="http://bear.app">Bear.app&lt;/a> 的網站看到的，不過既然都是 Markdown，那我就借來用了。&lt;/p>
&lt;h2 id="匯出之後">匯出之後&lt;/h2>
&lt;p>但總有一些不順利的，例如說匯出之後格式其實還是會跑版，但這時候已經是文字檔了，身為一個 Programmer 就算不是大神，但是寫寫腳本應該還是會的：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/dwy6626/Markdown-Format-Fixer">dwy6626/Markdown-Format-Fixer&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>用法很簡單：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">python main.py &lt;span style="color:#f92672">[&lt;/span>your folder&lt;span style="color:#f92672">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>當然前提是你要裝好 Python，&lt;del>好像還有你要會用 Terminal&lt;/del>，一般來說 macOS 都有內建，但我用的是 Python 3.7，注意一下版本，如果是 2.X 的話我不保證能跑。&lt;/p>
&lt;p>順利的話，你會拿到一堆 &lt;code>.md&lt;/code> 檔。&lt;/p>
&lt;h2 id="匯入-notionso">匯入 Notion.so&lt;/h2>
&lt;p>直接利用內建 import 功能即可：&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/notion-import.png" alt="notion import">&lt;/p>
&lt;h2 id="還需要做的事">還需要做的事&lt;/h2>
&lt;p>在 Note Exporter 的 App changelog 裡面有說：&lt;/p>
&lt;blockquote>
&lt;p>Attachments and url-links are not imported correctly.&lt;/p>
&lt;/blockquote>
&lt;p>沒錯！這就是你需要手動修復的東西&lt;/p>
&lt;p>QQ&lt;/p>
&lt;p>加油吧&lt;/p>
&lt;p>我也是這樣過來的。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Notion 推薦文 - 強大的 Markdown 筆記整理服務</title><link>https://dwye.dev/post/notion-intro/</link><pubDate>Thu, 30 Jan 2020 00:41:23 +0800</pubDate><guid>https://dwye.dev/post/notion-intro/</guid><description>
&lt;h2 id="notion-適合誰">Notion 適合誰？&lt;/h2>
&lt;ul>
&lt;li>跟我一樣的無紙化魔人&lt;/li>
&lt;li>喜歡用鍵盤操作一切的人&lt;/li>
&lt;li>喜歡把筆記弄成看起來很潮的人&lt;/li>
&lt;li>Markdown 信仰者&lt;/li>
&lt;li>資料散佈在世界各地需要整合的人&lt;/li>
&lt;/ul>
&lt;h2 id="我為什麼選擇-notion">我為什麼選擇 Notion&lt;/h2>
&lt;ul>
&lt;li>因為我符合上面那幾點&lt;/li>
&lt;li>想要跨平台（包含手機）、跨電腦（自己的、公司的或實驗室的電腦）做筆記&lt;/li>
&lt;li>Code Block 良好支援（不包含匯入匯出的話）&lt;/li>
&lt;/ul>
&lt;h3 id="我的筆記歷史">我的筆記歷史：&lt;/h3>
&lt;ul>
&lt;li>Google Drive（現在仍然部分在使用）&lt;/li>
&lt;li>Evernote&lt;/li>
&lt;li>Apple 備忘錄&lt;/li>
&lt;li>Notion&lt;/li>
&lt;/ul>
&lt;p>Evernote 是我用的第一個真正的個人資料庫，不過也持續沒多久，而且那時候沒有很多要放 Code 的需求，加上一直有風聲說 Evernote 營運不佳（誰知道現在還活得好好的而且還進化了不少），後來買了 Mac 之後就搬到原生備忘錄（信仰最高）。&lt;/p>
&lt;p>至於搬到 Notion 的理由，就是上面提到的那些了。&lt;/p>
&lt;p>不過有時候簡單的協作上，我還是會和 HackMD 並用，畢竟對中文的支援比較友善，也比較接近純 Markdown 編輯沒有太多複雜功能。&lt;/p>
&lt;p>不知不覺已經用了半年了，現在 Notion 也對學生開放免費使用（2020 年 5 月更宣布&lt;strong>全使用者免費，不再有 Block 數量限制&lt;/strong>），只要使用學校信箱註冊就能直接免費訂閱，因此建議只要有興趣就來試看看吧。而且就算原本用了別的信箱註冊，也能直接更改登入信箱，就能免費使用了。&lt;/p>
&lt;h2 id="notion-簡介">Notion 簡介&lt;/h2>
&lt;p>Notion 是一家始於 2016 年的舊金山的新創公司 &lt;a href="https://www.notion.so/about">Notion Labs Inc.&lt;/a> 的主打產品，架在 AWS 上，目的是想創造一個簡單易用的 &lt;strong>All-In-One workspace&lt;/strong>，能夠個人做資料庫，也能夠讓團隊協作，並整合任何想要增加的內容到一個地方。&lt;/p>
&lt;h2 id="特色">特色？&lt;/h2>
&lt;h3 id="介於-word-和純-markdown-之間的方便性">介於 word 和純 Markdown 之間的方便性&lt;/h3>
&lt;p>Notion 的特色就是所有東西都是由 Block 這個物件組成，什麼東西都可以拖拉組合，排版方便，也支援多欄位。支援 Markdown 語法的同時，不會用 Markdown 的人也可以直接用滑鼠點。&lt;/p>
&lt;p>同時，你想得到的東西都可以插入，像是：&lt;/p>
&lt;ul>
&lt;li>Youtube 影片&lt;/li>
&lt;li>Google Drive 文件&lt;/li>
&lt;li>PDF 檔&lt;/li>
&lt;li>Spotify 歌單（KKBOX 不支援，真對不起大家）&lt;/li>
&lt;/ul>
&lt;h3 id="大量方便編輯的熱鍵">大量方便編輯的熱鍵&lt;/h3>
&lt;p>詳見 &lt;a href="https://dwye.dev/post/notion-tricks">Notion 小技巧&lt;/a>&lt;/p>
&lt;h3 id="支援-code-block">支援 Code Block&lt;/h3>
&lt;p>任何有在寫 Code 的人都需要的功能，我捨棄 Apple 內建備忘錄的原因。這是 Markdown 原本就有的功能，而 Notion（或是其他 Markdown-based 編輯器）加入了 Syntax highlighting。&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/Notion/code-block.png" alt="notion code block">&lt;/p>
&lt;h3 id="就和寫網頁一樣">就和寫網頁一樣：&lt;/h3>
&lt;p>可以善用上面的功能，做出一個跟網頁一樣的 Home Page:&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/Notion/Untitled.png" alt="notion personal home page">&lt;/p>
&lt;p>我的個人頁面（施工中）&lt;/p>
&lt;p>（可能有些人覺得旁邊空空的，他有個選項，可以調整是否限制最大寬度。）&lt;/p>
&lt;p>而頁面裡面又可以插入頁面，一層一層的，就像是把自己的資料庫做成網頁一樣，而不是一般筆記軟體的「分類 &amp;gt; 頁面」兩層式的架構。自訂的自由度相當高。&lt;/p>
&lt;p>就像是自己的 wiki 自己寫那樣。&lt;/p>
&lt;h3 id="筆記分享">筆記分享&lt;/h3>
&lt;p>你可以把你寫好的筆記藉由網址分享給別人。&lt;/p>
&lt;p>&lt;del>不是前端工程師也能做出漂亮的網頁ㄛ&lt;/del>&lt;/p>
&lt;h3 id="大量的模板">大量的模板&lt;/h3>
&lt;p>我懶得自己手刻頁面怎麼辦？沒關係，Notion 有大量的模板可以使用：&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/Notion/Untitled%201.png" alt="notion template">&lt;/p>
&lt;h3 id="包山包海">包山包海&lt;/h3>
&lt;p>沒錯，只要有上面這些模板，加上強大的客製化，可以取代掉很多軟體，像是：&lt;/p>
&lt;ul>
&lt;li>待辦事項&lt;/li>
&lt;li>記帳&lt;/li>
&lt;li>Board&lt;/li>
&lt;li>行事曆&lt;/li>
&lt;li>也可以透過共用筆記達到像 Dropbox Paper 或 HackMD 那樣的協作功能！&lt;/li>
&lt;/ul>
&lt;h3 id="版本紀錄">版本紀錄&lt;/h3>
&lt;p>要是改錯了怎麼辦？跟 Google Drive 一樣，可以一鍵復原！而且可以預覽各個版本的內容，就像 Mac 的 Time Machine 一樣。個人版支援 30 天歷史紀錄，如果是貴得要命的企業版(20 USD per month)，可以無上限還原。&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/Notion/Untitled%202.png" alt="version control">&lt;/p>
&lt;p>支援版本紀錄與還原。&lt;/p>
&lt;p>當然也像維基百科那樣可以查看最近的編輯：&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/Notion/Untitled%203.png" alt="version control and edited">&lt;/p>
&lt;p>最近編輯歷史。&lt;/p>
&lt;h2 id="workspace-概念">Workspace 概念&lt;/h2>
&lt;p>跟 Slack 類似，Notion 支援一個帳號可以進出各個不同的工作區（或著是說這就是 Notion 出現的初衷！）。你可以跟朋友開工作區進行協作，&lt;del>但我沒有朋友，所以沒有去嘗試。&lt;/del>&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/Notion/Untitled%204.png" alt="notion workspace">&lt;/p>
&lt;p>左上角的選單。&lt;/p>
&lt;h2 id="跨平台">跨平台&lt;/h2>
&lt;ul>
&lt;li>Browser 打得開就可以用（&lt;a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B3%E6%9C%8D%E5%8A%A1">SaaS&lt;/a>）&lt;/li>
&lt;li>本地端 App:
&lt;ul>
&lt;li>MacOS、Windows 10、Android 手機、iPad 和 iPhone&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>網頁擷取外掛（Chrome、Firefox）&lt;/li>
&lt;li>手機一鍵加入筆記&lt;/li>
&lt;li>&lt;del>Linux 哭哭&lt;/del>，但可以用網頁版啦&lt;/li>
&lt;/ul>
&lt;h2 id="快速搬遷">快速搬遷&lt;/h2>
&lt;p>&lt;img src="https://dwye.dev/img/Notion/Untitled%205.png" alt="notion workspace">&lt;/p>
&lt;p>所有的 import 選項。&lt;/p>
&lt;ul>
&lt;li>支援直接從競爭對手 evernote 把所有東西搬過來，搬了還有 5 USD 使用額度的獎勵，是多針對XDDD（像我就把五年前的陳舊筆記匯入之後刪掉，只為了 5 USD）&lt;/li>
&lt;li>也支援從 &lt;a href="http://hackmd.io">HackMD.io&lt;/a> 直接打包 .md 檔案匯入（雖然格式會需要調整因為 HackMD 也不是用純的 Markdown）。&lt;/li>
&lt;li>也可以從專案管理軟體 Trello 和 Asana 把整個 Board 搬過來！&lt;del>（每次都看成 &lt;a href="https://zh.moegirl.org/zh-tw/%E7%BB%93%E5%9F%8E%E6%98%8E%E6%97%A5%E5%A5%88">Asuna&lt;/a>）&lt;/del>&lt;/li>
&lt;/ul>
&lt;h3 id="從備忘錄搬入">從備忘錄搬入&lt;/h3>
&lt;p>真的是很痛苦，因為 Apple 不支援批次運出，所以我自己找出了一個解決方案（雖然也不太完美）。有興趣的可以參考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dwye.dev/post/apple-note-to-notion">從備忘錄搬移到 Notion&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="推薦制度">推薦制度&lt;/h2>
&lt;p>你可以從這個 Link 註冊帳號，你跟我都可以直接拿到 10 USD 的使用額度獎勵！&lt;/p>
&lt;p>&lt;a href="https://www.notion.so/?r=20b5ae5c193c4b8f853993c53ba34486">The all-in-one workspace for your notes, tasks, wikis, and databases - Notion&lt;/a>&lt;/p>
&lt;p>如果以年份為單位訂閱的話，一個月是 4 USD，當然也可以用免費版，&lt;del>這樣內容就有上限（而且挺容易爆的如果你跟我一樣筆記很多），但匯入的筆記不算在額度內，所以有個暗黑大法就是永遠用匯入來寫筆記（反正從 evernote 匯入做得這麼棒，不如多用幾次 XDD）。&lt;/del>&lt;/p>
&lt;p>(更新) &lt;a href="https://www.reddit.com/r/Notion/comments/gmrhlb/notion_is_now_free_for_personal_use/">&lt;strong>2020 年 5 月 Notion 已經宣布免費使用者的 Block 數量無上限了&lt;/strong>&lt;/a>，只保留了上傳的檔案大小要在 5 MB 內的限制。&lt;/p>
&lt;p>這個推薦制度也間接鼓勵使用者寫文章來拉大家入坑，就像我這樣 XD&lt;/p>
&lt;h2 id="搬出去">搬出去&lt;/h2>
&lt;p>鑑於 Apple 備忘錄那麼難搬，總是要關心一下如果哪天你不想用&lt;del>或是 Notion 公司倒了&lt;/del>該怎麼辦：&lt;/p>
&lt;p>Notion 支援以下三種匯出模式：&lt;/p>
&lt;ul>
&lt;li>PDF&lt;/li>
&lt;li>Markdown + csv&lt;/li>
&lt;li>HTML&lt;/li>
&lt;/ul>
&lt;p>三種匯出都能正常顯示內容，當然 .md 因為支援的比較少，特殊的 Block 會全部變成 Link。&lt;/p>
&lt;p>其中 PDF 版打包匯出是專業版功能，其他都可以直接打包匯出。&lt;/p>
&lt;p>上面說很像寫網頁，這邊就直接讓你匯出變成網頁了。真的 6。&lt;/p>
&lt;p>&lt;img src="https://dwye.dev/img/Notion/Untitled%206.png" alt="notion workspace">&lt;/p>
&lt;p>匯出之後的資料夾結構。&lt;/p>
&lt;h2 id="缺點">缺點&lt;/h2>
&lt;ul>
&lt;li>Webview 的 app 實在是有點吃效能，尤其是手機版，開得很慢。&lt;/li>
&lt;li>UI 沒有中文，但可以打中文啦。&lt;/li>
&lt;li>Markdown 匯出之後 Code Block 並非 fenced code block，所以 syntax highlighting 會消失。&lt;/li>
&lt;li>(更新) &lt;a href="https://dwye.dev/post/notion-privacy-concerns">中國防火牆問題與隱私權爭議&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="想知道更多嗎">想知道更多嗎？&lt;/h2>
&lt;h3 id="首先是官方完整的-guide">首先是官方完整的 Guide:&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.notion.so/Help-Support-e040febf70a94950b8620e6f00005004">Notion Official: Help &amp;amp; Support&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="在-plurk-上轉發很多次的教學影片">在 Plurk 上轉發很多次的教學影片&lt;/h3>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/Q_PfYlAtvHc" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h3 id="其他人的文章">其他人的文章：&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.inside.com.tw/article/16908-Notion.so-tips">矽谷大受歡迎的筆記軟體：Notion.so - INSIDE&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.playpcesor.com/2018/10/notion.html">從零開始用 Notion 快速打造一個美觀又專業的旅行計畫筆記&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.playpcesor.com/2018/11/notion-google-trello-airtable.html">用 Notion 把筆記整理成像 Google 日曆、 Trello 看板與 Airtable 表格&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/plaintech/notion-9924dcf6c9db">文件排版＋個人資料庫＋專案管理三合一：筆記軟體 Notion 推薦&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=FcnXOicBo0M">23 Notion Tips, Hacks &amp;amp; Tricks&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.playpcesor.com/2017/05/notion.html">Notion 把文件、任務、知識庫「無縫重組」的全新專案整理工具&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.playpcesor.com/2019/03/notion-evernote-web-clipper.html">Notion 筆記軟體推出網頁全文擷取外掛與自動匯入 Evernote&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/everyday-is-discovery-and-learning/notion-so-%E3%81%8C%E3%81%A8%E3%81%A6%E3%82%82%E8%89%AF%E3%81%84-f86d7e86e1bc">Notion.so がとても良い&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/@Johann016/%E6%95%99%E5%AD%B8-%E4%B8%80%E5%B0%8F%E6%99%82%E5%8A%A0%E5%85%A5-notion-so-cd2b5ca8a7fe">從哪開始？一小時上手 Notion.so ⏱&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/jp%E7%B0%A1%E5%A0%B1%E5%9D%8A/notion%E6%95%99%E5%AD%B8-%E5%BE%9E%E5%85%A5%E9%96%80%E5%88%B0%E4%B8%8A%E6%89%8B%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7-baa08ebf9069">Notion教學：從入門到上手操作技巧&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="資料庫欄位自訂語法">資料庫欄位自訂語法：&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://medium.com/@toiee_kame/notion-the-day-of-the-week-9429667975b1">Notion で「曜日」を表示する方法&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Wercker 自動化部署 Hugo 網站</title><link>https://dwye.dev/post/hugo-wercker/</link><pubDate>Tue, 03 Sep 2019 00:01:56 +0800</pubDate><guid>https://dwye.dev/post/hugo-wercker/</guid><description>
&lt;p>&lt;a href="https://dwye.dev/post/first-post">架好這個網站後的第一篇文章&lt;/a>提到，我是用 Wercker 做自動化部署。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/CdBoQ3C.png" alt="wercker">&lt;/p>
&lt;p>其實相關的說明很多，&lt;a href="https://gohugo.io/hosting-and-deployment/deployment-with-wercker/">Hugo 官方說明&lt;/a>也很詳細，看得懂英文的可以參考，看不懂的看&lt;a href="http://handsomezhu.me/2017/10/hugo-blog-setup-tutorial/">這篇簡中的&lt;/a>也行~~，都看不懂&amp;hellip;Google 翻譯是你的好朋友~~。&lt;/p>
&lt;p>不過這篇特別談的是 &lt;code>wercker.yaml&lt;/code> 到底要寫什麼？&lt;/p>
&lt;p>上面的官方說明附上了這個 script:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">box&lt;/span>: &lt;span style="color:#ae81ff">debian&lt;/span>
&lt;span style="color:#f92672">build&lt;/span>:
&lt;span style="color:#f92672">steps&lt;/span>:
- &lt;span style="color:#f92672">arjen/hugo-build&lt;/span>:
&lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.17&amp;#34;&lt;/span>
&lt;span style="color:#f92672">theme&lt;/span>: &lt;span style="color:#ae81ff">herring-cove&lt;/span>
&lt;span style="color:#f92672">flags&lt;/span>: --&lt;span style="color:#ae81ff">buildDrafts=true&lt;/span>
&lt;span style="color:#f92672">deploy&lt;/span>:
&lt;span style="color:#f92672">steps&lt;/span>:
- &lt;span style="color:#f92672">install-packages&lt;/span>:
&lt;span style="color:#f92672">packages&lt;/span>: &lt;span style="color:#ae81ff">git ssh-client&lt;/span>
- &lt;span style="color:#f92672">lukevivier/gh-pages@0.2.1&lt;/span>:
&lt;span style="color:#f92672">token&lt;/span>: &lt;span style="color:#ae81ff">$GIT_TOKEN&lt;/span>
&lt;span style="color:#f92672">domain&lt;/span>: &lt;span style="color:#ae81ff">hugo-wercker.ig.nore.me&lt;/span>
&lt;span style="color:#f92672">basedir&lt;/span>: &lt;span style="color:#ae81ff">public&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>好像複製貼上改一改就可以了，不過遇到了一些問題。畢竟上面那段說明寫的時候，hugo 才 0.17 版，現在這篇文章是用 0.57 版在 build 的，&lt;del>雖然還是一堆 bug 讓我有點想跳槽&amp;hellip;&lt;/del>。&lt;/p>
&lt;h2 id="git-submodule-設置">Git Submodule 設置&lt;/h2>
&lt;p>首先，我的 theme 是 &lt;a href="https://themes.gohugo.io/blackburn/">blackburn&lt;/a>，不過其實我有用 submodule 放在我 local 端的 theme 資料夾裡（而且被我改了不少&amp;hellip;）：&lt;/p>
&lt;script src="https://gist.github.com/dwy6626/09d96962a880be37c61cf5c7c48f247c.js">&lt;/script>
&lt;p>&lt;del>（結果用了 Markdown 還是想插入 gist XDDDDD）&lt;/del>&lt;/p>
&lt;p>所以 &lt;code>theme&lt;/code> 那行可以拔掉。&lt;/p>
&lt;p>另外，因為使用了 git submodule，根據 &lt;a href="//devcenter.wercker.com/integrations/git/submodules/">Wercker 官方的說明&lt;/a>，必須要手動把 submodule 給 &lt;code>clone&lt;/code> 下來（其實也是原本 &lt;code>git clone&lt;/code> 的特性，並不會自動幫導入 submodule），要在 &lt;code>wercker.yml&lt;/code> 把這一步寫入：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml"> - &lt;span style="color:#f92672">script&lt;/span>:
&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">install git&lt;/span>
&lt;span style="color:#f92672">code&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;span style="color:#e6db74"> apt-get update
&lt;/span>&lt;span style="color:#e6db74"> apt-get install git -y&lt;/span>
- &lt;span style="color:#f92672">add-ssh-key&lt;/span>:
&lt;span style="color:#f92672">keyname&lt;/span>: &lt;span style="color:#ae81ff">KEY_NAME&lt;/span>
&lt;span style="color:#f92672">host&lt;/span>: &lt;span style="color:#ae81ff">github.com&lt;/span>
- &lt;span style="color:#f92672">add-to-known_hosts&lt;/span>:
&lt;span style="color:#f92672">hostname&lt;/span>: &lt;span style="color:#ae81ff">github.com&lt;/span>
&lt;span style="color:#f92672">fingerprint&lt;/span>: &lt;span style="color:#ae81ff">16&lt;/span>:&lt;span style="color:#ae81ff">27&lt;/span>:&lt;span style="color:#ae81ff">ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48&lt;/span>
- &lt;span style="color:#f92672">script&lt;/span>:
&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">initialize git submodules&lt;/span>
&lt;span style="color:#f92672">code&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;span style="color:#e6db74"> &lt;/span> &lt;span style="color:#ae81ff">git submodule update --init --recursive&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>不過在 &lt;a href="https://www.kkstream.com/">KKStream&lt;/a> 搞過一些簡單的 CI/CD 之後（你看在 KKStream 什麼都可以學，還不過來當 intern 嗎 XD），回來看到自己的 &lt;code>wercker.yml&lt;/code> 就覺得好像不需要這麼多步驟，真的需要再加一次 ssh key 嗎？還要加一次 known_hosts 嗎？不然一開始 build 的時候，怎麼把檔案從我的 private repo 拉下來的？所以就嘗試刪掉&amp;hellip;就成功了 XD&lt;/p>
&lt;p>順便把 &lt;code>install git&lt;/code> 那步，用 Wercker 自帶的 &lt;code>install-packages&lt;/code> 取代。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml"> - &lt;span style="color:#f92672">install-packages&lt;/span>:
&lt;span style="color:#f92672">packages&lt;/span>: &lt;span style="color:#ae81ff">git&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>於是就變成這樣了：&lt;/p>
&lt;script src="https://gist.github.com/dwy6626/d072c4809db1e04e02e4eab9365e567e.js">&lt;/script>
&lt;p>至於為什麼 &lt;code>$GIT_TOKEN&lt;/code> 變成 &lt;code>$GITHUB_TOKEN&lt;/code>？那就是個環境變數名字，存在 Environment 那格裡面的，所有 pipeline 共用的變數。因為 &lt;a href="https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line">TOKEN 是在 GitHub 生成的&lt;/a>，我覺得這樣叫比較合理而已。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>為什麼我的 Markdown 會跑版？</title><link>https://dwye.dev/post/markdown-intro-history/</link><pubDate>Sun, 01 Sep 2019 00:41:23 +0800</pubDate><guid>https://dwye.dev/post/markdown-intro-history/</guid><description>
&lt;p>這個問題困擾了我好一陣子，直到有朋友和我說，Markdown 有很多種標準，頓時茅塞頓開。既然程式語言有分版本，HTML 也有不同版本，那麼副檔名都是 &lt;code>.md&lt;/code> 的 Markdown 也有很多種版本，似乎也是合理的事情。&lt;/p>
&lt;p>那下一個問題就是：&lt;/p>
&lt;blockquote>
&lt;p>Markdown 有沒有一個&lt;strong>統一&lt;/strong>的標準？&lt;/p>
&lt;/blockquote>
&lt;p>答案是&lt;strong>沒有&lt;/strong>的。&lt;/p>
&lt;p>而且也不會有，因為&lt;strong>大家需要的 Markdown 可能不太一樣&lt;/strong>。&lt;/p>
&lt;p>最簡單的例子就是換行，就標準的 Markdown 語法，當你在 &lt;code>.md&lt;/code> 檔內換行，並不會真的換行。如果你要做到換行，必須在行尾加入兩個空白，或是手動插入 &lt;code>&amp;lt;br&amp;gt;&lt;/code>。不過像是台灣知名的線上筆記服務 &lt;a href="https://hackmd.io/">HackMD&lt;/a>，就很貼心的配合了台灣人的打字習慣，幫你把每個換行都變成真正的換行。&lt;/p>
&lt;p>其實包含 HackMD 在內，大部分的 Markdown 服務都有切換換行模式的選項，為了滿足每種人。也因此 Markdown 不會有真正統一的標準。&lt;/p>
&lt;p>但是撇除這種選項式的差別之外，目前最知名的應該是 &lt;a href="https://commonmark.org/">CommonMark&lt;/a> 了，若要問為什麼叫 CommonMark 這個名字？而 CommonMark 跟一般的 Markdown 有什麼差別？就必須從 Markdown 的歷史說起。&lt;/p>
&lt;h2 id="the-origin">The Origin&lt;/h2>
&lt;p>一切的開端，是 2004 時 &lt;a href="https://daringfireball.net/projects/markdown/syntax">John Gruber 提出的 Markdown 標準&lt;/a>，也是一般所說的經典的 Markdown，以 BSD 開源。&lt;/p>
&lt;h3 id="markdown-的理念">Markdown 的理念&lt;/h3>
&lt;p>John Gruber 的文章寫道：&lt;/p>
&lt;blockquote>
&lt;p>The overriding design goal for Markdown&amp;rsquo;s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it&amp;rsquo;s been marked up with tags or formatting instructions.&lt;/p>
&lt;/blockquote>
&lt;p>簡單來說，就是想要創造一個易讀而且易寫的格式，也因此和 reStructuredText 一同被歸類為輕量級的標記語言（當然不只這兩種，可以參考 &lt;a href="https://github.com/github/markup">GitHub 支援列表&lt;/a>）。比起更早出現的 reStructuredText，Markdown 似乎又更簡單一些，雖然 Markdown 比起 reStructuredText 的功能較少，而且標準化也較晚，但並不影響 Markdown 受歡迎的程度。&lt;/p>
&lt;p>John Grube 以 Perl 寫了第一個 Markdown to html 轉換器，一般被稱為 &lt;code>Markdown.pl&lt;/code>，但沒多久就沒有繼續維護了。而且隨著使用的人越來越多，漸漸有定義相關的問題產生出來，於是後來群雄並起，產生了各種分支。&lt;/p>
&lt;p>原始 Markdown 的語法的中文翻譯可以看&lt;a href="https://markdown.tw/">這個網站&lt;/a>。或是 &lt;a href="https://www.markdownguide.org/basic-syntax">Markdown Guide 這邊有個英文的對照表&lt;/a>。&lt;/p>
&lt;p>值得一提的是，這時候的 Markdown 的 Code Block 並不是大家熟悉的那種 &lt;code>```&lt;/code> 開頭並且可以註記語言種類的 fenced code block：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="color:#e6db74">```javascript
&lt;/span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Hello, markdown!&amp;#39;&lt;/span>)
&lt;span style="color:#e6db74">```&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>而是利用縮排的 indented code block，並不支援 syntax highlighting（因為不能註記語言種類）。注意前面有四個空格（或是一個 &lt;code>tab&lt;/code>）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript"> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Hello, markdown!&amp;#39;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="markdown-extra">Markdown Extra&lt;/h2>
&lt;p>&lt;a href="http://six.pairlist.net/pipermail/markdown-discuss/2005-July/001379.html">2005 年由 Michel Fprtin 發表&lt;/a>，基於原始 Markdown 並修改及新增一些功能，並在當時希望這些能成為未來 Markdown 的標準（下面的 CommonMark 和 GFM 都分別和 Markdown Extra 有一些相同的特色），除了表格之外，其中比較特別的功能是支援腳註（Footnotes）和縮寫。官方編譯是 &lt;a href="https://github.com/michelf/php-markdown">PHP Markdown&lt;/a>。&lt;/p>
&lt;p>因為不是這篇的重點，詳細介紹可以到&lt;a href="https://michelf.ca/projects/php-markdown/extra/">他們的網站&lt;/a>。&lt;/p>
&lt;h2 id="multimarkdown-mmd">MultiMarkdown (MMD)&lt;/h2>
&lt;p>就在 Markdown Extra 發表的隔天，&lt;a href="http://six.pairlist.net/pipermail/markdown-discuss/2005-July/001389.html">Fletcher T. Penney 發表了 MultiMarkdown&lt;/a>，同樣也是基於原始 Markdown，希望能夠變得更接近像是 XHTML 或是 LaTeX 之類的排版語言，可以看&lt;a href="https://fletcherpenney.net/multimarkdown/">作者的介紹&lt;/a>：&lt;/p>
&lt;blockquote>
&lt;p>It adds multiple syntax features (tables, footnotes, and citations, to name a few), in addition to the various output formats listed above (Markdown only creates HTML). Additionally, it builds in “smart” typography for various languages (proper left- and right-sided quotes, for example).&lt;/p>
&lt;/blockquote>
&lt;p>一樣支援表格和腳註等功能，但為了進一步進行更複雜的編寫，也支援引用、數學式、圖片說明等等功能。另外也支援更多的輸出格式，例如 PDF 和 OPML（一種開放式文件檔案格式，可以進一步讓 Microsoft Word 使用）。官方編譯器是原始的 &lt;code>Markdown.pl&lt;/code> 的延伸，存放在&lt;a href="https://github.com/fletcher/MultiMarkdown">這個 repo&lt;/a>。&lt;/p>
&lt;h2 id="commonmark">CommonMark&lt;/h2>
&lt;p>因為原始 Markdown 就這樣缺乏後續的維護，因此就有人提出要接續幫 Markdown 進行語法的標準化以及規範的進一步維護，這就是 &lt;a href="https://commonmark.org/">CommonMark&lt;/a> 的開端。從 2012 年開始，包括 Jeff Atwood（&lt;a href="https://stackoverflow.com/">Stack Overflow&lt;/a> 的共同創辦者之一） 在內的一群人啟動了所謂的 Markdown 標準化工作（&lt;a href="https://blog.codinghorror.com/the-future-of-markdown/">Standard Markdown&lt;/a>，這個專案原本的名字，&lt;a href="https://blog.codinghorror.com/standard-markdown-is-now-common-markdown/">但是在原作者要求之下改名為 CommonMark&lt;/a>，還為此叫他們換掉原本的 domain 並且不能直接重新導向到新網站）。&lt;/p>
&lt;p>根據 Jeff Atwood （註：高中力學教的阿特午機的阿特午，英文也是 Atwood）的 &lt;a href="https://blog.codinghorror.com/the-future-of-markdown/">blog 文章&lt;/a>，這個計畫有以下的目標：&lt;/p>
&lt;ul>
&lt;li>定義&lt;a href="https://spec.commonmark.org/current/">更明確的 spec&lt;/a>，把可能有爭議的語法全部定義清楚要怎麼轉換成 HTML（所以這個檔案超長）&lt;/li>
&lt;li>新增一些選項，可以被關閉 / 開啟以符合各種需求，例如：
&lt;ul>
&lt;li>intra-word emphasis：字串內部的強調是否要用空格隔開&lt;/li>
&lt;li>auto-hyperlink：是否自動為文章中的網址建立超連結&lt;/li>
&lt;li>automatic return-based linebreaks：是否要把 return 視為換行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/commonmark/commonmark-spec">測試集&lt;/a>（和 spec 放在同一個 repo）&lt;/li>
&lt;li>整理已知的變體（&lt;del>雖然 CommonMark 本身就是個變體&lt;/del>）&lt;/li>
&lt;/ul>
&lt;h3 id="因此-commonmark-和原始的-markdown-有這些差別">因此 CommonMark 和原始的 Markdown 有這些差別：&lt;/h3>
&lt;p>新增項目（有許多並非 CommonMark 的創舉，而是很多已經在使用的 Markdown 已經先加入了）：&lt;/p>
&lt;ul>
&lt;li>所有 symbol 都可以被 backslash-escaped（中文叫跳脫字元，為了防止和保留字元混淆，因此在打某些特定符號的時候，例如&lt;code>\&lt;/code>的時候，必須要打成&lt;code>\\&lt;/code>。），因為他們發現一般人很難記得哪些字元要 escape XD&lt;/li>
&lt;li>加入 backslash 換行機制（原本只能雙空白，很難在文字編輯器上面被注意到）&lt;/li>
&lt;li>&lt;code>1)&lt;/code>也可以被當作數字列表（原本只能用 &lt;code>1.&lt;/code>）&lt;/li>
&lt;li>允許非 1 開始的數字列表&lt;/li>
&lt;li>加入大家很常用的 Fenced code blocks：用 &lt;code>```&lt;/code> 和 &lt;code>~~~&lt;/code> 開頭&lt;/li>
&lt;/ul>
&lt;p>更動：&lt;/p>
&lt;ul>
&lt;li>當使用了不同的 list 的符號，會被判斷成分開的 list（例如： &lt;code>-&lt;/code>, &lt;code>+&lt;/code>, &lt;code>*&lt;/code> 以及 &lt;code>1.&lt;/code>, &lt;code>1)&lt;/code>）&lt;/li>
&lt;li>&lt;code>&amp;gt;&lt;/code> 用空行分開後，會被判斷成分開的 Quote，而不是合併成一個&lt;/li>
&lt;li>Link Syntax 改善，e.g. 單引號也可以被用在 Reference Link 的 Title 裡面（原本只有 Inline Link 可以）&lt;/li>
&lt;/ul>
&lt;p>CommonMark 旨在&lt;strong>建立一個嚴謹的標準，而不是支援更多的功能&lt;/strong>，雖然上面有提到新增的語法，但是那些都是替代性語法，並不是真正的新功能。也因此，只要是原始 Markdown 沒有的功能， CommonMark 也不會有。&lt;/p>
&lt;p>官方提供的編譯器有兩個，一個是 &lt;a href="https://github.com/commonmark/cmark">cmark&lt;/a>，一個是 &lt;a href="https://github.com/commonmark/commonmark.js">CommonMark.js&lt;/a>，從名稱就能看出是基於什麼語言、或是給什麼語言用的了。&lt;/p>
&lt;h2 id="github-flavored-markdown-gfm">GitHub Flavored Markdown (GFM)&lt;/h2>
&lt;p>GFM，中文意思是「GitHub 偏好的 Markdown」，&lt;a href="https://github.blog/2017-03-14-a-formal-spec-for-github-markdown/">2017 年發布&lt;/a>，基於 CommonMark，再加上一些 GitHub 上可能會用到的功能，簡單來說，就是 GitHub 現在正在用的 Markdown（但其實在 GFM 之前的 2012 年，GitHub 就有支援 Markdown 了）。&lt;/p>
&lt;h3 id="主要擴充">主要擴充：&lt;/h3>
&lt;p>&lt;a href="https://github.github.com/gfm/">GFM&lt;/a> 的規範在此，這邊僅列出和 CommonMark 不同之處（其實它就是直接從 CommonMark 的 &lt;a href="https://github.com/github/cmark-gfm">cmark 拉個分支出來&lt;/a>）&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.github.com/gfm/#tables-extension-">4.10 表格&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.github.com/gfm/#task-list-items-extension-">5.3 任務列表&lt;/a>（主要給 issue 用的）&lt;/li>
&lt;li>&lt;a href="https://github.github.com/gfm/#strikethrough-extension-">6.5 刪除線&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.github.com/gfm/#autolinks-extension-">6.9 自動超連結的更改&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.github.com/gfm/#disallowed-raw-html-extension-">6.11，過濾掉一些 HTML tag&lt;/a>，將裡面的 &lt;code>&amp;lt;&lt;/code> 取代成 &lt;code>&amp;amp;lt;&lt;/code>，似乎是 GitHub 認為這些標籤在編譯的時候在某些組合會有特殊情況發生。&lt;/li>
&lt;/ul>
&lt;h2 id="關於-hackmd">關於 HackMD&lt;/h2>
&lt;p>&lt;img src="https://dwye.dev/img/Untitled-46f3245a-2064-4a23-8ffa-225aba38fdd7.png" alt="HackMD">&lt;/p>
&lt;p>在台灣寫一篇 Markdown 的文章，不能不提一下 &lt;a href="https://hackmd.io/">HackMD&lt;/a>。&lt;/p>
&lt;p>HackMD 是基於 Markdown 之上（其實他們並沒有說清楚是基於哪種 Markdown 之上，不過你想的到的功能他們都有，甚至還能插入 YouTube 影片），加上一堆很 fancy 的語法，又是台灣出產的線上筆記服務，只要打開瀏覽器就能使用，而且還能即時預覽！&lt;/p>
&lt;p>有開源版本 &lt;a href="https://demo.codimd.org/">CodiMD&lt;/a>，也提供企業版的 SaaS （Software-as-a-Service），還能把版本歷史整合進 GitHub，讓大家愛上 Markdown 的好地方。&lt;/p>
&lt;p>介紹的部分我就不多敘述，隨手 Google 兩篇看起來不錯的介紹：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.playpcesor.com/2016/10/hackmd-hackpad-markdown.html">HackMD 取代 Hackpad 的中文版 Markdown 共筆平台上手教學&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/starrocket/hackmd-product-story-1e332f83d343">為工程師文件而生的協作平台：HackMD 開發故事&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>個人認為在台灣的 Markdown 推廣，HackMD 一定會扮演一個重要的角色，因為真的太好用了，而且又免費！根本佛心來著。&lt;/p>
&lt;h2 id="小結">小結&lt;/h2>
&lt;p>Markdown 有各種規範，也有各種選項可以調整，像是&lt;a href="http://dwy6626.github.io">我的網站&lt;/a>是基於 Hugo，一個 Go 編寫的靜態網站生成器（SSG），&lt;del>所以採用了同樣是 Go 編寫的 &lt;a href="https://github.com/russross/blackfriday">blackfriday&lt;/a> 來編譯&lt;/del>（0.60 版之後的 Hugo 已經改為使用 &lt;a href="https://github.com/yuin/goldmark/">Goldmark&lt;/a> 作為 Markdown 編譯器了，詳情在這篇文章：&lt;a href="https://gohugo.io/news/0.60.0-relnotes/">Now CommonMark Compliant&lt;/a>）。&lt;/p>
&lt;p>為了能夠方便寫作，我在我的網站把可調選項（例如換行）調整成和 HackMD 的選項一樣，希望能夠最大化相容，並且最小化需要額外修改的地方。&lt;/p>
&lt;p>寫了這麼多，希望大家在處理各種 &lt;code>.md&lt;/code> 檔的時候，在享受 Markdown 帶來的便利（和潮感）之外，不要跟我一樣四處踩雷 QQ&lt;/p>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;p>我在寫這篇的時候讀的文章，有些連結附在文章裡面了，就不再貼一次：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.othree.net/log/2017/03/27/github-flavored-markdown/">GitHub Flavored Markdown 標準規範&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.jianshu.com/p/03dccaae11d7">关于Markdown，你应该知道的&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.veekxt.com/article/7">VeekXT&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.markdownguide.org/extended-syntax">Extended Syntax&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://aaronbeveridge.com/markdown/history.html">Markdown Movement&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>茜雫凛《むかしむかし》中文歌詞</title><link>https://dwye.dev/post/mukasi-mukasi/</link><pubDate>Tue, 27 Aug 2019 23:41:23 +0800</pubDate><guid>https://dwye.dev/post/mukasi-mukasi/</guid><description>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/LStSGSQvlco" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;blockquote>
&lt;p>むかしむかし、あるところに&lt;br>
忘れちゃいけない物語がありました。&lt;/p>
&lt;/blockquote>
&lt;p>很久很久以前，某個地方，有著不能被忘記的故事。&lt;/p>
&lt;p>也許是離去的朋友或是親人，能夠一直在一起的美好日子總是會結束的，但還是要樂觀以對呢。&lt;/p>
&lt;hr>
&lt;h3 id="むかしむかし很久很久以前">むかしむかし（很久很久以前）&lt;/h3>
&lt;p>作詞 / 作曲：&lt;a href="https://www.youtube.com/channel/UCF3GFSms-WSRmJKvOgLC7mw">凛(茜雫凛)&lt;/a>&lt;br>
編曲：十川ともじ&lt;/p>
&lt;p>&lt;br>
だんだんとたつ&lt;br>
緩緩地站起&lt;/p>
&lt;p>ひかりを見てました&lt;br>
看著光芒&lt;/p>
&lt;p>行き着くのは　明日がないような&lt;br>
到達一個沒有就像明天的地方&lt;/p>
&lt;p>あなたが望まないもの&lt;br>
不是你所想要的&lt;/p>
&lt;p>たとえば、出来立てのご飯の匂いで&lt;br>
例如說，剛做好的午餐的香味&lt;/p>
&lt;p>目覚めるような&amp;hellip;朝がまだ欲しい&lt;br>
就像醒來的時候&amp;hellip;還想要更多的早晨&lt;/p>
&lt;p>&lt;br>
昨日までの私は綺麗でしたか&lt;br>
昨天為止的我是那麼的美麗&lt;/p>
&lt;p>美しい姿のままで&lt;br>
維持著美麗的姿態&lt;/p>
&lt;p>薄れないで&lt;br>
不會淡去&lt;/p>
&lt;p>ついに君が消えてしまうような日は&lt;br>
最終還是到了你將消失的那一天&lt;/p>
&lt;p>変わらないで　ずっといられるかな&lt;br>
能夠不會改變，成為永恆嗎？&lt;/p>
&lt;p>&lt;br>
便箋に紡ぐ思い滲んでた&lt;br>
書籤中滲透著編織的思念&lt;/p>
&lt;p>さよならと言わない強さも&lt;br>
不說出再見的堅強、&lt;/p>
&lt;p>優しさも諦めもね　分かるんだよ&lt;br>
體貼、以及放棄　我都是了解的&lt;/p>
&lt;p>もう一度会うのはこの空&lt;br>
再一次相遇的是這片天空&lt;/p>
&lt;p>せめて最期は&lt;br>
至少在最後一刻&lt;/p>
&lt;p>青く澄むように&lt;br>
要保持著澄淨的湛藍&lt;/p>
&lt;p>&lt;br>
明日からのあなたはあなたでいるよ&lt;br>
明天之後的你就會是你了&lt;/p>
&lt;p>美しい姿のままで&lt;br>
維持著美麗的姿態&lt;/p>
&lt;p>薄れないで&lt;br>
不會淡去&lt;/p>
&lt;p>ふいに君が私を弱くするから&lt;br>
因為不經意間你使我軟弱&lt;/p>
&lt;p>忘れないで　ずっといられないよ&lt;br>
請不要忘記，是沒辦法成為永恆的喔&lt;/p>
&lt;p>&lt;br>
「むかしむかし&amp;hellip;」&lt;br>
「很久很久以前&amp;hellip;」&lt;/p>
&lt;p>二人は思い出になる&lt;br>
兩人編織了難忘的記憶&lt;/p>
&lt;p>誰にもしられないで&lt;br>
不被誰知道地&lt;/p>
&lt;p>そっと空の向こうまで&lt;br>
靜靜前往天空的另一邊&lt;/p>
&lt;p>&lt;br>
あの日のこと&lt;br>
那一天的事了&lt;/p>
&lt;p>ぼくらは目をそらしてた&lt;br>
我們不再對上目光&lt;/p>
&lt;p>大切なことはいつもそばに&lt;br>
重要的一直在身旁&lt;/p>
&lt;p>&lt;br>
ねぇ　ずっと忘れないで&lt;br>
欸，請永遠不要忘記&lt;/p>
&lt;hr>
&lt;p>這首是凛さん的第一首原創曲，第一次讓大家知道原來凛さん不只會翻唱還能創作，而且是自包作詞作曲！還能找到強大的團隊做出不錯的品質！&lt;/p>
&lt;p>雖然曲風實在是很安全的 J-Pop 就是 XD&lt;/p>
&lt;p>覺得有幾句沒有理解的很好，如果有人有更好的翻法歡迎糾正我~&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>茜雫凛《自縛霊》中文歌詞</title><link>https://dwye.dev/post/jibakurei/</link><pubDate>Wed, 07 Aug 2019 19:09:06 +0800</pubDate><guid>https://dwye.dev/post/jibakurei/</guid><description>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/rjDddkFoIFc" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>作詞 / 作曲：&lt;a href="https://www.youtube.com/channel/UCF3GFSms-WSRmJKvOgLC7mw">茜雫凛（せんな りん）&lt;/a>&lt;br>
編曲：&lt;a href="https://twitter.com/LASTorder_kt">LASTorder&lt;/a>&lt;br>
MV 演出：&lt;a href="https://www.instagram.com/hi_erica_">愛花 -ERICA-&lt;/a>&lt;br>
導演：TSUGUMI MATSUNAGA（A4A）&lt;/p>
&lt;p>&lt;br>
慰められることだけ　好意も期待もない&lt;br>
只是被安慰而已　沒有抱有親切或期待&lt;/p>
&lt;p>悟った者に居場所は無いと閉ざした&lt;br>
把醒悟的人限制在無法屬於任何地方的狀態&lt;/p>
&lt;p>「過去」のそばでどうして待っているの？&lt;br>
為何待在「過去」的身邊等待著呢？&lt;/p>
&lt;p>笑ってないでよ&lt;br>
請不要嘲笑我唷&lt;/p>
&lt;p>&lt;br>
ただずっと耐えてるみたいで&lt;br>
只是似乎一直能夠忍受的關係&lt;/p>
&lt;p>透けていくのを見てるだけで&lt;br>
只是隱約能夠看見些什麼&lt;/p>
&lt;p>でもその姿を諦めないのは&lt;br>
但是不放棄那個模樣是因為&lt;/p>
&lt;p>まだ意味を知らないから&lt;br>
仍然不知道是什麼意思的關係&lt;/p>
&lt;p>&lt;br>
抱えきれない痛みを数えるたびに&lt;br>
每次細數那無法承受的痛苦&lt;/p>
&lt;p>救えるほどの余りがあるのだろうか&lt;br>
大概還是有能夠得救的餘地吧&lt;/p>
&lt;p>消えてしまえ　君のいた景色匂いも&lt;br>
消失吧　你存在的風景與氣味&lt;/p>
&lt;p>全部が嫌いだ&lt;br>
全部都令人生厭&lt;/p>
&lt;p>&lt;br>
瞬間刹那　消えてしまうなら&lt;br>
轉眼之間　全部都消失的話&lt;/p>
&lt;p>私に爪跡を残して&lt;br>
在我身上留下指甲的痕跡吧&lt;/p>
&lt;p>心失くしては生きてゆけないよ&lt;br>
弄丟了心靈就無法再活下去了喔&lt;/p>
&lt;p>あの子は笑ってるのに&lt;br>
而那女孩卻明明還笑著&lt;/p>
&lt;p>&lt;br>
あぁ　どうせさ&lt;br>
啊　為何呀&lt;/p>
&lt;p>答えを探してもない&lt;br>
找著也找不出解答&lt;/p>
&lt;p>出口なんてないんでしょ&lt;br>
出口什麼的根本就不存在的吧？&lt;/p>
&lt;p>いつも間に合っていない&lt;br>
不知不覺之間已經不再合得來&lt;/p>
&lt;p>&lt;br>
ただずっと耐えてるみたいで&lt;br>
只是似乎一直能夠忍受的關係&lt;/p>
&lt;p>透けていくのを見てるだけで&lt;br>
只是隱約能夠看見些什麼&lt;/p>
&lt;p>言葉亡くしては君が見えないよ&lt;br>
失去冷靜的言語，看不見身影的你&lt;/p>
&lt;p>答えはみつからぬまま&lt;br>
保持著找不到解答的狀態&lt;/p>
&lt;p>&lt;br>
まだ夢を見てたいのに&lt;br>
明明還想要一直做著夢&lt;/p>
&lt;hr>
&lt;p>自縛靈，在日文因為和地縛靈同音，常常被混用，但這邊的第二句歌詞：&lt;/p>
&lt;blockquote>
&lt;p>悟った者に居場所は無いと閉ざした&lt;/p>
&lt;/blockquote>
&lt;p>大概暗示了這邊是採用自縛靈原本的意思：「被自己困住的靈體」。&lt;/p>
&lt;p>這句話本身還蠻難理解的的，就算理解了，也很難用中文寫出來&amp;hellip;。我把「悟った者」理解成醒悟的人，但其實也不一定是人，就看各自怎麼解釋吧 XD，然後「居場所は無い」是常用的用法，比起「居無定所」，「沒有一個感到放鬆或是歸屬的地方」是更常用的解釋。而說這句話的人（或靈）把「悟った者」鎖在這樣的情境裡面。&lt;/p>
&lt;p>綜合整首的歌詞來看，我覺得這邊的「悟った者」大概就是第一人稱的人（或靈）自己了。&lt;/p>
&lt;p>&lt;br>
這首歌在凛さん的原創曲中也算是蠻特別的，凛さん沒有在自己的推特發文宣傳（其他大小新作品發表她都會在 IG 和推特同時分享），Youtube 評論也罕見的關起來，不知道這本身代表著什麼意義呢？&lt;/p>
&lt;p>同時這大概也是凛さん在&lt;a href="https://www.youtube.com/channel/UCjBt6WpPI_jXslSTqFRPnZw">こもれびちゃんねる&lt;/a>的最後一個作品，在那天她同時公開了新頻道 &lt;a href="https://www.youtube.com/channel/UCF3GFSms-WSRmJKvOgLC7mw">Senna Rin&lt;/a> 並發表了天氣之子的插入曲之一—— RADWIMPS 的「グランドエスケープ」的 cover。&lt;/p>
&lt;p>&lt;br>
也許這個頻道本身就將成為一個留在過去的自縛靈吧？&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>茜雫凛《AIのうた》中文歌詞</title><link>https://dwye.dev/post/ai-no-uta/</link><pubDate>Mon, 05 Aug 2019 17:49:26 +0800</pubDate><guid>https://dwye.dev/post/ai-no-uta/</guid><description>
&lt;p>這是一個用裝了人工智慧的機器人照顧老婆婆，陪伴老婆婆到離開的故事。&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/I8tXNMps-ZQ" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
（凛さん唯獨在這首歌禁止外部播放，需要點進去 YouTube 聽）
&lt;hr>
&lt;h2 id="aiのうたai的歌">AIのうた（AI的歌）&lt;/h2>
&lt;p>作詞 / 作曲：茜雫凛（せんな りん）&lt;br>
編曲：浅野尚志&lt;br>
動画：金子開発&lt;/p>
&lt;p>&lt;br>
愛なんて語れない ココロを取り除いた&lt;br>
無法談論「愛」 因為去除了「心」&lt;/p>
&lt;p>人が創り出したそれは　&lt;ruby>Ａ&lt;rt>えい&lt;/rt>Ｉ&lt;rt>あい&lt;/rt>だった&lt;/ruby>&lt;br>
是人為製作出來的 AI&lt;/p>
&lt;p>&lt;br>
血の代わりに電気を　骨の代わりにアルミを&lt;br>
以電力代替血液　以鋁金屬代替骨頭&lt;/p>
&lt;p>人の代わりになる為の  &lt;ruby>愛し&lt;rt>かなし&lt;/rt>&lt;/ruby>き少年よ&lt;br>
以代替人類而誕生的　可愛而悲傷的少年&lt;/p>
&lt;p>&lt;br>
無感情に語りかけて&lt;br>
機械式地和你搭話&lt;/p>
&lt;p>涙を流すことも　許されないでしょう&lt;br>
流淚大概也是不被允許的吧&lt;/p>
&lt;p>&lt;br>
例えばほら 愛の意味が「犠牲」と言うのならば&lt;br>
例如說，把愛的意義解釋成「犧牲」的話&lt;/p>
&lt;p>あなた色に染まる  &lt;ruby>ＡＩ&lt;rt>わたし&lt;/rt>&lt;/ruby>になるよ&lt;br>
那我會成為你專屬的 AI 喔&lt;/p>
&lt;p>&lt;br>
積み重ねた時間も 探してみた言葉も&lt;br>
不斷累積重複的日子以及不斷嘗試的言語&lt;/p>
&lt;p>覚えてるよ 忘れないよ&lt;br>
全部都牢記著，不會忘記的唷&lt;/p>
&lt;p>あと何が欲しい？&lt;br>
接下來還需要什麼嗎？&lt;/p>
&lt;p>&lt;br>
何も応えないから君を知ろうとしたよ&lt;br>
不需要回應也沒關係，我已經了解你了啊&lt;/p>
&lt;p>瞳閉じて 眠ったまま&lt;br>
你闔上雙眼 保持著沉睡&lt;/p>
&lt;p>&lt;ruby>ＡＩ&lt;rt>わたし&lt;/rt>&lt;/ruby>より冷たい&lt;br>
身體比 AI 的我還要冰冷&lt;/p>
&lt;p>&lt;br>
「今すぐにね、直し方を見つけてあげるからね。少し待っていてね。｣&lt;br>
「我現在馬上去幫你找出修復的方法，在這裡稍微等下喔。」&lt;/p>
&lt;p>&lt;br>
無感情な声が響く 本当は泣きたいのに&lt;br>
明明真的很想哭泣，卻只能發出機械般的聲響&lt;/p>
&lt;p>同じ時間だけを生きていけたなら&lt;br>
要是能只和你擁有相同的壽命的話就好了&lt;/p>
&lt;p>&lt;br>
壊れたのはきっと&lt;ruby>ＡＩ&lt;rt>わたし&lt;/rt>&lt;/ruby>&lt;br>
我一定是哪裡出了問題&lt;/p>
&lt;p>あなたが居なくなっておかしくなったんだ&lt;br>
因為你已不在，一切都變得奇怪起來&lt;/p>
&lt;p>&lt;br>
わかってるよ&lt;br>
我是知道的喔&lt;/p>
&lt;p>電源を消して　記憶を消去すれば&lt;br>
關機之後　刪除記憶就好了&lt;/p>
&lt;p>でも忘れたくない　あの優しさを&lt;br>
但卻不想忘記那份溫柔&lt;/p>
&lt;p>&lt;br>
血の代わりに電気を　骨の代わりにアルミを&lt;br>
以電力代替血液　以鋁金屬代替骨頭&lt;/p>
&lt;p>あなたの代わりになる為の　 &lt;ruby>愛し&lt;rt>かなし&lt;/rt>&lt;/ruby>き少年に&lt;br>
為了代替你而誕生的　可愛而悲傷的少年&lt;/p>
&lt;hr>
&lt;h2 id="trivia">Trivia&lt;/h2>
&lt;ol>
&lt;li>「ココロを取り除いた」比較精確的意思是，「心」從設計上人為地被拿掉了，含有不需要心靈的意味在。當然也可以腦補成派機器人來的人本身是沒有「心」的。這首歌就是在描述沒有心的機器人，在照顧老婆婆的過程中，漸漸成長出了心的故事。&lt;/li>
&lt;li>「人が創り出したそれは　&lt;ruby>Ａ&lt;rt>えい&lt;/rt>Ｉ&lt;rt>あい&lt;/rt>だった&lt;/ruby>」這句非常有意思，如果字面上看，就是「人為製作出來的，那就是 AI」，但如果把 AI 連起來，讀音就會變成「愛」，這句就變成「人為製作出來的愛」，不是真心的愛，不知道是不是凛さん本意。&lt;/li>
&lt;li>「愛しき」原本是可愛或是愛慕的意思，但這邊直接讀成悲傷的音，有種說不出口的悲傷。&lt;/li>
&lt;li>「あなた色に染まる」直翻的話就是「染上了你的顏色」，而意思比較接近「成為對方的風格」，我個人覺得這邊應該有「為了你而成為另外一個你」的意思。&lt;/li>
&lt;/ol>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>第一次發翻譯，雖然以前也有在別的地方翻譯過一些歌，但可能是太久沒接觸中文寫作了，覺得常常找不到好詞（畢竟是個工程師XD）&lt;br>
有任何錯誤或建議歡迎留言喔。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>茜雫凜 (Senna Rin) 介紹</title><link>https://dwye.dev/post/senna-rin-intro/</link><pubDate>Sun, 04 Aug 2019 17:21:28 +0800</pubDate><guid>https://dwye.dev/post/senna-rin-intro/</guid><description>
&lt;p>&lt;img src="https://pbs.twimg.com/media/D_1PNKMUwAAnuid?format=jpg" alt="senna rin">&lt;/p>
&lt;p>&lt;ruby>茜雫&lt;rt>せんな&lt;/rt>凜&lt;rt>りん&lt;/rt>&lt;/ruby>是日本一個 cover 日文歌的 JK（女子高中生），九州的&lt;a href="https://twitter.com/senna_rin/status/1023887599499276288">福岡人&lt;/a>，目前高中二年級，&lt;a href="https://twitter.com/senna_rin/status/1040211770495782913">生日是 9 月 23 日&lt;/a> &lt;del>（和我一樣是天秤）&lt;/del>&lt;/p>
&lt;p>透過 Youtube 發表作品，發表的 cover 主要以流行歌為主，有簡單的吉他彈唱 cover，也有重新編曲過的，錄音和 MV 品質都蠻好的，唱的當然也很好！&lt;/p>
&lt;p>常 cover 的歌手/團體有：&lt;/p>
&lt;ul>
&lt;li>Aimer&lt;/li>
&lt;li>米津玄師&lt;/li>
&lt;li>RADWIMPS&lt;/li>
&lt;li>Mr. Children&lt;/li>
&lt;li>Back number&lt;/li>
&lt;li>aiko&lt;/li>
&lt;/ul>
&lt;h2 id="頻道名稱-こもれびちゃんねる">頻道名稱 「こもれびちゃんねる」&lt;/h2>
&lt;p>「こもれび」大概就是「木漏れ日」，日文維基百科這樣寫的：&lt;/p>
&lt;blockquote>
&lt;p>森林などの木立ちから太陽の日差しが漏れる光景のこと。&lt;/p>
&lt;/blockquote>
&lt;p>森林中從木葉縫隙中滲入的陽光所形成的景象，在我想像大概是這樣：&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/Ci8welIUNrQ" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>「ちゃんねる」就是頻道，所以大概可以理解成「林間隙光的頻道」，也正好凛さん頻道裡面的歌，大多都是輕柔系的，當然也有些帶著淡淡的哀傷，像是&lt;a href="https://dwye.dev/post/ai-no-uta">AIのうた&lt;/a>。&lt;/p>
&lt;p>凛さん的聲音其實蠻療癒的，悲傷的歌也不會太過沈重那種，很溫柔的聲音，很適合一首一首聽下去。&lt;/p>
&lt;h2 id="翻唱內容">翻唱內容&lt;/h2>
&lt;p>從 2017 年上傳第一部 &lt;a href="https://www.youtube.com/watch?v=y7UZnI8xWKo">Himawari&lt;/a> 開始，我寫這篇的時候已經有 41 首 cover，而且陸續增加中。&lt;/p>
&lt;p>其中播放次數超過千萬的一首：&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/PdE4P-hm2hg?autoplay=1" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>當然不能否認也是搭上 Aimer 的人氣，但是 Aimer 這首歌的 MV 才 100 萬次閱覽，這首 cover 是十倍人氣啊！！&lt;br>
&lt;del>今年是十倍嗎？？&lt;/del>&lt;br>
這首歌也是我認識凛さん的原因。&lt;/p>
&lt;p>偶爾會有些自創曲，目前已經有四首了，這首也是其中一首。&lt;br>
自創曲完成度都意外的很高，編曲/錄音/拍攝都有一定水準，完全就是以後順著出道也不意外的類型，而且也累積了不少粉絲了，雖然本人最近才在 IG 限時動態的 QA 說沒有事務所就是。&lt;/p>
&lt;p>十六萬訂閱，除了日本國內之外，外國也有不少粉絲，之前 IG 直播（直播其實蠻稀有的，畢竟凛さん是個高中生，剛好我在下班時間的車上看到的）的時候，有些人和我一樣在報國籍 XDDD&lt;/p>
&lt;p>一開始活動的時候名字只有「凛」一個字，後來才加上姓氏「茜雫」，讀作&lt;del>西卡&lt;/del>才不對，是 Senna，合起來就是 &lt;strong>Senna Rin&lt;/strong>。&lt;/p>
&lt;p>最近開了新的&lt;a href="https://www.youtube.com/channel/UCF3GFSms-WSRmJKvOgLC7mw">頻道&lt;/a>，不知道為什麼不是選擇改名，可能有什麼新的個人計畫吧～&lt;/p>
&lt;p>但這邊就比較少人了，路過幫點一下支持吧，這是天氣之子的電影主題曲之一「グランドエスケープ」：&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/LPP5dd-Oat0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;h2 id="其他">其他&lt;/h2>
&lt;p>上面那些個人資料其實不用特別去查，本人都有說 XD&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">福岡！&lt;/p>&amp;mdash; 茜雫凛 (@senna_rin) &lt;a href="https://twitter.com/senna_rin/status/1023889541319471104?ref_src=twsrc%5Etfw">July 30, 2018&lt;/a>&lt;/blockquote> &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;!-- ![](https://i.imgur.com/QtMWhOo.png)
![](https://i.imgur.com/zeWuWgo.png) -->
&lt;blockquote class="twitter-tweet">&lt;p lang="und" dir="ltr">23💕&lt;/p>&amp;mdash; 茜雫凛 (@senna_rin) &lt;a href="https://twitter.com/senna_rin/status/1040213127357296640?ref_src=twsrc%5Etfw">September 13, 2018&lt;/a>&lt;/blockquote> &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>讓 VSCode 的 Terminal 執行 Conda 的 Python</title><link>https://dwye.dev/post/vscode-python-terminal/</link><pubDate>Mon, 29 Jul 2019 15:47:44 +0800</pubDate><guid>https://dwye.dev/post/vscode-python-terminal/</guid><description>
&lt;p>其實這個問題一直都有在困擾我，不過因為通常都是用 iTerm 另外開 Terminal 測試，或是直接用 VSCode 的 Python Plug-in 執行，所以就比較還好。因為想寫 Side Project，今天決定先認真來解決這個問題。&lt;/p>
&lt;p>於是就找到了這個 issue:&lt;/p>
&lt;p>&lt;a href="https://github.com/Microsoft/vscode-python/issues/4434">https://github.com/Microsoft/vscode-python/issues/4434&lt;/a>&lt;/p>
&lt;p>裡面的 &lt;a href="https://github.com/praenubilus">praenubilus&lt;/a> 這位大大有說到，原因是 VSCode 在啟動 Terminal 時，可能有特別的 Shell Initialization，這會導致 Conda 的 &lt;code>$PATH&lt;/code> 被排在後方，而非前方，可以透過 &lt;code>echo $PATH&lt;/code> 指令來查看：&lt;/p>
&lt;p>這是一般使用 iTerm 開的：&lt;/p>
&lt;pre>&lt;code>/Users/xxx/miniconda3/bin:/Users/xxx/miniconda3/condabin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
&lt;/code>&lt;/pre>&lt;p>這是使用 VSCode 的內建 Terminal：&lt;/p>
&lt;pre>&lt;code>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/xxx/miniconda3/bin:/Users/xxx/miniconda3/condabin
&lt;/code>&lt;/pre>&lt;h2 id="一個-magic-workaround">一個 Magic Workaround&lt;/h2>
&lt;p>&lt;a href="https://github.com/praenubilus">praenubilus&lt;/a> 也提供了一個一個簡單的暫時改善方法：&lt;br>
在 Setting 裡面搜尋 &lt;code>terminal.integrated.env.osx&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/4S3p7Hq.png" alt="terminal search result">&lt;/p>
&lt;p>因為好像不能直接在 GUI 修改，所以我是在 Edit in settings.json 打開設定檔，加入：&lt;/p>
&lt;pre>&lt;code>&amp;quot;terminal.integrated.env.osx&amp;quot;: {
&amp;quot;PATH&amp;quot;: &amp;quot;&amp;quot;
}
&lt;/code>&lt;/pre>&lt;p>這樣就可以得到一個&lt;strong>乾淨的Terminal&lt;/strong>（參見這篇 issue: &lt;a href="https://github.com/microsoft/vscode/issues/70248">Support using a &amp;ldquo;clean&amp;rdquo; environment for the terminal&lt;/a>)&lt;/p>
&lt;p>同時打開 Terminal 時，也可以正常找到 Conda 的 Python，可以透過 &lt;code>which python&lt;/code> 指令來確認，應該要得到下面的結果：&lt;/p>
&lt;pre>&lt;code>/usr/local/miniconda3/bin/python
&lt;/code>&lt;/pre>&lt;p>至於正式的改善方案&amp;hellip;還是個 Open issue:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/microsoft/vscode/issues/47816">Feature Request: Reload environment variables on new integrated terminal instance&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>未了</title><link>https://dwye.dev/post/sodagreen-endless/</link><pubDate>Sat, 08 Jun 2019 01:26:27 +0800</pubDate><guid>https://dwye.dev/post/sodagreen-endless/</guid><description>
&lt;p>或許或多或少，或是不記得主角的名字&lt;br>
但也許你聽過一個希臘神話&lt;br>
關於一個罪人被神降下永恆的勞動懲罰&lt;br>
勞動的內容，是推動巨石上山&lt;br>
當這個任務完成後，巨石就會滾下山&lt;br>
於是形成無止盡迴圈&lt;/p>
&lt;p>如果用一個什麼故事都是有結束的觀點來看&lt;br>
那麼這樣的懲罰是沒有止盡的痛苦&lt;br>
沒有結局，不斷重複&lt;br>
無論怎麼努力，都看不到盡頭&lt;/p>
&lt;p>這首歌是在描述另外一個觀點&lt;br>
即使沒有迎來盡頭&lt;br>
過程的本身也是生命的一部分：&lt;/p>
&lt;blockquote>
&lt;p>雖然反覆，卻漸漸懂得：每一步都是自己的；&lt;br>
不愛永恆，但求現在：真實活著的人生。&lt;/p>
&lt;/blockquote>
&lt;p>走出悲傷什麼的，總是會這麼說&lt;br>
因為想要擺脫現在的困境&lt;br>
所以焦躁地想要做些什麼&lt;br>
但實際上不可能物理上地與自己分割&lt;br>
不管怎麼樣的自己，都是自己的一部分&lt;/p>
&lt;p>也或許當有什麼走不出的情緒&lt;br>
其實也不存在走出去的一天&lt;br>
所以換個角度&lt;br>
學習與那個自己共存&lt;br>
學會活用那樣負面的情緒所帶來的力量&lt;br>
比起拋下或是脫離什麼的&lt;br>
更是真實活著的人生吧&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/xiUc8m5lxcQ" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>在 Jupyter 使用虛擬 Python 環境</title><link>https://dwye.dev/post/venv-jupyter/</link><pubDate>Mon, 04 Mar 2019 23:41:25 +0800</pubDate><guid>https://dwye.dev/post/venv-jupyter/</guid><description>
&lt;p>因為交作業要有特定套件，但調參數還是用 Jupyter 方便，所以就研究了下怎麼用特定的 Python 來執行 Jupyter Notebook 或是 JupyterLab。方法有兩種，首先我們先從創建虛擬環境講起：&lt;/p>
&lt;h2 id="準備">準備&lt;/h2>
&lt;h3 id="創建虛擬環境">創建虛擬環境&lt;/h3>
&lt;p>這邊以 conda 為例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">conda create --name new_env python&lt;span style="color:#f92672">=&lt;/span>3.6
&lt;/code>&lt;/pre>&lt;/div>&lt;p>輸入 y（或是直接 enter）就完成這步了，可以看一下視窗內部的訊息來確認。或是列出現有的環境：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">conda env list
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="啟動虛擬環境">啟動虛擬環境&lt;/h3>
&lt;p>確認你的 .bashrc（或是 macOS 上：.bash_profile）有包含你的虛擬環境的路徑：（以我的 miniconda 為例）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e"># .bash_profile&lt;/span>
export PATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/usr/local/miniconda3/bin:&lt;/span>$PATH&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接著用這行指令就可以直接啟動了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">conda activate new_env
&lt;/code>&lt;/pre>&lt;/div>&lt;p>這時候命令列的前方會多出一個 &lt;code>(new_env)&lt;/code>，就代表我們已經進入這個虛擬環境了，但這時候我們的 Python 還是系統預定的版本，記得也為他安裝一個 Python：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">conda install python&lt;span style="color:#f92672">=&lt;/span>你要安裝的版本
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="第一招在原本的-jupyter-中加入新的-kernel">第一招：在原本的 Jupyter 中加入新的 Kernel&lt;/h2>
&lt;p>首先照著上面做的進入虛擬環境，然後安裝 ipykernel：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">conda install ipykernel
&lt;/code>&lt;/pre>&lt;/div>&lt;p>沒意外的話會有一大堆相依套件被安裝，按 y 繼續就好。&lt;br>
接下來確認一下你的 Python 是正確的 Python：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&amp;gt; which python
/usr/local/miniconda3/envs/new_env/bin/python
&lt;/code>&lt;/pre>&lt;/div>&lt;p>正確的話就可以直接幫 Jupyter 增加新的 kernel：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">python -m ipykernel install --name another_name
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接著列出可以使用的 kernel，檢查是否成功：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">jupyter kernelspec list
&lt;/code>&lt;/pre>&lt;/div>&lt;p>就會看到剛剛加入的 kernel&lt;/p>
&lt;p>&lt;img src="//i.imgur.com/mVfFZOD.png" alt="jupyter kernel list">&lt;/p>
&lt;h3 id="切換-kernel">切換 kernel&lt;/h3>
&lt;p>可以直接在新增的時候選擇 kernel，或是進入 notebook 之後再修改 kernel。&lt;/p>
&lt;p>Jupyter lab 選擇頁面：&lt;br>
&lt;img src="//i.imgur.com/fCC5TdM.png" alt="Jupyter lab 選擇頁面">&lt;/p>
&lt;p>notebook 切換 kernel：&lt;br>
&lt;img src="//i.imgur.com/w7I31we.png" alt="notebook 切換 kernel">&lt;/p>
&lt;h2 id="第二招為虛擬環境安裝獨立的-jupyter">第二招：為虛擬環境安裝獨立的 Jupyter&lt;/h2>
&lt;p>一樣先進入虛擬環境，然後直接在裡面安裝 Jupyter：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">conda install jupyter
&lt;/code>&lt;/pre>&lt;/div>&lt;p>沒啥特別好說的，你開心也可以用 pip。然後去泡杯茶等它安裝好就行了。&lt;/p>
&lt;p>這時候你的 Jupyter 應該就會被置換成虛擬環境的版本，可以用 which 確認一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&amp;gt; which jupyter
/usr/local/miniconda3/envs/new_env/bin/jupyter
&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下來就跟平常一樣，走進你喜歡的根目錄之後開啟 Jupyter，就大功告成了&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>使用 Bcc 保護收件人的隱私</title><link>https://dwye.dev/post/bcc/</link><pubDate>Wed, 16 Jan 2019 21:00:20 +0800</pubDate><guid>https://dwye.dev/post/bcc/</guid><description>
&lt;!-- 寄信的學問：To? CC? BCC? -->
&lt;p>最近發生太多被洩露 email 的案件，決定來寫一篇文。&lt;/p>
&lt;p>寄信也是有很多學問的，這篇只是其中一環。&lt;/p>
&lt;p>&lt;a href="https://hackmd.io/s/Bk-jM3hMV">HackMD version&lt;/a>&lt;/p>
&lt;h2 id="toccbcc">To/Cc/Bcc?&lt;/h2>
&lt;h3 id="收件者-to">收件者 To&lt;/h3>
&lt;ul>
&lt;li>主要需要收到你這封信的人（們）&lt;/li>
&lt;/ul>
&lt;h3 id="副本-carbon-copy-cc">副本 Carbon Copy (Cc)&lt;/h3>
&lt;ul>
&lt;li>把你的信件複製一份給別人做參考&lt;/li>
&lt;li>收件者和被 Cc 的人彼此看得到對方&lt;/li>
&lt;/ul>
&lt;h3 id="密件副本-blind-carbon-copy-bcc">密件副本 Blind Carbon Copy (Bcc)&lt;/h3>
&lt;ul>
&lt;li>把你的信件複製一份給別人做參考&lt;/li>
&lt;li>被 Bcc 的人不會被看見&lt;/li>
&lt;/ul>
&lt;h2 id="為什麼要用-bcc">為什麼要用 Bcc&lt;/h2>
&lt;ul>
&lt;li>收件者彼此之間會看到其他人的 email（甚至是名字）&lt;/li>
&lt;li>隱私問題！&lt;/li>
&lt;li>&lt;a href="https://www.ptt.cc/bbs/LoL/M.1536386502.A.636.html">[閒聊] Reddit 熱議: NA LCS 通知出包&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="什麼時候該用-bcc">什麼時候該用 Bcc&lt;/h3>
&lt;ul>
&lt;li>收件者有一堆人&lt;/li>
&lt;li>收件者彼此不認識&lt;/li>
&lt;/ul>
&lt;h3 id="什麼時候不該用-bcc">什麼時候不該用 Bcc&lt;/h3>
&lt;ul>
&lt;li>工作小組討論問題&lt;/li>
&lt;/ul>
&lt;h2 id="怎麼用-bcc">怎麼用 Bcc&lt;/h2>
&lt;ul>
&lt;li>收件者/Cc/Bcc 會有三欄不同的名單&lt;/li>
&lt;li>以 Mac 的郵件為例：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.imgur.com/j6JSo7b.jpg" alt="">&lt;/p>
&lt;h2 id="延伸閱讀">延伸閱讀&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://lastparadise.pixnet.net/blog/post/24727859-bcc-%E6%98%AF%E4%B8%80%E7%A8%AE%E5%9F%BA%E6%9C%AC%E7%A6%AE%E8%B2%8C">BCC 是一種基本禮貌&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bnext.com.tw/ext_rss/view/id/651536">解讀 Google 執行董事長 Eric Schmidt 的 9 條 Email 規則&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ptt.cc/man/NTUHistory89/D7B4/DA50/D7AF/M.981269465.A.html">養成 Email 寄信好習慣，確保隱私資料不外流&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://cc.nchu.edu.tw/content/docs/%E5%AF%86%E4%BB%B6%E5%89%AF%E6%9C%AC%E7%B0%A1%E4%BB%8B%E8%88%87%E4%BD%BF%E7%94%A8">中興大學 密件副本簡介與使用&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>為什麼會有這個網站</title><link>https://dwye.dev/post/first-post/</link><pubDate>Thu, 10 Jan 2019 14:34:33 +0800</pubDate><guid>https://dwye.dev/post/first-post/</guid><description>
&lt;p>不管是下面哪一個待辦事項，都不是突發奇想，而是一直想嘗試的事情：&lt;/p>
&lt;ul>
&lt;li>架一個個人網站&lt;/li>
&lt;li>寫 blog&lt;/li>
&lt;/ul>
&lt;h2 id="在這個網站之前我還擁有過的個人頁面有">在這個網站之前，我還擁有過的個人頁面有：&lt;/h2>
&lt;h3 id="msn-社群">MSN 社群&lt;/h3>
&lt;p>第一次有個人頁面，是在小學時候的 MSN 社群，當時為了發布 LF2 （小朋友齊打交二）的改檔而申請的，但是後來 MSN 關了之後就沒有然後了，改檔備份也消失。&lt;/p>
&lt;h3 id="無名小站">無名小站&lt;/h3>
&lt;p>國三因為看大家寫無名小站很好玩（剛好那時候蔚為風潮），所以就跟著創了，但這時候就是屁孩文為主。用現代人的觀點來看，無名小站就是當時學生的 FB。&lt;/p>
&lt;h3 id="痞客邦-pixnethttpra21844pixnetnetblog">&lt;a href="http://ra21844.pixnet.net/blog">痞客邦 PIXNET&lt;/a>&lt;/h3>
&lt;p>第一個比較正式的 blog，大學時候創的，主要是放跟家教有關的東西，每次丟家教的履歷的時候都會附上網址，目前感覺效果是不錯。那時候接家教接的很有心得，目前搬過來的文章的主要來源也都是那裡。&lt;/p>
&lt;p>不過大四忙起來之後就比較少經營。&lt;/p>
&lt;h3 id="blogger">Blogger&lt;/h3>
&lt;p>上面的無名小站倒掉之後，個人 blog 就投靠了 &lt;del>Google&lt;/del> Blogger，畢竟現在是 Google 旗下產品之一，感覺比較不會倒。不過因為充滿了中學時期的黑歷史，目前關起來了。&lt;/p>
&lt;p>另外我也有匿名經營一個歌詞翻譯 blog，但是也很久沒更新了XD。&lt;/p>
&lt;h2 id="所以關於本站">所以關於本站&lt;/h2>
&lt;p>因為&lt;del>誤入&lt;/del>理論化學組，這幾年把 coding 能力撿回來之外還提升了不少（離 pro 還很遠就是）。此外，在當研究助理的時期也幫實驗室維護網站（雖然更新頻率不太高），我們實驗室的網站是用 WordPress 架在機房裡面的，當時就有種「想要以後也自己來架個站」的想法。&lt;/p>
&lt;p>原本的痞客邦網站，因為寫了一些家教的東西，雖然頻率很低但是偶爾還是會收到家長的留言問問題，我也因此接到家教過，所以 blog 要是經營的起來多少有些幫助的。&lt;/p>
&lt;p>於是決定把大四之後就斷掉的 blog 生涯延續下去並擴展，人要有 &lt;a href="http://www.oneokrock.com/jp/music/1703">Ambitions&lt;/a>！！&lt;/p>
&lt;h3 id="架在哪">架在哪&lt;/h3>
&lt;p>網站雖然是放在雲端，但是跟天空中的雲不一樣，還是要有個本體的。如果是公家單位或是公司有個不斷電的機器，那就直接放在那裡就好了，但是一般人很難啊，不管是硬體電費網路費啥的都是一筆支出，所以現在有不少的免費和付費平台給大家架站。雖然很想列個 list，不過感覺列出來就會有「其實還有XXXX喔？」「XXXX其實不是」之類的發言（因為我沒有一個一個試過所以，怕.jpg），加上其實是很好 Google 的資訊&amp;hellip;。&lt;/p>
&lt;p>剛好有 &lt;del>Microsoft&lt;/del> GitHub，也有認識的人架在 GitHub 上，就直接選定了 GitHub Page。&lt;/p>
&lt;h3 id="框架">框架&lt;/h3>
&lt;p>其實這年頭架站也沒那麼困難的，有很多 framework 可以幫你省下很多事，也有直接 deploy 就有後台 UI 可以登入管理的。&lt;br>
我看到的 blog 框架有：&lt;/p>
&lt;ul>
&lt;li>hexo 聽說是台灣產&lt;/li>
&lt;li>hugo&lt;/li>
&lt;li>jekyll&lt;/li>
&lt;li>Octopress&lt;/li>
&lt;li>Wordpress&lt;/li>
&lt;li>Ghost&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>最後我是選了 hugo 當作我的框架，去 GitHub 上面 initialize，改一下 config.toml，套用主題 Blackburn（一個日本人寫的主題，看得蠻順眼的），clone 上去網站就這樣蹦出來了。&lt;/p>
&lt;p>&lt;del>生在二十一世紀&lt;/del>真好。&lt;/p>
&lt;h3 id="自動化發布">自動化發布&lt;/h3>
&lt;p>GitHub 支援 jekyll 直接在一個專案庫部署，不過因為我是用 hugo，你把 data clone 上去，就還是原始碼。這時，常見的招式是開兩個 git 專案，然後只 clone 產生的 html 們。不過這樣蠻累的，如果原始碼也用 git 管理，那每次更變你都要 git commit 兩次，很麻煩，而且還有可能會有不同步的問題，如果你沒管理好的話。&lt;/p>
&lt;p>這個時候就是 Google 大神派上用場的時候啦。&lt;/p>
&lt;p>&lt;del>Oracle&lt;/del> Wercker 是一個荷蘭出產的自動化測試與部署專案的工具，以我這種背景的人是第一次聽到，但看完大概的介紹後，感覺這東西就是：很酷，很屌，很方便，所以就用了。&lt;/p>
&lt;p>自從用了 Wercker 之後，&lt;del>考試都考一百分&lt;/del>，我只要把原始碼推上 GitHub，Wercker 就會發現你的 code 更新了，自動幫你 build 和 push 到放 html 們的專案庫，這樣我就只需要管理一個專案庫就好，另外一個就自動化處理了。&lt;/p>
&lt;h3 id="小結">小結&lt;/h3>
&lt;p>從 Hugo 裝完，到我寫了這篇文章，其實也才第三天，所以，架站真的沒那麼難（只是會偶爾鬼打牆）。&lt;/p>
&lt;p>目前這個網站大概就是：&lt;/p>
&lt;ul>
&lt;li>我的電腦裡面有個本地備份&lt;/li>
&lt;li>VSCode 寫文章（in Markdown），&lt;del>VSCode 大法好&lt;/del>&lt;/li>
&lt;li>本地確認看看沒毛病之後，推上去 GitHub&lt;/li>
&lt;/ul>
&lt;p>當然我也手很癢改了一些東西，像是：&lt;/p>
&lt;ul>
&lt;li>字體&lt;/li>
&lt;li>側邊欄 icon，素材跟原本的 theme 一樣是從 &lt;a href="//fontawesome.com/">fontawesome&lt;/a> 來的&lt;/li>
&lt;li>加了幾個頁面&lt;/li>
&lt;li>改了一下 index.html 的模板讓首頁看得到 about&lt;/li>
&lt;li>我可以插入 $\mathrm{\LaTeX}$ 欸（用了 &lt;a href="//www.mathjax.org">MathJax&lt;/a>）&lt;/li>
&lt;/ul>
&lt;h2 id="這個網站之後的發展">這個網站之後的發展&lt;/h2>
&lt;p>雖然網站好像架好了，&lt;del>但是俗話說，「The end is the beginning」&lt;/del>，其實很多事情都是剛開始。原本的文章大部分都是家教向，不過就像上面說的，這幾年開始碰了不少 coding，也想跟著前輩大神們寫些技術性一點的東西，這也是之後更新的方向之一。另外也希望能把自己聽音樂的興趣發揚一下，不用到像 &lt;a href="https://twitter.com/kazbomyi">KAZBOM&lt;/a> 那麼厲害，但是寫寫字我應該還是做得到&lt;del>吧&lt;/del>。&lt;/p>
&lt;p>雖然有點大方向，但是其實網站的走向也是很隨性的，&lt;strong>我的人生哲學，就是走一步算一步&lt;/strong>。&lt;/p>
&lt;h3 id="待辦">待辦&lt;/h3>
&lt;ul>
&lt;li>寫文章，更多文章&lt;/li>
&lt;li>中英文語言切換&lt;/li>
&lt;li>去充實人生這樣才能充實這裡（無誤&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>回到過去殺了希特勒，那世界會變成怎樣？</title><link>https://dwye.dev/post/kill-hitler/</link><pubDate>Tue, 02 Jan 2018 00:48:45 +0800</pubDate><guid>https://dwye.dev/post/kill-hitler/</guid><description>
&lt;p>寫在最開頭，這只是一篇很歪的廢文。&lt;/p>
&lt;h3 id="正文">正文&lt;/h3>
&lt;p>這個命題其實不是沒有人問過，也不是沒有人給過一個像樣的答案。有人說，歷史是會修正自己的，如果今天殺掉一個希特勒，那麼一定會有一個類似的人出來取代他，可能德國的法西斯政黨換了名字，卻還是發生了二戰。&lt;/p>
&lt;p>所以如果有人跟我說，要是日本沒有引發珍珠港事件，或是希特勒的部隊沒有在史達林格勒被包圍，甚至什麼中華民國打贏了三大會戰之類的，我都覺得只是會有另外的類似事件，讓歷史往原本的方向去進行。推動歷史的永遠不是一個人、也不是一個事件，而是那個人和那件事件後面的潮流，以及全體人類。&lt;/p>
&lt;p>是的，這個題目就是遊戲『終極動員令：紅色警戒』的劇情：&lt;br>
愛因斯坦發明了時光機，抱著拯救全體人類的心情，回到1924年的慕尼黑，抹殺了剛出獄的希特勒。從遊戲名字就可以猜想之後發生了什麼事了，冷戰時期最能代表紅色的事物不言而喻。&lt;/p>
&lt;p>當初第一次學到二戰附近的歷史覺得很有趣，就像玩過信長的人會知道服部半藏跟本多忠勝一樣，我對近現代歷史的基本認知，就是美國總統杜根，帶領歐洲的同盟國夥伴：英、法、德三國打敗沙皇後代洛馬諾夫引發的蘇聯侵略——這是紅色警戒 2 代的劇情XD，我當然知道這場戰爭沒有發生，後來 1990 年柏林圍牆倒塌，1991 年蘇聯解體獨立國協成立，國小老師叫我背過，所以我還知道這些事，但是對於第一二次世界大戰到底是誰打誰我還真的沒什麼頭緒，只知道美國和同盟國是好人，蘇聯是壞人，而創立蘇聯的史達林是壞人中的壞人。&lt;/p>
&lt;p>所以當我知道其實二戰是我以前認知的同盟國裡面的一國所引起的時候，就覺得充滿衝擊感，就像從小被認為是奢侈品的象徵 iPhone 一樣，原本以為是神到不能再神的劃時代高科技，結果長大之後好不容易有錢換了一隻 iPhone，才發現他連基本的中文輸入法都做不好&amp;hellip;&amp;hellip;離題了。&lt;/p>
&lt;p>更讓人驚訝的是這段歷史真就像在打遊戲破關一樣，玩家選擇德軍，訓練關卡是把部隊開進奧地利，然後第一關是佔領捷克，第二關北上丹麥，第三關確保挪威補給線，第四關華沙攻略，然後荷蘭比利時盧森堡法國，媽的真的跟打遊戲一樣，你說打就真的打下來，怎麼可能真這麼順利？於是就一路進行到海獅作戰、巴巴羅薩行動，最後一關是在華盛頓丟一顆核彈，然後就接上《高堡奇人》（The Man in the High Castle）的世界觀了（誤）。&lt;/p>
&lt;p>史實上是當初被我認為的大壞蛋史達林，和新學到的壞蛋希特勒，兩個人互打起來了。這下有趣了，一般來說看故事都是壞人打好人，好人合作變強反擊一波幹掉壞人，結果現實世界居然有這種壞人互打的劇情。結果兩個獨裁政權互咬互傷，鷸蚌相爭英美得利，才接上我們現代所生存的國際世界。&lt;/p>
&lt;p>而且另外一個史實是，海森堡的團隊沒能夠為德國開發出核彈，反而是被希特勒趕跑的愛因斯坦的團隊先造出來。這件事情成為後來歷史的疑雲之一：海森堡到底是開發不出來？還是就如某些辯護者所說的：他能夠但他蓄意避免了。畢竟如果發狂的希特勒拿到核彈，一定是二話不說先往一個人口多的地方丟下去報復對方——結果反而是終結戰爭的好人方美國做了同樣的事，用核彈把兩個日本大城鎮變成了灰燼。&lt;/p>
&lt;p>這邊也有一個有趣的事：量子力學的創始者掌控不了相對論，相對論的提出者也無法理解量子力學。哥本哈根詮釋用機率論解釋波函數平方的物理意義，愛因斯坦卻質問：上帝怎麼可能丟骰子？他的後繼者霍金回答了：上帝不止丟骰子，還為了搞混我們兒把它扔到你看不見的地方&amp;hellip;&amp;hellip;又離題了。&lt;/p>
&lt;p>當然好人壞人這種東西都是大眾去定義的，而這樣的定義也可以因為每個人的認知而不同，如果沒有凡爾賽會議的割地賠款以及不平等要求，我覺得反而比消滅希特勒更能夠阻止二戰發生。但是前面才說過，凡爾賽會議之所以會這樣規劃，也不是當時座位上的幾個人決定的，當時世界的認知就是那樣，打贏了就是有錢有地有資源，打輸了就下去等著被瓜分。就像打贏二戰的美國，丟了兩顆核彈都能說成是阻止更多人員傷亡，好像砸下去時城市裡面無辜的老人小孩都不是人一樣，還能開心地當他的世界警察。&lt;/p>
&lt;p>紅色警戒告訴我們，即使少了希特勒，史達林還活得好好的，而且被抽去平衡的架空世界，反而更加殘酷。但我覺得，一定會有一個曾經追隨希特勒的人，會取代他的位置，這個人，可能是海德里希，也可能是戈培林或是希姆萊。也許這個新的納粹領袖會是個更聰明的人，少了些領袖魅力，卻多了平穩的思緒，這樣的人反而比一個單純靠勇氣與魄力在打仗的戰爭瘋子還可怕。&lt;/p>
&lt;p>結論就是，還是趕快去充實自己的人生吧，改變世界太難，改變自己比起來容易太多了，一個粒子的系統可以有可逆性，熱力學卻告訴我們不要跟時間的後盾：熵 (entropy) 去做對抗。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>剛結束當兵前最後一場家教</title><link>https://dwye.dev/post/%E5%89%9B%E7%B5%90%E6%9D%9F%E7%95%B6%E5%85%B5%E5%89%8D%E6%9C%80%E5%BE%8C%E4%B8%80%E5%A0%B4%E5%AE%B6%E6%95%99/</link><pubDate>Tue, 27 Sep 2016 00:36:06 +0800</pubDate><guid>https://dwye.dev/post/%E5%89%9B%E7%B5%90%E6%9D%9F%E7%95%B6%E5%85%B5%E5%89%8D%E6%9C%80%E5%BE%8C%E4%B8%80%E5%A0%B4%E5%AE%B6%E6%95%99/</guid><description>
&lt;p>剛結束當兵前最後一場家教，所以想打點心得，不知道以後還有沒有機會做這份行業，總之一切的開始都是緣份。&lt;/p>
&lt;p>剛上大學總是有很多野心，當時有個願望，就是希望能夠早日經濟獨立，所以第一件事情就是跟家裡要來存摺，自己的錢自己管，然後建立零用錢制，所以有了基本收入。再來就是如何賺錢了。&lt;/p>
&lt;p>除了因為台大學生很多都是用家教當打工，就我自己而言，其實高中平時成績也不是特別好，教高中物理這種事情原本應該是想都想不到的，除了高三上成績不知道為什麼破格的高，不過到高三下又跌回班上十幾名。後來因為不幸要指考，只好把物理乖乖補起來，才發現其實高中物理對我來說還蠻簡單的，當時有自己準備一份公式筆記，以後搞不好有機會拿來幫別人解決物理問題。&lt;/p>
&lt;p>原本只是在 SNS 上半開玩笑性質的幾句話，後來就真的認真的家教起來了。後來因為朋友D先生在補習班工作，也把我拉了過去，慢慢累積實力，加上剛開始每次家教都會花很多小時備課，也就熟能生巧了起來，開始想透過其他平台來找家教。過程當然有順利也有不順利，也有好幾個人是教了半學期一學期就不見人影，畢竟這行業競爭對手真的很多，除了同行、補習班，甚至是學校老師、以及學生自己。如果學生不小心找到了讀書的訣竅，家教老師也就失業了，雖然這是我覺得最好的失業方式，比因為成績沒進步而失業好太多XD。&lt;/p>
&lt;p>一份家教的結束，除了被補習班搶走或被fire，也有可能是學生考完試畢業惹，這種方式結束的還是最多的，而且佔了大部分比例，所以也是值得欣慰的事情吧。不過結束之後又是另一回事，其實還有在聯絡的比例真的很少，搞不好兩年前的學生走在路上我還不會第一時間認出呢。我覺得這種私人性質的工作除了賺錢之外也有交朋友的性質在，在還沒出社會的時候認識越多人也不是一件壞事，只是希望能留下的都是好印象。畢竟身為邊緣人以前實在累積太少朋友了，透過打工來認識人也是一種彌補的管道～以後在社會上有機會的話也能互相幫助。&lt;/p>
&lt;p>這邊突然很想講兩件事情。&lt;/p>
&lt;p>第一件事情就是，如果教的是女生學生，通常跟別人講的時候，對方就會露出一臉你在虧妹子的表情，也有人會嘴叫我把握機會。不過說真的，還真的不會想要ww，不只會覺得怪，多重身份疊上去處理起來真的蠻麻煩的，是那種光是用腦袋想就覺得麻煩，就現實面來講就不會想要，反正機會別的地方也有，不差這一點點。那如果說教女生會不會比教男生爽，可是我覺得平常跟男生朋友嘴炮也很爽，所以如果跟男生的學生很有話聊又很主動學習，其實教起來也蠻開心的，如果女生是不太會自己唸書又不太講話的，教起來也不會說多輕鬆，而且你還要比他積極比他有希望有笑容，心裡面其實蠻累的。&lt;/p>
&lt;p>然後還有關於收錢的部分。雖然一開始只是想賺錢，但後來又覺得好像有賺到錢就好，不用賺那麼多沒關係，畢竟也是自己喜歡的工作，就是不要空虛的度過就好。而且慢慢會意識到自己的責任感，是比賺到多少錢還重要，如果只有拿錢但是學生沒有什麼進步甚至還退步，其實也會良心不安。&lt;/p>
&lt;p>有些時候也會覺得，成績不是一切，其實排名差不多的大學不會差在那幾所之間，重要的是把未來可能用到的主要觀念學好，分數夠了就好不用求很高，可是常常都是家長和學生比我還在意這些，而且由一個台大的人來講這些實在沒什麼說服力XD。&lt;/p>
&lt;p>我覺得每次的相遇都是一次緣份，人生要不要往上爬也是自己的選擇，但是在世間遊走體驗就足夠是一種人生的意義了，大概就是這樣吧。謝謝所以曾經在這方面照顧過我或被我照顧的人。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>Aimer 11th 單曲「蝶々結び」（和 RADWIMPS 主唱合作）日中歌詞</title><link>https://dwye.dev/post/aimer-radwimps-single/</link><pubDate>Sat, 16 Jul 2016 16:33:56 +0800</pubDate><guid>https://dwye.dev/post/aimer-radwimps-single/</guid><description>
&lt;p>實在是很喜歡的一首歌&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/Du_5wIB26-M" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>旋律和歌詞都有 RADWIMPS 的感覺在&lt;br>
值得細細欣賞&lt;/p>
&lt;p>雖然只有試聽版，但是就姑且把現在有的歌詞翻譯一下&lt;br>
更能體驗歌詞那種唱到心裡的感動&lt;/p>
&lt;hr>
&lt;h3 id="蝶々結び">蝶々結び&lt;/h3>
&lt;p>詞曲：野田洋次郎 from RADWIMPS&lt;/p>
&lt;p>&lt;br>
片っぽで丸を作って　しっかり持ってて&lt;br>
一隻手繞出一個圈，確實地抓著&lt;/p>
&lt;p>もう片っぽでその丸の後ろを　ぐるっと回って&lt;br>
再用另一隻手從那個圓圈的後方繞過&lt;/p>
&lt;p>間にできたポッケに入って　出て来るの待ってて&lt;br>
完成之後的空隙等待著另一邊也穿出來&lt;/p>
&lt;p>出てきたところを迎えにきて　「せーの」で引っぱって&lt;br>
在另一邊穿出來之時，「1 2 3 !」地拉直&lt;/p>
&lt;p>&lt;br>
はじめはなんとも　情けない形だとしても&lt;br>
雖然一開始只能做出這樣不好看的形狀&lt;/p>
&lt;p>同じだけ力を込めて&lt;br>
但也同樣是投入了力量&lt;/p>
&lt;p>&lt;br>
羽根は大きく　結び目は固く&lt;br>
為了成就大大的翅膀、堅固的繩結&lt;/p>
&lt;p>なるようにきつく　結んでいてほしいの&lt;br>
所以希望能不留空隙地把結繫上&lt;/p>
&lt;p>腕はここに　思い出は遠くに&lt;br>
把雙手放在這裡，讓思念遠去&lt;/p>
&lt;p>置いといてほしい　ほしいの&lt;br>
希望能夠這樣一直維持下去&lt;/p>
&lt;p>&lt;br>
片っぽでも引っ張ちゃえば　ほどけちゃうけど&lt;br>
雖然只要單手一拉就能解開&lt;/p>
&lt;p>作ったもの壊すのは　遥かに簡単だけど&lt;br>
雖然要破壞做好的東西是如此簡單&lt;/p>
&lt;p>だけどほどく時も　そう、ちゃんと　同じようにね&lt;br>
但是在解開的同時也正是一樣地需要力量&lt;/p>
&lt;p>分かってるよ　でもできたらね　「せーの」で引っ張って&lt;br>
我知道呀，但因為做得到呀，所以「1 2 3 !」地把繩結拉開&lt;/p>
&lt;p>&lt;br>
ほどけやしないように　と願って力込めては&lt;br>
不想要被解開，所以注入更多力量&lt;/p>
&lt;p>広げすぎた羽根に　戸惑う&lt;br>
看到太過張開的翅膀卻又不知所措&lt;/p>
&lt;p>&lt;br>
羽根は大きく　結び目は固く&lt;br>
為了成就大大的翅膀、堅固的繩結&lt;/p>
&lt;p>なるようにきつく　結んでいてほしいの&lt;br>
所以希望能不留空隙地把結繫上&lt;/p>
&lt;p>夢はここに　思い出は遠くに&lt;br>
把夢想留在這裡，讓思念遠去&lt;/p>
&lt;p>気づけばそこにあるくらいがいい&lt;br>
差不多能夠察覺到的程度就夠了&lt;/p>
&lt;p>&lt;br>
黙って引っ張ったりしないでよ&lt;br>
不要不說話地拉直繩結&lt;/p>
&lt;p>不格好な蝶にしないでよ&lt;br>
不要打出不成形的蝴蝶結&lt;/p>
&lt;p>結んだつもりがほどいていたり&lt;br>
想著要打結的時候卻不小心解開了&lt;/p>
&lt;p>緩めたつもりが締めていたり&lt;br>
想著要鬆開的時候卻又繫得更緊&lt;/p>
&lt;p>&lt;br>
この蒼くて広い世界に　無数に散らばった中から&lt;br>
我們從這蒼藍又廣闊的世界裡，從這寥落無數的散落當中&lt;/p>
&lt;p>別々に二人選んだ糸を　お互いたぐり寄せ合ったんだ&lt;br>
各自選到了同一條線，而拉近了彼此的距離&lt;/p>
&lt;p>&lt;br>
結ばれたんじゃなく結んだんだ&lt;br>
繩結不是被強迫繫上的，而是彼此主動繫上的&lt;/p>
&lt;p>二人で 「せーの」　で引っ張ったんだ&lt;br>
是兩人一起「1 2 3 !」地拉緊的&lt;/p>
&lt;p>大きくも　小さくも　なりすぎないように&lt;br>
不管是大是小、是否成形&lt;/p>
&lt;p>力を込めたんだ&lt;br>
都是我們全心全力投入的成果&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>談日本搖滾樂團 ONE OK ROCK 的興起</title><link>https://dwye.dev/post/one-ok-rock/</link><pubDate>Wed, 20 Apr 2016 00:18:03 +0800</pubDate><guid>https://dwye.dev/post/one-ok-rock/</guid><description>
&lt;p>這篇是我在通識課「日本文化史」的期中報告。&lt;/p>
&lt;hr>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>首先於第二部分我會先簡單介紹關於 ONE OK ROCK (以下簡稱ワンオク)的一些基本資訊，接著於第三部分將我認為他們的特色分項討論，最後第四部分會簡述ワンオク對我的影響以及選ワンオク當作主題的理由，並於第五部分做總結。&lt;/p>
&lt;h2 id="二樂團簡介">二、樂團簡介&lt;/h2>
&lt;p>ワンオク目前是一個四人樂團，於 2006 年成立，已有十年歷史，團員為主唱 Taka，吉 他手 Toru，Bass 手 Ryota 以及鼓手 Tomoya，目前發有七張正規專輯以及九張單曲。團名的由來是因為日本的「L」和「R」發音相同，從他們以前學生時代的練團時間半夜的「one o’clock」音轉而來，兼具他們搖滾為本位風格的意思。光是從半夜一點也要練習，就可以看出他們對音樂的熱忱。&lt;/p>
&lt;p>ワンオク的樂團路並非一路順遂，曾經因為主吉他手 Alex 捲入性騷擾事件被逮捕，而導致樂團活動被迫中止，一瞬間演唱會、電視節目主題曲、待發行單曲什麼的全部都沒了，可以說是樂團歷史的谷底。然而團員憑著不能半途而廢的精神，以及對音樂的熱忱，就算少一個人也要走下去。他們發行了《完全感覚 Dreamer》單曲後再度一炮走紅，這首歌對他們的意義重大，是直到現在 6 年後這首歌都是 live 一定會表演的最後一首歌。&lt;/p>
&lt;p>樂團風格一開始充滿了反骨、叛逆的龐克風，可以從《Keep it real》中「くだらない前評判と大人達の世間体」別去在意那些成人的現實觀與批評、《内秘心書》中「ツメを伸ばしたウソ書き人，こんな時代だから」對世界的不滿，以及《カラス》中「泣いてるか笑ってるか，ソレすら誰にも分かりはしない」的無奈怨恨看出。後來也漸漸出現一些正向的歌，如《キミシダイ列車》中「過去の自分が今僕の土台となる」的激勵，以及紀念日本 311 大地震的《Be the light》中「Tomorrow’s night returns to light」的正向呼喊。也有正面的告白情歌《Wherever you are》的「Wherever you are, I’ll always make you smile」之類。風格逐漸多樣化，但最重要的搖滾核心，仍是他們的主要路線。&lt;/p>
&lt;p>近年來ワンオク積極走向國際化，靠著為「神劍闖江湖」電影三部曲譜寫主題曲，並大量增加英文歌詞使用量以及大量的海外巡迴來腳踏實地推廣知名度，並加盟國際音樂公司華納兄弟音樂，發行全球版專輯，走向世界。&lt;/p>
&lt;h2 id="三特色分析">三、特色分析&lt;/h2>
&lt;h3 id="積極追求國際化">積極追求國際化&lt;/h3>
&lt;p>因為日本注重著作權，有的甚至連 MV 都只放片段到 Youtube，想看完整版必須買單曲或專輯，這方面和其他國家完全不同。為了避免海外盜版，不少音樂甚至會封鎖海外 ip，想 要看他們的影片必須要使用 VPN 跳板到日本。然而ワンオク在這方面卻完全與之相反，他們和歐美樂團一樣，上傳大量 MV 和 live 表演影片來進行網路宣傳，在海外表演也尊重當地錄音錄影文化，和日本國內對版權的一板一眼不同。&lt;/p>
&lt;p>除此之外，從第一張專輯時，他們就採用了英日歌詞混合的創作模式，到後來更變本加厲，英文歌詞比重越來越重，也有好幾首歌只有英文歌詞，如《Reflection》、《Never Let This Go》&amp;hellip; 等。主唱 Taka 有著想強烈走向世界的夢想，也所以近年和美國公司簽約，發行全英文版本專輯《35xxxv Deluxe Edition》，甚至發生過將原本寫好的日文歌詞砍掉用英文重寫，就為了將自己的音樂讓更多人理解。&lt;/p>
&lt;h3 id="簡單卻直白的歌詞">簡單卻直白的歌詞&lt;/h3>
&lt;p>ワンオク的歌詞不走文謅謅的路線，像是《エトセトラ》中「分かってるんだ，戻んないのは，でもでも&amp;hellip;」這樣如同說話一般的歌詞，彷彿真的是失戀時的自言自語。又或是《Deeper Deeper》中直接點出「いつだって人は迷うんだって」，直白的歌詞卻能夠引人共鳴，連非日本母語的人只要學過一點點日文就可以理解歌詞，或是英文不好的人也可以簡單理解他們英文部分的歌詞，這也是我認為他們能把自己推向世界的原因之一。&lt;/p>
&lt;h3 id="抒情和搖滾都能入味">抒情和搖滾都能入味&lt;/h3>
&lt;p>如同第二段說到，ワンオク嘗試過各種不同的風格，從一開始的龐克、還有 rap 到後來加入一些電子元素。當我同學興致盎然的對我推薦ワンオク的時候，他說了他喜歡他們的理由就是「不管是抒情或搖滾都能寫得很好」。例如說在台灣的 KKBOX 日文歌排行榜，抒情歌《Wherever you are》一直都佔領著前三名的位置。同時身為搖滾樂團的他們，如同《No Scared》般的嘶吼，《The Beginning》的堅定，《Liar》的憤怒，主唱 Taka 強大的音域與爆發能力以及辨認度十足的嗓音，是目前樂團界中少有的，不需要依靠金屬腔也能讓人感到十分的爆發力。Tomoya 的強大鼓功，多變華麗而聽起來過癮的打法，也為樂團的搖滾加了不少分數。&lt;/p>
&lt;h3 id="強大的演唱會現場實力以及渲染力">強大的演唱會現場實力以及渲染力&lt;/h3>
&lt;p>我認為ワンオク最強大的地方，莫過於他們現場表演的實力以及渲染力。搖滾樂團不能只是錄音室歌手，不能像韓國團體一樣彈空氣吉他，自己寫出來的歌，在現場表演時不能感冒唱不上去，鼓手吉他手不能跟不上搖滾的快速節拍。除此之外，現場更要擁有足夠的體力跳跳唱唱，陪歌迷搖滾將近三個小時，年輕充滿活力的ワンオク正把現場發揮得淋漓盡致，不少國外網友都對於主唱 Taka 邊跳還能邊爆發高音的實力感到佩服而一聽成主顧。他們也善用他們的現場實力，不常上節目，反而時時都在巡迴表演，直接用現場表演拉攏更多歌迷。&lt;/p>
&lt;h2 id="四one-ok-rock-與我">四、ONE OK ROCK 與我&lt;/h2>
&lt;p>之所以選擇ワンオク當作主題，因為他們是我對於國外音樂的啟蒙團，讓我打開音樂的視野，接觸流行音樂以外的音樂。後來也因此慢慢能接受不同種類的音樂風格，知道有流行音樂以外的世界，也知道除了主唱之外，樂器的靈魂也是很重要的。因此慢慢聽了以前認為不知道在唱什麼的閃靈樂團，能夠關注地下認真彈奏每個音符的獨立音樂圈，連結到歐美日各國厲害的搖滾樂團，開始思考每個樂團的主軸以及他們想要傳達給世界什麼。&lt;/p>
&lt;p>ワンオク的很多首歌陪我走過了人生的各個感動時刻，在此不多贅述，而我也會購買正版專輯對音樂做最好的支持，並參加台灣粉絲專頁的應援活動以及在 PTT 上參與討論，也參與維基百科的條目編寫，讓好奇他們的人能夠得到更多關於他們的訊息。&lt;/p>
&lt;h2 id="五結語">五、結語&lt;/h2>
&lt;p>ワンオク是目前在日本國內外都有一定知名度的樂團，但是在日本國內仍然與一些流行天團差得遠，也許搖滾音樂的愛好者本來就不是佔多數吧？然而他們在國外的知名度，絕對是目前日本樂團首屈一指的。以台灣來說，他們是目前唯一一組在台北小巨蛋開過演唱會的日本樂團，而且還一開就是兩天。&lt;/p>
&lt;p>ワンオク是個搖滾樂團，而且是喜歡嘗試多變曲風的搖滾樂團，Taka 曾在訪談說，雖然說想要有更多歌迷，但他們不會擔心風格的轉變造成歌迷流失，因為他們想要傳達的思想就是「做自己就對了，然後把自己的這樣子傳達給更多人」，不管是透過搖滾的宣洩也好，透過激勵的旋律也好，希望能夠帶給世界正面的力量。ワンオク才剛正式邁向全球音樂圈，下一張專輯將往什麼風格發展，未來都還尚未明朗，但也希望他們能夠不忘初衷，繼續向歌迷傳達他們正向的搖滾音樂與思想。&lt;/p>
&lt;h2 id="六參考資料">六、參考資料&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="//zh.wikipedia.org/wiki/ONE_OK_ROCK">中文/英文/日文維基百科 ONE OK ROCK 以及相關條目&lt;/a>&lt;/li>
&lt;li>&lt;a href="//www.jame-world.com/uk/articles-4982-interview-with-one-ok-rock-in-tokyo.html">Interview with ONE OK ROCK in Tokyo&lt;/a>&lt;/li>
&lt;li>&lt;a href="//www.kkbox.com/tw/tc/column/interviews-46-763-1.html">ONE OK ROCK的決意:「目標世界第一!!」&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ptt.cc/bbs/ONE_OK_ROCK/M.1354658668.A.C7A.html">ROCKIN’ON JAPAN 2012 年 6 月號 TAKA 篇, PTT ONE_OK_ROCK 版&lt;/a>&lt;/li>
&lt;/ol></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>酸欠少女さユり「来世で会おう」日中歌詞</title><link>https://dwye.dev/post/sayuri-raise-dea-aou/</link><pubDate>Sat, 12 Mar 2016 16:33:56 +0800</pubDate><guid>https://dwye.dev/post/sayuri-raise-dea-aou/</guid><description>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/9LhUlEeeSF0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>&lt;br>
過去は変えられないさって&lt;br>
過去是不能被改變的&lt;/p>
&lt;p>何度言われても懲りないのね&lt;br>
無論被告知多少次都無法領悟&lt;/p>
&lt;p>再三再四　振り払えずに&lt;br>
一次又一次的無法甩開這些&lt;/p>
&lt;p>取り残されてく&lt;br>
我卻被拋棄在後方&lt;/p>
&lt;p>&lt;br>
もうそれ以上願ってるだけじゃ&lt;br>
現在只需要想著祈求更多&lt;/p>
&lt;p>もう一緒にいられないのでしょう&lt;br>
而已經不需要在一起了吧&lt;/p>
&lt;p>もう行かなくちゃ&lt;br>
已經不得不行動&lt;/p>
&lt;p>受け入れなくちゃ&lt;br>
必須去接受&lt;/p>
&lt;p>&lt;br>
来世で会おう　生まれ変わった時は&lt;br>
來世再相見吧，當我們轉世之後&lt;/p>
&lt;p>二人きっと違う未来が待ってる&lt;br>
一定會有不一樣的未來在等著我們&lt;/p>
&lt;p>来世で会おう　光を手繰り寄せて&lt;br>
來世再相見吧，緊緊抓住那道光&lt;/p>
&lt;p>必ずまた笑い合えるさ　信じて僕は今歩き出すよ&lt;br>
我們一定還會再笑著見面的，抱著這樣的信心我要開始向前邁進了&lt;/p>
&lt;p>&lt;br>
記憶にすがりつくように&lt;br>
就像是緊緊地依賴著記憶&lt;/p>
&lt;p>罰が下るのを待っていたように&lt;br>
也像是一直等待著懲罰&lt;/p>
&lt;p>僕が僕自身をこの部屋に　閉じ込めていた&lt;br>
我把我自己囚禁在這房間&lt;/p>
&lt;p>&lt;br>
冷たく体を覆っている氷は&lt;br>
冰冷的覆蓋在身上的冰&lt;/p>
&lt;p>自分以外には溶かせないってこと&lt;br>
只有我自己的力量是無法溶解的&lt;/p>
&lt;p>もう知ってるけど&lt;br>
明明已經知道了&amp;hellip;&lt;/p>
&lt;p>気づいてるけど&lt;br>
明明已經察覺了&amp;hellip;&lt;/p>
&lt;p>&lt;br>
夢を見るよ　選ばなかった日々の先で&lt;br>
我做了一個夢，是在那些沒有被我選擇的日子裡&lt;/p>
&lt;p>僕は幸せそうに笑ってて&lt;br>
我看起來開心地笑著&lt;/p>
&lt;p>それでも朝が来たら今日も歌うよ&lt;br>
就算如此，早晨到來時我今天也哼著歌&lt;/p>
&lt;p>すべて間違いじゃなかったと　思える春が来るように祈る&lt;br>
所有的事情都沒有弄錯，而我祈禱著春天的來到&lt;/p>
&lt;p>&lt;br>
許せるだろうか　そんな日が来るとしたなら&lt;br>
可以原諒我嗎？如果那樣的日子來臨的話&lt;/p>
&lt;p>君は待っててくれるだろうか　この痛みの先で&lt;br>
你會超越那些痛苦在那裡等著我的吧？&lt;/p>
&lt;p>&lt;br>
来世で会おう　指切りといた合図で&lt;br>
來世再相見吧，曾經答應過的隨著那暗號&lt;/p>
&lt;p>僕らそれぞれの場所へ向かってく&lt;br>
我們各自邁向我們各自的道路&lt;/p>
&lt;p>来世で会おう　だからもう振り向かないよ&lt;br>
來世再相見吧，所以不會再回頭了&lt;/p>
&lt;p>&lt;br>
来世で会おう　生まれ変わった時は&lt;br>
來世再相見吧，當我們轉世之後&lt;/p>
&lt;p>二人きっと違う未来が待ってる&lt;br>
一定會有不一樣的未來在等著我們&lt;/p>
&lt;p>来世で会おう　それまでどうかお元気で&lt;br>
來世再相見吧，在那之前請保重啊&lt;/p>
&lt;p>すべて間違いじゃなかったと　信じて僕は今歩き出すよ&lt;br>
所有的事情都沒有弄錯，抱著這樣的信心我要向前邁進了&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>[現場] 我們囚禁在格林威治的規則裡</title><link>https://dwye.dev/post/sodagreen/</link><pubDate>Tue, 15 Dec 2015 01:26:27 +0800</pubDate><guid>https://dwye.dev/post/sodagreen/</guid><description>
&lt;p>第一次的自己買票的小巨蛋，獻給蘇打綠。&lt;/p>
&lt;p>第一次的蘇打綠，獻給《故事未了》。&lt;/p>
&lt;h2 id="強盜就躲在城堡">強盜就躲在城堡&lt;/h2>
&lt;p>第一次認識打綠是高一時，音樂課大家要選一首歌來唱。一個日本名字的同學，跟我借手機播放音樂。&lt;/p>
&lt;p>他問我：「你有沒有聽過蘇打綠？」&lt;/p>
&lt;p>鄉下出身的我，除了從小跟著姊姊聽林俊傑周杰倫，因為畢業歌認識五月天之後，再也沒有聽過其他流行音樂。&lt;/p>
&lt;p>他說：「你怎麼可以沒聽過！很好聽欸，我多傳幾首給你！你回去慢慢聽！」&lt;/p>
&lt;p>正好我的日本同學很會唱歌，把這首當年的新歌裡所描述的不滿、反抗、指控等詮釋的很完美。在他的強力推廣下，從此之後我就因緣際會地迷上蘇打綠，慢慢自己找更多首歌來聽，《這天》、《近未來》、《小宇宙》、《相信》&amp;hellip;&amp;hellip;等歌陪我度過不少快樂、孤單、喜悅與失望。從《你在煩惱什麼》開始，每一張專輯都擺在我的書櫃上，與《蘇打誌》一起。&lt;/p>
&lt;p>第一場的蘇打綠演唱會，不知怎麼地成為很重要的人生目標之一，想要早點看到，卻又希望能一直把期待留著。&lt;/p>
&lt;p>原本因為手邊的票轉讓不出，差點就決定兩張一起賣掉，還好最後一刻找到了願意跟我換票的人，以及願意收購另一張票的人，讓我懷著複雜的心情（既期待又害怕過度期待XD），迎接人生第一場正式的蘇打綠。&lt;/p>
&lt;h2 id="人生一場大夢葉落知多少">人生一場大夢，葉落知多少&lt;/h2>
&lt;p>紫2E的座位比我想像來得近，小威的鼓在眼前佔了一定比例，突然覺得其實小巨蛋也不大嘛。開場的中央舞台升起，樂手、指揮、團員們相繼走出，讓我想起小時候的國樂表演，彷彿角色對調，而一場盛大正式的音樂會正要在此起彼落的掌聲中展開。&lt;/p>
&lt;p>老實說，聽朋友說小巨蛋的音場對古典音樂來說很不好，讓我一開始有點忐忑不安。當《故事》拉開了序幕，比原曲更加壯闊的伴奏群起奔馳，也許是我的耳朵還沒習慣，也或許是太專注空氣裡每個小雜音，除了青峰的歌聲較清晰外，回音與樂器互相干擾，實在聽不太清楚細節，比起主唱的旋律我更喜歡專注於音樂的細節安排，所以一開始有點小失望，直到&amp;hellip;&amp;hellip;&lt;/p>
&lt;h2 id="夏蟬猛把天地叫窄容不下過去未來">夏蟬猛把天地叫窄，容不下過去未來&lt;/h2>
&lt;p>前奏我還在猜是不是要翻唱誰的歌或演奏誰的作品，和弦越聽越耳熟，直到「某個夏天一座花園」就立刻認出了這首！！《蟬想》一直是我很喜歡的作品，詞意不說，單說轉調就讓人入迷，我在現場也聽得入迷了，上一首歌出現的擔心完全消失！果然還是要一心一意沈浸於音樂中才享受！說真的這首的出現讓我十分驚喜！&lt;/p>
&lt;h2 id="放開時間空間而存在">放開時間空間而存在&lt;/h2>
&lt;p>《融雪之前》，一首寧靜的歌，自我思想著哲理，配上流暢的木吉他，是我之前對這首歌的印象。配上交響樂團後，額外的優美。原本我是喜歡搖滾樂的，這次的表演中卻發現許多不太搖滾的慢歌都被詮釋的極佳，讓我有機會用新的角度欣賞它們。&lt;/p>
&lt;p>秋、夏、春，下首就是冬了吧！&lt;/p>
&lt;h2 id="只是要比誰病的輕">只是要比，誰病的輕&lt;/h2>
&lt;p>「《冬　未了》專輯開門見山，即帶來完整的樂團大合奏，所有的樂器全用上&amp;hellip;&amp;hellip;」，聽到開場的樂團大合奏，就讓我想起《蘇打誌》中的阿龔的這句話，這就是《痛快的哀艷》了吧！交響樂團開始展現他們的實力了，這首歌標誌著「冬」的饗宴真正開始了。附帶一提，在我位置正前方的小洋老師彈的好激動好入迷，好愛他哈哈，他扛了不少重要的電吉他旋律，是我覺得加的非常適當非常美的。&lt;/p>
&lt;h2 id="這曠古的最仇恨之歌">這曠古的最仇恨之歌&lt;/h2>
&lt;p>一首寫希特勒的歌，特別吸引著我。時間回到1945年，紅軍坦克輾過柏林廢墟，地下碉堡平靜而詭譎，元首出了碉堡就再也不是元首了。蘇打綠穿越時空的質問，元首或瘋狂、或沈默，最後還是做出一樣的選擇。祂按下了最後的開關，同時啟動了婚禮與喪禮，在小威的鼓聲與交響的奔騰中燃燒自我，寫下這曠古的最毀滅之歌，讓整個德意志與祂一同墮入深層地獄。&lt;/p>
&lt;p>（PS. 明天的軍訓報告正好要講第三帝國XD）&lt;/p>
&lt;h2 id="雖有陰晴-你的手卻透明而清晰">雖有陰晴 你的手卻透明而清晰&lt;/h2>
&lt;p>真的是照著專輯曲目來呀，不過也代表著原本的專輯曲序設計正好符合音樂會的情緒起伏！一首沈重的歌，接下來是《地平線》陪著我們，毀滅之後重現生機，不管怎麼樣日出都陪著我們！整首歌我最專注的是最後一次副歌「充滿了喜悅，口滿了稱謝」的鼓，很喜歡專輯中那段的混音，小威也沒有讓我失望打得很用力啊！（糟糕我怎麼一直在聽鼓）&lt;/p>
&lt;h2 id="曾經給你太多傷心過過後總會寬闊">曾經給你太多，傷心過，過後總會寬闊&lt;/h2>
&lt;p>居然能聽到四季以外的歌，讓我有點出乎意料哈哈。不過可惜這邊好像是讓交響樂休息，但是光是原本的版本就夠催人熱淚的。&lt;/p>
&lt;p>「請你張開雙手，讓我死在懷中。」即使逐漸忘了有多久，腦海中浮現著相同的面孔。&lt;/p>
&lt;p>在交往後，我的目標是想變得富有；分手之後，卻想要繼續升學單純地走學術的路。不同的心境有不同的野心，但不論是在一起還是離別都會改變一個人呢。第一次在分手之後好好聽這首歌，真的是聽完整首要偷偷拭一下眼淚。除了專注於歌詞中，看著青峰繞圓形舞台轉圈圈也是某種樂趣XD。&lt;/p>
&lt;p>抱歉打了點自己的事情。&lt;/p>
&lt;h2 id="藥水請蕭邦地擦謊言請李白地講">藥水請蕭邦地擦，謊言請李白地講&lt;/h2>
&lt;p>回到秋天了，這似乎是C大很喜歡的歌～有點傷心之後的療癒感。我一直在想蕭邦地擦是怎麼樣地擦，整個人就失焦了sorry XDDD&lt;/p>
&lt;p>Talking其實不怎麼出乎意料，我覺得C大一定會忍不住想講講話哈哈，簡單的問候同時問我們喜不喜歡，當然是超！喜！歡！！！接下來是我覺得最驚喜的part了！&lt;/p>
&lt;h2 id="於是你哭泣於是你孤寂停在那不能自己的一瞬間">於是你哭泣，於是你孤寂，停在那不能自己的一瞬間&lt;/h2>
&lt;p>天啊是第一張專輯第一首歌！！！我看了看周圍好像只有我和我旁邊的兩個女生聽過哈哈，原來我也是鐵粉啊知道打綠有發行的每一首歌！還是我在第一張專輯裡面很喜歡的一首！能夠聽到交響樂版嚇死人了！還好有來聽不然真的要《後悔莫及》啦！&lt;/p>
&lt;h2 id="你想找我想逃倒不如分道揚鑣">你想找、我想逃，倒不如分道揚鑣&lt;/h2>
&lt;p>這首歌居然叫大家動起來是想怎樣！害我在青峰開口才猜出是這首XDDD，這首歌算是我比較晚認識的一首，可是認識之後卻不知道為什麼很喜歡哈哈，大概是身邊也有甩也甩不掉的討厭鬼吧（噓，小聲點）。跟剛剛一樣我周圍只有幾個人知道這首，當然就不客氣地大聲唱啦～整場演唱會難得可以大方的活動筋骨！&lt;/p>
&lt;p>連指揮和樂團都開始手舞足蹈，現場一片歡樂真的蠻喜歡這種感覺的。&lt;/p>
&lt;h2 id="從繽紛到昨天凌晨蒸散夢才能永恆">從繽紛到昨天凌晨，蒸散夢才能永恆&lt;/h2>
&lt;p>冬專輯的最愛！！天啊從一首擺來擺去的歌接道一首有人自殺的歌，叫人怎麼冷靜下來啊！喜歡標題這句歌詞時青峰唱起來的流暢感，聽了幾百遍仍然著迷。第一次的電吉他間奏也很喜歡，還有專輯裡面混音很奇幻的bridge配上好聽的鼓，現場我都有特別注意聽這些點！打綠再次證明他們不是錄音室樂團！能夠把這首在現場表演得比專輯更出色！希望趕快出MV這樣才可以在FB洗版分享XDDD&lt;/p>
&lt;h2 id="不過是一尊藝術的門外漢">不過是一尊藝術的門外漢&lt;/h2>
&lt;p>安靜的一首歌，好像想著自己卻又說著誰，現場一樣意外地比專輯令人著迷。其實我比較喜歡樂團（鼓、Bass等）進來之後的部分。&lt;/p>
&lt;h2 id="那等不到的道歉交給風">那等不到的道歉，交給風&lt;/h2>
&lt;p>「邊界上人的思念」的現場版！在文明之下，令人反思的一種意境，而下首歌承接著，覺得真是絕妙的安排。青峰最後的連續幾聲拍子上的嘆息好迷人XD&lt;/p>
&lt;h2 id="這座城市一般享受著奢侈卻莫名失落">這座城市一般，享受著奢侈卻莫名失落&lt;/h2>
&lt;p>等這首歌等很久了！！「比較龐大的管樂組合僅出現在《城市》當中」《蘇打誌》早就提到了這首，果然真的出現了，正宗的交響樂版！而且是以一種絕妙的意境連接，以及無比滂礡的氣勢堆疊！一層一層的管弦樂把情緒往上帶，好像人類的城市發展一般，人口日益擁擠，數位的浪花讓人喘不過氣。讓人整個聽得過癮，每次聽都忘記哪邊才是副歌，其實整首歌是一個流暢的大組合啊！聽完這首還餘音不絕於耳，出去上廁所還一邊哼XD，覺得如果在這邊結束了也值得了（欸）。拜託發DVD吧我還想再聽一遍！！！！&lt;/p>
&lt;h2 id="其實還有下半場就留給下半篇吧">其實還有下半場，就留給下半篇吧！&lt;/h2>
&lt;p>附帶一提，報時的設計每次都不一樣是很棒的巧思哈哈，好像是指揮吧用不太標準的中文說「十五分鐘」格外逗趣～&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>物理解題經驗分享：四大步驟</title><link>https://dwye.dev/post/20151028_162837/</link><pubDate>Wed, 28 Oct 2015 16:28:37 +0800</pubDate><guid>https://dwye.dev/post/20151028_162837/</guid><description>
&lt;h2 id="四大步驟">四大步驟&lt;/h2>
&lt;p>看到題目不知道要做什麼？一個不熟悉的題型應該從何下手？就算是身經百戰的考生，可能今年大考又有新的題型。除了基本題型熟練之外，更重要的是訓練自己不害怕新的題型，能夠運用所學穩健地破解題目。就我觀察，一般解題的高手都有一個自己習慣的解題步驟，可能是自然而然產生的，也可能是自己制定下來自己習慣的。因此在這邊將自己寫物理時候的習慣步驟整理出來分享給大家：&lt;/p>
&lt;h3 id="第一步破題">第一步：破題&lt;/h3>
&lt;p>找到題目的關鍵字，重量多少？接觸面光滑與否？仰角多少？要不要考慮重力？有沒有固定系統壓力？是圓周運動還是直線飛出？要問什麼？把有用的資訊圈起來，去蕪存菁，看這題到底要考我們什麼。有沒有可以直接刪掉或是直接回答的選項？&lt;/p>
&lt;h3 id="第二步前置準備">第二步：前置準備&lt;/h3>
&lt;p>畫圖！找到一個可以計算的空間，用自己能理解的方式畫出題目圖像，像是情境圖、力圖，並且把速度、加速度、能量之類的資訊標上去。我們在第一步找的的線索裡面有什麼可以用？如果沒有的，就都設未知數。題目給的資訊，單位是不是都正確？除非答案有特殊要求，不然最好是都換成SI制。若是到這邊沒有什麼想法，就趕快跳下一題做，把這題留到後面再寫，考試中時間是很寶貴的。&lt;/p>
&lt;h3 id="第三步列式">第三步：列式&lt;/h3>
&lt;p>想想自己學過的物理定律或公式，哪些包含了題目給的條件，哪些可以求出我們要的答案？幾個未知數就要幾條方程式來解。&lt;/p>
&lt;h3 id="第四步計算">第四步：計算&lt;/h3>
&lt;p>代入消去，相除消去，把未知數求出來，這是所有步驟裡面最簡單的部分。&lt;/p>
&lt;h2 id="應用">應用&lt;/h2>
&lt;p>大部分題目我都是用上面四步去想的，可能只講理論有點抽象，這邊直接用一道題目當例子好了：&lt;/p>
&lt;p>&lt;img src="https://lh4.googleusercontent.com/nHdWd0oiy2VxBZ4tOtSclmPORgUYdTKjotBkUs-2w6YXUaMDBB_nwuv-onC2ySRN1LdQo0D9IGLz0tHz6BUqSQg_PofA0EK1KA7Om7FkX0UBFzP_hJoAursJxeGBs9yXvSGYj0Q4" alt="Physic Quiz">&lt;/p>
&lt;h3 id="一破題">一、破題：&lt;/h3>
&lt;p>看圖就知道這是一題斜拋了。&lt;/p>
&lt;p>題目給的資訊有：質量、初速、仰角、最高高度H、A點高度h，重力加速度g。&lt;/p>
&lt;p>題目要問的有：在A點的鉛直速率、OA時間、最高點B時速度跟加速度的關係&lt;/p>
&lt;p>這個時候會發現，(D)選項為純粹考觀念的選項，如果知道最高點B只剩水平速度，而加速度是重力加速度一直都是往下，就可以知道在B點時速度一定會垂直加速度，(D)要選。&lt;/p>
&lt;h3 id="二準備">二、準備&lt;/h3>
&lt;p>題目已經給圖了，不過我還是畫了幾張圖補助：&lt;/p>
&lt;p>起始速度：&lt;/p>
&lt;p>&lt;img src="https://lh6.googleusercontent.com/i5bESwWzUlelnR-mEfltCmL3eaXBvM7JunKR9Kjx8MEYUm_iSMrUueKk7Zdo3qSI9P4wdXtV_ZXIXwSXTYeysuL9oIoZ_MOecNn5fR-PVlqHvRabvp1nKTqOj49MgjII7nFLsj6r" alt="initial velocity">&lt;/p>
&lt;p>B點速度：&lt;/p>
&lt;p>&lt;img src="https://lh6.googleusercontent.com/INdPEsdXYbyiiGRwBa-_kwQnWg7Ofj6QkqCnpr8NLg5_s3MjycwmHOgW2hO-XoiNXQB2URYqdm1fxT2vuKNz5yUNoEq9_nqiR6wOl5zMc5_MKBe0df4POkeKG0P9qY2JQpPsjTwx" alt="velocity of b">&lt;/p>
&lt;p>A點速度：&lt;/p>
&lt;p>&lt;img src="https://lh6.googleusercontent.com/bMDZ7C3lptDek3b1k5zqYbmnrd4PoJEv4J14v-d7riYFBF91m_OYWCFvaqV3VohyFSZhH3O4vBT3FKBBu05PIqdOKoeqKvqdhTTE00mnQqg5fsN8iTK9gN0SHm24wojDFvtNI2A1" alt="velocity of a">&lt;/p>
&lt;p>這樣對於速度的概念會比較清楚，重點就是，水平方向是等速度運動，而鉛直方向則是加速度g往下的等加速度運動。&lt;/p>
&lt;h3 id="三列式">三、列式&lt;/h3>
&lt;p>所以要求出A的鉛直速率，可以善用B到A的等加速度運動去求，既然有了初速0，加速度g，以及兩者高度差（位移）H-h，就可以利用等加速度運動的第三條公式：&lt;/p>
&lt;p>$$ v^2 = v_0^2 + 2a\Delta x $$&lt;/p>
&lt;p>代入之後完成列式。&lt;/p>
&lt;h3 id="四計算">四、計算&lt;/h3>
&lt;p>在此不詳述，可以算出A點鉛直速率為 $\sqrt{2g(H-h)}$，選項(A)為錯誤&lt;/p>
&lt;p>這時發現，選項(B)和(C)問的是同樣的事情，要問O點到A點的時間，這時既然我們已經對鉛直方向瞭若指掌，何不從鉛直方向下手？重複第三步列式，找到可以求出時間的公式：&lt;/p>
&lt;p>$$ v = v_0 + at $$&lt;/p>
&lt;p>代入已知的O點初始速度、A點的末速以及加速度g，完成列式，注意正負號喔，這邊統一以向上為正：&lt;/p>
&lt;p>$$ - \sqrt{2g(H-h)} = v_0 \sin{\theta} - gt $$&lt;/p>
&lt;p>接者就移項把答案算出來就解決這題了！(C)也要選，所以答案是(C)(D)&lt;/p>
&lt;h2 id="還有">還有&lt;/h2>
&lt;h3 id="把所有題目當作計算題">把所有題目當作計算題&lt;/h3>
&lt;p>還有一個很重要的原則，如果是自然組，我建議這個習慣必須培養起來：寫題目的時候，把所有題目當作計算題來寫，把算式寫整齊，寫錯直接擦掉而不要在上方塗改。因果來由交代一下，讓以後的自己也能看得懂，也方便之後回來檢查。這四大步驟，每一步都要動筆，第一步破題時就要在題目上標出關鍵字和有用資訊，畫圖更不能偷懶，有圖可以幫助自己理解題目情境，並且思考題目要怎麼做。&lt;/p>
&lt;h3 id="學習解題">學習解題&lt;/h3>
&lt;p>步驟是活的，不是每一題都要四步，也有在第四步失敗了回到第一步檢查。若是初學者或是對物理比較沒有感覺的人，很容易一開始就卡住，這時候唯一的訣竅就是「練習」，以戰養戰。我建議能夠模仿老師上課講的例題，看著例題依樣畫葫蘆做類題，或是把例題蓋住重新做一遍，就算把解題方法背下來也沒關係，常有人說不能死背題目，但把一些基本做法背下來我認為是邁向熟練的第一步。&lt;/p>
&lt;p>等到有一定的熟練度後，開始找到自己統一的步驟，找到自己適合的解題方法，可以試著挑戰新題目和較難的題目，實際上很多難題都是由各種基本觀念堆砌起來的。到了更高竿的階段，就是老師常說的「先看到結果再計算」，畫完圖整理完資訊之後，在腦袋裡想出怎麼計算出答案之後才繼續動筆，一次解決。以我個人的經驗，能夠對於每個題目有自己的步驟，是段考考好所必需的，畢竟段考就是同一章節的題目不斷變化。但是指考物理若要考好，則必須能夠對物理熟練到「先看到結果再計算」的境界。&lt;/p>
&lt;h2 id="寫在文章最後隱藏的第五步檢查">寫在文章最後，隱藏的第五步：檢查。&lt;/h2>
&lt;p>我建議的檢查步驟如下：&lt;/p>
&lt;p>一、算出的答案和選的選項是否一樣？和答案卡上劃的是否一樣？題目問的是「正確」還是「錯誤」，選項有沒有選反？&lt;/p>
&lt;p>二、題目給的數字，在畫圖的時候有沒有寫錯？代入算式有沒有代錯？單位是不是都統一了？&lt;/p>
&lt;p>三、重新把題目看一次，自己對題目的理解是不是正確的？有沒有求錯東西？&lt;/p>
&lt;p>四、重新把計算過程寫一次，計算結果是不是一樣？&lt;/p>
&lt;p>根據時間足夠與否，先一再二最後是三。&lt;/p>
&lt;p>希望這篇文能夠幫上一些忙，不管是考生還是其他人，祝大家都能夠成功克服高中物理這個難關。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>五月天 - 女也 個人小心得</title><link>https://dwye.dev/post/20150721-herstory-with-mayday/</link><pubDate>Tue, 21 Jul 2015 16:28:37 +0800</pubDate><guid>https://dwye.dev/post/20150721-herstory-with-mayday/</guid><description>
&lt;p>忍到專輯出來之後一次用KKBOX聽完&lt;br>
之後邊聽第二遍編寫感想&lt;br>
算是個人小心得啦&amp;hellip;也不是什麼專業的音樂人&lt;br>
另外我對人聲比較沒什麼感覺所以會比較著重於編曲&lt;br>
然後我是理組的沒啥文筆就請見諒喔&lt;/p>
&lt;hr>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/xy-BqLWpoQM" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>生命有一種絕對&lt;/p>
&lt;p>想要傳達的意境跟原本是差不多的&lt;br>
人聲的部分有很多微妙的調整還蠻有意思的&lt;br>
倒數第二次副歌後面進入整首歌的高潮的地方很喜歡&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/Eso_PkuYlB4" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>盛夏光年&lt;/p>
&lt;p>風格變得很迷幻XD&lt;br>
我要我瘋我要我愛那邊有左右聲道的特效&lt;br>
變得比較像是在你耳邊說話的感覺&lt;br>
而不是原本的炸裂感&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/hwe411J3Hbc" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>離表&lt;/p>
&lt;p>從搖滾曲變成電音舞曲，整體還不錯啦&lt;br>
另外很喜歡副歌多出來的合音&lt;br>
（撲通撲通的狂跳）&lt;br>
應該是一首搖得起來的歌，但是可能還是沒辦法像原曲跳起來XD&lt;br>
節奏有點單調，原本的鼓變化其實還蠻用心的有點可惜&lt;br>
不過會這麼嚴苛也是因為這首原本是我最喜歡的歌&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/IBT0_3QUy98" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>突然好想你&lt;/p>
&lt;p>空氣真的好安靜&amp;hellip;.&lt;br>
配樂營造了一個適合哭泣的環境&lt;br>
整體的輕重走向跟原本一樣&lt;br>
「最痛的紀念品」後面多一段副歌被嚇到了XDD&lt;br>
間奏覺得普普就是，只是換個樂器&amp;hellip;沒什麼共鳴&lt;br>
喜歡主歌勝過於副歌&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/eZxkpvoJI2Q" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>溫柔&lt;/p>
&lt;p>變得&amp;hellip;好有節奏感XDDDD&lt;br>
完全就是一首改編歌的Fu（慢慢的人聲配上硬是要節奏感的拍子）&lt;br>
間奏沒什麼變就是&lt;br>
最後一段主歌回到原點的感覺有做出來&lt;br>
但是尾奏突然跑進來有點嚇到XD&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/6dwbkrAKpvY" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>你不是真正的快樂&lt;/p>
&lt;p>雖然是改編版但是不知道為什麼很有原版的感覺XD&lt;br>
只是&amp;hellip;副歌的弦樂完全跟著人聲好像伴唱帶喔XDDD&lt;br>
不是應該要幫人聲合音或作伴奏之類的&lt;br>
「然後才後悔著」後面的Bridge大好！&lt;br>
爆發力也很夠&lt;br>
只是後面突變的很嗨就不像原本要傳達的意思了&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/0sDtXpMUKAE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>我不願讓你一個人&lt;/p>
&lt;p>第一個感覺是「拍子好慢喔」XDDDD&lt;br>
鋼琴的伴奏有點逗趣，反而沒有那麼多悲傷的感覺&lt;br>
但是總覺得有點扭曲，有種思念對方思念到不知道自己在幹嘛的Fu&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/6n8AitBL7xc" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>如煙&lt;/p>
&lt;p>一開始的彈奏有點小叮噹的感覺啊XDDD&lt;br>
整體編曲很合口味，只是人聲太重就是了&lt;br>
「有沒有」的唱法跟原曲不同&lt;br>
Bridge不像原曲有壓下去的感覺，反而特別突出&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/45mI3RaNOow" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>愛情萬歲&lt;/p>
&lt;p>應該是改最多的一首吧&amp;hellip;&lt;br>
原本的間奏和配樂和節拍全部被吃掉重寫&lt;br>
除了人聲旋律和原本比較像之外幾乎都改了&lt;br>
然後合成音用的超級迷幻，搭上歌詞就變很撫媚了&lt;br>
整首歌的風格十分明顯&lt;br>
雖然不是我會收的風格，但在心中的評價很高（糟了，好像在發好人卡）&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/3Q__2oA69PM" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>我心中尚未崩壞的地方&lt;/p>
&lt;p>這首歌被改得一點都不孤獨啊XDDDD&lt;br>
反而變得很熱鬧的感覺&lt;br>
只聽旋律好像還不錯只是我覺得很不搭啦&lt;br>
個人不是很喜歡&lt;/p>
&lt;hr>
&lt;p>整個聽下來最喜歡的前三名分別是&lt;br>
你不是真正的快樂 &amp;gt; 突然好想你 &amp;gt; 離開地球表面&lt;br>
另外整張專輯風格跟五月天差好多喔&lt;br>
聽習慣的人(就我啦)來聽這張反而會一直覺得很怪&lt;br>
如果說有愛再來聽&amp;hellip;.好像也不會因為我會繼續聽五月天的版本XDDD&lt;br>
沒辦法誰叫有愛是對五月天有愛而不是對改編版有愛呢哈哈&lt;br>
不過應該可以把五月天的歌推廣給新的族群吧（不喜歡樂團的XD）&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>高中基礎物理補充：費曼對能量的見解</title><link>https://dwye.dev/post/feynman-and-energy/</link><pubDate>Tue, 24 Mar 2015 00:48:45 +0800</pubDate><guid>https://dwye.dev/post/feynman-and-energy/</guid><description>
&lt;p>這是&lt;a href="https://dwye.dev/highschool-physics">基礎物理補充文章&lt;/a>的一部分。&lt;/p>
&lt;hr>
&lt;p>偉大的物理學家，也幾乎是近世普物課程之始祖：費曼 (Feynman)，在他的課程中發表了他對能量的看法：&lt;/p>
&lt;blockquote>
&lt;p>我們發現了一個事實，有一個定律掌控了到目前為止我們所知道的自然現象，而這個定律在我們所知範圍內沒有任何的例外。而且以我們目前所知，它是準確的。這個定律被稱為「能量守恆」。它說明了有一個特定的物理量，我們稱之為「能量」，這個量在自然狀態經歷了各種變化後，並不會改變。也許聽來有些抽象，因為它是一個數學的原理：它說明了有一個量在一些事件發生時不會改變。而且並不是任何具體的物理過程描述，卻僅是一個奇特的事實：我們可以先對系統計算這些量，而當系統經歷了一些變化之後，如果我們在去計算這些量，會發現這些量加起來並沒有改變。（就好向西洋棋裡面的『象』，它只能斜著走，因此如果它原本在黑色的格字上，不管它中間動了幾步以及如何動，還是會在黑色的格子上，這就是因為這是西洋棋天生的『規則』）&lt;/p>
&lt;/blockquote>
&lt;p>簡單歸納起來，就是&lt;/p>
&lt;p>&lt;strong>一個間接被定義的物理量，這個量可以在物質中轉換，並且會守恆。&lt;/strong>&lt;/p>
&lt;p>以下附上英文原文：&lt;/p>
&lt;blockquote>
&lt;p>There is a fact, or if you wish, a law, governing all natural phenomena that are known to date. There is no known exception to this law—it is exact so far as we know. The law is called the conservation of energy. It states that there is a certain quantity, which we call energy, that does not change in the manifold changes which nature undergoes. That is a most abstract idea, because it is a mathematical principle; it says that there is a numerical quantity which does not change when something happens. It is not a description of a mechanism, or anything concrete; it is just a strange fact that we can calculate some number and when we finish watching nature go through her tricks and calculate the number again, it is the same. (Something like the bishop on a red square, and after a number of moves—details unknown—it is still on some red square. It is a law of this nature.)&lt;/p>
&lt;/blockquote>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://www.feynmanlectures.caltech.edu/I_04.html">費曼物理學講義 I-IV 能量守恆（英文）&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>高中基礎物理補充：馬克士威方程式簡介</title><link>https://dwye.dev/post/maxwell-eq/</link><pubDate>Mon, 23 Mar 2015 00:48:45 +0800</pubDate><guid>https://dwye.dev/post/maxwell-eq/</guid><description>
&lt;p>這是&lt;a href="https://dwye.dev/highschool-physics">基礎物理補充文章&lt;/a>的一部分。&lt;/p>
&lt;hr>
&lt;p>法拉第發現了電磁感應的現象之後，相關的應用產品就開始發展，但這時候人們主要還是注重於電磁感應現象的應用，尚未有一套理論基礎被發展出來。&lt;/p>
&lt;p>馬克士威正巧誕生於法拉第發現電磁感應現象那一年，這似乎註定著他之後在電磁學上的偉大貢獻：&lt;strong>為電與磁的現象建立一套完整的數學理論&lt;/strong>，並且用他的方程式們&lt;strong>預測電磁波的存在&lt;/strong>，以及&lt;strong>計算光速&lt;/strong>。&lt;/p>
&lt;p>馬克士威方程式一共有四條：&lt;/p>
&lt;h2 id="高斯定律">高斯定律&lt;/h2>
&lt;p>從一個地方產生或消失的電場大小，跟那裡的電荷密度有關。&lt;br>
$$&lt;br>
\nabla \cdot \mathbf{E} = \frac {\rho} {\varepsilon_0}&lt;br>
$$&lt;/p>
&lt;h2 id="高斯磁場定律">高斯磁場定律&lt;/h2>
&lt;p>從一個地方產生或消失的磁場量是零。（即&lt;strong>磁場是封閉的&lt;/strong>）&lt;br>
$$&lt;br>
\nabla \cdot \mathbf{B} = 0&lt;br>
$$&lt;/p>
&lt;h2 id="馬克士威-法拉第方程式">馬克士威-法拉第方程式&lt;/h2>
&lt;p>一個變化的磁場，會產生一個抵抗其變化的電場。&lt;br>
$$&lt;br>
\nabla \times \mathbf{E} = -\frac{\partial \mathbf{B}} {\partial t}&lt;br>
$$&lt;/p>
&lt;h2 id="馬克士威-安培方程式">馬克士威-安培方程式&lt;/h2>
&lt;p>一個變化的電場或是一道電流( $J$ 是電流密度)，會產生一個順應其變化的磁場。&lt;br>
$$&lt;br>
\nabla \times \mathbf{B} = \mu_0\left(\mathbf{J} + \varepsilon_0 \frac{\partial \mathbf{E}} {\partial t} \right)&lt;br>
$$&lt;/p>
&lt;h2 id="小結">小結&lt;/h2>
&lt;p>其中用到了一些比較進階的微積分符號，這邊就不多作深入說明，只是秀給大家看這些和現代科技息息相關的數學式。因為電磁波是由電場和磁場依據這些方程式互相感應而生成，所以理所當然地馬克士威就計算出了電磁波的速度。&lt;/p>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>維基百科：&lt;a href="http://en.wikipedia.org/wiki/Maxwell's_equations">馬克士威方程式&lt;/a>與相關頁面&lt;/li>
&lt;li>伊恩‧史都華 改變世界的17個方程式&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>高中基礎物理：原子內電力與重力的比較</title><link>https://dwye.dev/post/force-in-atom/</link><pubDate>Thu, 12 Feb 2015 00:48:45 +0800</pubDate><guid>https://dwye.dev/post/force-in-atom/</guid><description>
&lt;p>這是&lt;a href="https://dwye.dev/highschool-physics">基礎物理補充文章&lt;/a>的一部分。&lt;/p>
&lt;hr>
&lt;p>為什麼在想像原子模型時，都是說「&lt;strong>電子受到原子核的靜電力吸引&lt;/strong>」而沒有考慮到「&lt;strong>電子和原子核的萬有引力吸引&lt;/strong>」？這邊利用&lt;a href="https://dwye.dev/s/H1Mbwesf4">估算法&lt;/a>稍微估計一下兩個力的大小差別，就會發現原因，以下以氫原子為例：&lt;/p>
&lt;h2 id="重力">重力&lt;/h2>
&lt;p>$$&lt;br>
F_g = \frac{GM_1M_2}{r^2} =&lt;br>
\frac{(6.67 \times 10^{-11})(9.11 \times 10^{-31})(1.67 \times 10^{-27})}{r^2} \approx&lt;br>
\frac{10^{-67}}{r^2}&lt;br>
$$&lt;/p>
&lt;h2 id="電力">電力&lt;/h2>
&lt;p>$$&lt;br>
F_e = \frac{kQ_1Q_2}{r^2} =&lt;br>
\frac{(9 \times 10^9)(1.6 \times 10^{-19})^2}{r^2}\approx&lt;br>
\frac{10^{-28}}{r^2}&lt;br>
$$&lt;/p>
&lt;h2 id="於是">於是&lt;/h2>
&lt;p>$$&lt;br>
\frac{F_g}{F_e} \approx 10^{-39}&lt;br>
$$&lt;br>
兩個力完全不在同一個數量級上面。&lt;/p>
&lt;p>&lt;strong>原子內的電力比重力還要大上超過幾千兆倍，所以重力幾乎都被忽略掉了&lt;/strong>。一般在計算原子內的電子軌域時，主要考慮的還是原子核和電子間的引力，再加上其他電子對電子的引力作修正。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>高中基礎物理補充：終端速度簡單介紹</title><link>https://dwye.dev/post/terminal-speed/</link><pubDate>Tue, 03 Feb 2015 00:48:45 +0800</pubDate><guid>https://dwye.dev/post/terminal-speed/</guid><description>
&lt;p>這是&lt;a href="https://dwye.dev/highschool-physics">基礎物理補充文章&lt;/a>的一部分。&lt;/p>
&lt;hr>
&lt;h2 id="簡單的阻力公式">簡單的阻力公式&lt;/h2>
&lt;p>一般在計算自由落體時，我們忽略了空氣阻力，但實際上空氣是有阻力的。在普通物理學裡面我們可以用一個簡單的式子來估計阻力 $f$：&lt;br>
$$&lt;br>
f = \frac{1}{2}C\rho Av^2=kv^2&lt;br>
$$&lt;/p>
&lt;ul>
&lt;li>$C$, $k$：常數&lt;/li>
&lt;li>$\rho$：空氣密度&lt;/li>
&lt;li>$A$：截面積&lt;/li>
&lt;li>$v$：速率&lt;/li>
&lt;/ul>
&lt;p>因為下降的速率越快，劃破空氣越用力，所以空氣給的阻力就會越大，因此阻力是和下落速度有關的，即為 $f=kv^2$，或在一些學測考題裡面，會用 $f=kv$ 來估計阻力，&lt;/p>
&lt;p>兩者只是不同的模型而已，並沒有對錯，只有不同情況下，哪個比較準的問題。&lt;/p>
&lt;h2 id="終端速度的推導">終端速度的推導&lt;/h2>
&lt;p>也因為阻力和速率有關，下落速率越大，可以從牛頓第二運動定律得出：&lt;br>
$$&lt;br>
F_合 = ma = mg - kv^2 \&lt;br>
a = g - \frac{kv^2}{m}&lt;br>
$$&lt;br>
因此&lt;strong>加速度會隨著速率的上升而變小&lt;/strong>，可大略畫出 $v$-$t$ 圖如下（斜率即加速度）：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/fWk3fJ1.png" alt="">&lt;/p>
&lt;p>當加速度減小到零的時候，速度變成一直線，這時候就稱為「&lt;strong>終端速度&lt;/strong>」，是物體在下落過程中所能達到的&lt;strong>最大速度&lt;/strong>。&lt;/p>
&lt;p>附帶一提，物體是永遠無法達到終端速度的，只會不斷接近它。終端速度所形成的直線是一條「漸進線」，物體的速度曲線會逐漸靠近它，但永不相交。&lt;/p>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>Halliday &amp;amp; Resnick, Fundamentals of Physics&lt;/li>
&lt;li>102學測自然科試題&lt;/li>
&lt;/ul>
&lt;h2 id="圖片來源">圖片來源&lt;/h2>
&lt;ul>
&lt;li>102學測自然科試題&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>高中基礎物理補充：白話微積分</title><link>https://dwye.dev/post/differentiation-and-integration/</link><pubDate>Wed, 21 Jan 2015 00:48:45 +0800</pubDate><guid>https://dwye.dev/post/differentiation-and-integration/</guid><description>
&lt;p>這是&lt;a href="https://dwye.dev/highschool-physics">基礎物理補充文章&lt;/a>的一部分。&lt;/p>
&lt;hr>
&lt;h2 id="微分">微分&lt;/h2>
&lt;p>微分，可以求出一個函數的&lt;strong>斜率函數&lt;/strong>，只要把斜率函數內的任何一個x座標帶入，就能得到原本函數在x座標的斜率。&lt;/p>
&lt;p>以下圖來說，求出一點的斜率似乎沒有很直觀的數學算式，&lt;strong>要有斜率就必須要有一條線，要定出一條線則必須在平面上找到兩個點&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/KxdBYBR.png" alt="differentiation from Salas, Calculous one and several variables 10/e">&lt;/p>
&lt;p>所以這邊用的方式就是，除了我們要的點之外，先另外取一個點 $x+h$，畫出割線。這時候發揮想像力，把另取的點 $x+h$ 沿著函數，不斷往 $x$ 的位置移動，&lt;strong>越靠近 $x$ 越好&lt;/strong>，但是不能碰到 $x$ ，不然重合成一個點的話就無法決定一條線了。&lt;/p>
&lt;p>這樣我們就能得到一個很接近切線的割線，同時這個割線的斜率也會很接近函數在該點的斜率。現在以函數 $f(x)=x^2$ 當作例子，用算式求出斜率的過程表示如下：&lt;br>
$$&lt;br>
x點的斜率 = \frac{f(x+h)-f(x)}{(x+h)-x} =&lt;br>
\frac{(x+h)^2 - x^2}{h} =&lt;br>
\frac{2xh - h^2}{h} = 2x+h&lt;br>
$$&lt;/p>
&lt;p>因為我們不斷把兩個點靠近，$h$ 就會縮小到可以忽略的地步，因此上述的答案就變成 $2x$，這正是 $f(x)=x^2$ 的斜率函數，或著用更正式的名字，叫「&lt;strong>導函數&lt;/strong>」。&lt;/p>
&lt;p>而這個過程，我們會說是「&lt;strong>把 $f(x)$ 對 $x$ 微分」&lt;/strong>。這套工具是牛頓為了解決運動學上的問題所發明的，只要把 $x$-$t$ 圖中的 $x$ 對 $t$ 微分，就可以求出任何時刻&lt;strong>位置對時間的變化，也就是速度&lt;/strong>。&lt;/p>
&lt;p>牛頓除了這項工具之外，他還有另外一項利器：積分。&lt;/p>
&lt;h2 id="積分">積分&lt;/h2>
&lt;p>積分，可以求出一個函數底下和橫軸所夾的&lt;strong>面積&lt;/strong>。&lt;/p>
&lt;p>這個面積所形成的函數 $F(x)$，就剛好是&lt;strong>微分的反過來操作&lt;/strong>。只要把 $F(x)$ 微分之後，就可以得到原本的函數 $f(x)$。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/otu3UM2.png" alt="integration from Salas, Calculous one and several variables 10/e">&lt;/p>
&lt;p>如圖，積分的想法就是把一個不規則的函數切成很多很多小塊的長方形。原本的函數面積很複雜，沒有公式可以算，但切成小塊的長方形之後，我們就可以分別計算長方形的面積公式，加起來，就可以得到整塊函數底下的面積。圖中的長方形面積也許不夠準，但是只要切越多塊，所有長方形的面積就會越接近函數和橫軸所夾的真正面積。&lt;/p>
&lt;p>通常在計算積分的時候，只要把微分的法則反過來運用就成了。不過也因為沒有較直接的運算方法，所以積分的運算通常比微分複雜，甚至會有無法直接積分的情況發生。&lt;/p>
&lt;h2 id="其他關於微積分">其他關於微積分：&lt;/h2>
&lt;p>除了牛頓之外，另一個科學家：&lt;strong>萊布尼茲，也獨立發展出了這套工具&lt;/strong>，他和牛頓常常被視為微積分的發明者。不過這套工具一直受到質疑，因為它的「無限接近」的概念一直沒有數學上嚴謹的定義，這個問題一直到19世紀時才被一些數學家所解決，並成為現在大學生最入門的科目：「微積分Calculous」。（英文Calculous是計算的意思，不過因為教學內容主要還是要提供微積分這套工具，因此中文名稱才稱呼叫微積分。）&lt;/p>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>伊恩‧史都華 改變世界的17個方程式&lt;/li>
&lt;li>容志輝老師 101-1微積分甲上 課程筆記&lt;/li>
&lt;li>Salas, Calculous one and several variables 10/e&lt;/li>
&lt;/ul>
&lt;h2 id="圖片來源">圖片來源&lt;/h2>
&lt;ul>
&lt;li>Salas, Calculous one and several variables 10/e&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>高中基礎物理補充：基本粒子大觀園</title><link>https://dwye.dev/post/elementary-particles/</link><pubDate>Fri, 12 Dec 2014 00:48:45 +0800</pubDate><guid>https://dwye.dev/post/elementary-particles/</guid><description>
&lt;p>這是&lt;a href="https://dwye.dev/highschool-physics">基礎物理補充文章&lt;/a>的一部分。&lt;/p>
&lt;hr>
&lt;h2 id="基本粒子">基本粒子&lt;/h2>
&lt;p>基本粒子，是科學家對於物質所認知的最小單位，隨著科學的進展，最小單位不斷的被更新。現今物質的最小單位，最廣為所知的大概就是電子和夸克。不少的基本粒子因為生存週期不長，或和一般人認知的物質概念有所相左，所以比較不被熟悉。&lt;/p>
&lt;h2 id="費米子">費米子&lt;/h2>
&lt;p>最為人所知的夸克大概就是「上夸克」（帶電+2/3基本電荷）和「下夸克」（帶電-1/3基本電荷），這兩種夸克三個一組靠強力結合在一起，形成質子（2上1下）和中子（1上2下），這兩個夸克是所謂「第一代」被發現的粒子。後來還有科學家發現其他的夸克，目前已知六種，且它們的共同特性就是：不會單獨存在，夸克通常是成對或是三個一組形成較重的粒子。&lt;/p>
&lt;p>電子屬於相對於夸克的「輕子」，不參與強交互作用的粒子。電子也屬於「第一代」，同時是最早被認知的基本粒子。&lt;strong>夸克和電子屬於「費米子」，意指自旋量（參見高三化學）是半整數（以電子為例：±1/2）的粒子&lt;/strong>。它們的共同特性就是：遵守&lt;strong>鮑立不相容定則&lt;/strong>，有個簡單的比喻，就是兩個費米子不能放在同一個位置。&lt;/p>
&lt;h2 id="玻色子">玻色子&lt;/h2>
&lt;p>除了費米子之外，當然也有&lt;strong>自旋量是整數（包含0）的粒子，這些粒子稱為玻色子&lt;/strong>，它們不遵守鮑立不相容定則，可以放在完全相同的位置而發生「玻色－愛因斯坦凝聚」。目前已知的玻色子分為兩種：「規範玻色子」、「希格斯玻色子」。&lt;/p>
&lt;p>自然界的交互作用（也就是力，參見基礎物理第四章），必須透過規範玻色子來進行，因此又可以依交互作用將規範波色子繼續分類。和重力作用有關的是「引力子」，但由於重力太弱，導致引力子一直都沒有被發現；和強力有關的是「膠子」，維持原子核和質子、中子的穩定存在；而和電磁力作用有關的，正是我們&lt;strong>常見的電磁波的本尊：「光子」&lt;/strong>。&lt;/p>
&lt;p>希格斯玻色子，是最近才被實驗上偵測到的基本粒子，詳細性質很多都還是謎團，但科學家預測這個粒子可能是質量的來源。&lt;/p>
&lt;h2 id="反粒子">反粒子&lt;/h2>
&lt;p>很多粒子有相對應的反粒子存在，例如：電子有相對應的「正子」存在。但也有反粒子就是其本身的例子，例如：光子。粒子構成物質，反粒子構成反物質。&lt;strong>反物質和物質接觸時，會立刻遵守愛因斯坦的質能轉換公式而化為能量&lt;/strong>。原本宇宙產生時，一般物質和反物質的數量應該要一樣，但可能是因為衰變速率不同，導致最後剩下物質存在我們熟悉的世界，反物質則灰飛煙滅。不過科學家現在已經有技術在實驗室裡面短暫地呼喚出反物質。&lt;/p>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://zh.wikipedia.org/wiki/%E5%9F%BA%E6%9C%AC%E7%B2%92%E5%AD%90">維基百科：基本粒子和相關頁面&lt;/a>&lt;/li>
&lt;li>科技部高瞻自然科學教學資源平台：&lt;a href="https://highscope.ch.ntu.edu.tw/wordpress/?p=19087">基本粒子&lt;/a>、&lt;a href="https://highscope.ch.ntu.edu.tw/wordpress/?p=41214">反粒子&lt;/a>&lt;/li>
&lt;li>Carter, Classical and Statistical Thermodynamics：費米子、玻色子的統計性質。&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>高中基礎物理補充：寫在三態之外</title><link>https://dwye.dev/post/state-phase-plasma/</link><pubDate>Sun, 07 Dec 2014 00:48:45 +0800</pubDate><guid>https://dwye.dev/post/state-phase-plasma/</guid><description>
&lt;p>這是&lt;a href="https://dwye.dev/highschool-physics">基礎物理補充文章&lt;/a>的一部分。&lt;/p>
&lt;hr>
&lt;p>物質有三態：固態、液態、氣態。乍聽起來就像物質有三寶一樣，但是其實物質並不是只有三寶！&lt;/p>
&lt;h2 id="狀態state">狀態(State)&lt;/h2>
&lt;p>「狀態」的意思，是說分子排列的緊密程度。固態，是緊密排列；液態，分子很靠近但可以滑動；氣態，分子之間是自由的，所以才能有不同體積。&lt;/p>
&lt;p>除了這三種狀態之外，另外還有「&lt;strong>電漿態(plasma)&lt;/strong>」，把氣體繼續加溫，有機會使分子游離，形成電子和離子以及中性分子的混合狀態。現在更有技術可以在不那麼高溫的情況下做出電漿。&lt;/p>
&lt;p>電漿態物質並不稀有，例如：電漿電視、大氣電離層、一些火焰尖端、太陽之類的恆星。電漿態和一般所知的三態，常被統稱為物質基本四態。&lt;/p>
&lt;h2 id="相phase">相(Phase)&lt;/h2>
&lt;p>只要&lt;strong>分子的排列方式不一樣，就算是不同的「相」&lt;/strong>。&lt;/p>
&lt;p>最簡單的例子，就是&lt;strong>鑽石和石墨&lt;/strong>，雖然都是碳原子組成，但沒有人會認為它們是一樣的東西，不管是顏色、硬度、導電性，甚至是價值，都天差地遠，所以把它們歸為不同的「相」也是合情合理。&lt;/p>
&lt;p>以水為例，大家所熟悉的固態就是日常生活之間所見的冰，但是其實水的固態不只一種相，目前已經發現水在不同溫壓情況下，會有很多不同的排列方式。詳細可以參考&lt;a href="https://highscope.ch.ntu.edu.tw/wordpress/?p=53503#more-53503">這篇&lt;/a>。&lt;/p>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>維基百科：&lt;a href="http://zh.wikipedia.org/wiki/%E7%89%A9%E8%B4%A8%E7%8A%B6%E6%80%81">物質狀態&lt;/a>、&lt;a href="http://zh.wikipedia.org/wiki/%E7%AD%89%E7%A6%BB%E5%AD%90%E4%BD%93">電漿&lt;/a>、&lt;a href="http://zh.wikipedia.org/wiki/%E7%9B%B8_(%E7%89%A9%E8%B4%A8)">相&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://highscope.ch.ntu.edu.tw/wordpress/?p=53503#more-53503">科技部高瞻自然科學教學資源平台：水的三相點不只一個&lt;/a>&lt;/li>
&lt;li>Silbey, Physical Chemistry 4/e&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>高中基礎物理補充：巨觀與微觀</title><link>https://dwye.dev/post/macrocosm-and-microcosm/</link><pubDate>Tue, 02 Dec 2014 00:48:45 +0800</pubDate><guid>https://dwye.dev/post/macrocosm-and-microcosm/</guid><description>
&lt;p>這是&lt;a href="https://dwye.dev/highschool-physics">基礎物理補充文章&lt;/a>的一部分。&lt;/p>
&lt;hr>
&lt;h2 id="巨觀">巨觀&lt;/h2>
&lt;p>巨觀，簡單說起來，就是我們日常生活所看到的。&lt;/p>
&lt;p>像是桌子、汽車、電燈……，這些東西你不會看得到他們是由一粒粒分子組成的，它們看起來就是彼此不同的東西，桌子就是桌子，你不會發現桌子跟玻璃在分子排列上面有什麼差別，你最多只會發現桌子跟椅子都是木頭做的。&lt;/p>
&lt;p>如果我們使用一些光學儀器輔助，讓我們可以看到更小的細菌、木頭上的紋路，&lt;strong>很抱歉，這些都還是巨觀，因為你還是看不到這些東西是由一粒粒分子構成的&lt;/strong>，你也沒辦法看見空氣中有氧分子和氮分子悠閒自在地作飛來飛去。&lt;/p>
&lt;h2 id="微觀">微觀&lt;/h2>
&lt;p>微觀，簡單說起來，就是從&lt;strong>原子或分子&lt;/strong>層面看。&lt;/p>
&lt;p>主要是在十九世紀至今才開始慢慢興盛，因為古典電磁學和其他各種學問的發展，科學家才能想辦法用實驗和計算的方式，慢慢探索我們看不到的世界。微觀下的世界，有時候跟牛頓直接看到的巨觀世界會不太符合，因此才有所謂量子理論的發展。&lt;/p>
&lt;p>&lt;strong>想像我們拿著刀子切蛋糕，蛋糕似乎可以切多小就切多小，但是總有一天我們會把蛋糕切到只剩一顆粒子，不能再分割。&lt;/strong>&lt;/p>
&lt;p>量子的概念就是把這種想法推廣。&lt;/p>
&lt;h2 id="巨觀是微觀的統計結果">巨觀是微觀的統計結果&lt;/h2>
&lt;p>雖然微觀世界可能和巨觀世界有些差異，例如說，巨觀世界主要使用牛頓力學，但在微觀下必須使用量子力學。但是如果我們&lt;strong>在微觀世界看到的很多事情用統計的方式統合起來，那就會得到巨觀下看到的結果。&lt;/strong>&lt;/p>
&lt;p>物理學上的例子，就是統計物理可以利用微觀的想法，由下而上（Bottom-Up）建構出和熱力學從巨觀觀察，由上而下（Top-Down）建立的理論有相同的結果。&lt;/p>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;ul>
&lt;li>I. N. Levine, Quantum Chemistry&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>公斤、公斤重與牛頓的差別</title><link>https://dwye.dev/post/kg-kgw-n/</link><pubDate>Mon, 17 Nov 2014 00:50:40 +0800</pubDate><guid>https://dwye.dev/post/kg-kgw-n/</guid><description>
&lt;p>這是&lt;a href="https://dwye.dev/highschool-physics">基礎物理補充文章&lt;/a>的一部分。&lt;/p>
&lt;hr>
&lt;p>很多人都有類似方面的問題，就一次寫清楚&lt;/p>
&lt;h2 id="日常生活">日常生活&lt;/h2>
&lt;p>在日常生活裡，重量和質量是差不多的（都在地表）&lt;br>
公斤這個單位因此可以在兩者之間混用&lt;br>
「小明的體重（重量）是 60 公斤 (kg)」&lt;br>
這句話是沒有問題的&lt;/p>
&lt;h2 id="物理">物理&lt;/h2>
&lt;p>物理裡面，重量跟質量是不同的東西&lt;br>
因此必須先幫它們下個比較精確的定義（至少於高中範圍可以通用）&lt;/p>
&lt;h3 id="質量--m-">質量 $ (m) $&lt;/h3>
&lt;ul>
&lt;li>物體本身具有的本性，單位為公斤 $ (kg) $&lt;/li>
&lt;li>和當地重力加速度無關&lt;/li>
&lt;/ul>
&lt;h3 id="重量--w-">重量 $ (W) $&lt;/h3>
&lt;ul>
&lt;li>物體所受的萬有引力，單位為公斤重 $ (kgw) $、牛頓 $ (N) $&lt;/li>
&lt;li>和當地重力加速度有關&lt;/li>
&lt;/ul>
&lt;p>重量 = 重力 = 物體所受之引力&lt;br>
所以可以說重量是一種力&lt;br>
重量與質量的關係為&lt;br>
$$ W = m \times g $$&lt;br>
可以和牛頓第二運動定律做比較&lt;br>
$$ F = m \times a $$&lt;br>
重力加速度 $(g)$ 對應到加速度 $(a)$&lt;br>
重量 $(W)$ 對應到力 $(F)$&lt;br>
所以重量的國際標準單位和力一樣，是牛頓$(N)$&lt;br>
但方便起見，我們另外定義在地表質量 $1kg$ 的物體的重量為 $1kgw$&lt;/p>
&lt;h3 id="當-地表重力加速度--g--98-ms2-">當 地表重力加速度 $ g =\ 9.8\ m/s^2 $&lt;/h3>
&lt;ul>
&lt;li>質量 $ 1\ kg $ 的物體 重量 $ 1\ kgw $ 或 $ W = mg = 1 \times 9.8 = 9.8 N $&lt;/li>
&lt;li>所以 $ 1\ kgw = 9.8\ N $&lt;/li>
&lt;/ul>
&lt;h3 id="當-地表重力加速度近似為-g--10-ms2-">當 地表重力加速度近似為 $g =\ 10\ m/s^2 $&lt;/h3>
&lt;ul>
&lt;li>質量 $ 1\ kg $ 的物體 重量 $ 1\ kgw $ 或 $ W = mg = 1 \times 10 = 10 \ N$&lt;/li>
&lt;li>所以 $ 1\ kgw = 10\ N $&lt;/li>
&lt;/ul>
&lt;h3 id="註">註&lt;/h3>
&lt;p>就算不是地表的地方&lt;br>
公斤重和牛頓的單位轉換，仍必須以地表重力加速度去看&lt;br>
因為定義是在地表上的重量&lt;/p>
&lt;h2 id="所以我們必須說">所以我們必須說&lt;/h2>
&lt;ul>
&lt;li>「小明的質量是 60 公斤」（在任何地方都成立）&lt;/li>
&lt;/ul>
&lt;h3 id="在地表重力加速度-g--10-ms2--時">在地表重力加速度 $g = 10\ m/s^2 $ 時&lt;/h3>
&lt;ul>
&lt;li>「小明在地表的重量是 60 公斤重」&lt;/li>
&lt;li>「小明在地表的重量是 600 牛頓」&lt;/li>
&lt;/ul>
&lt;h3 id="在某個-g--5-ms2-地球表面的一半-的行星">在某個 $g = 5\ m/s^2 $(地球表面的一半) 的行星&lt;/h3>
&lt;ul>
&lt;li>$ W = mg = 60 \times 5 = 300 $ ( $ F = ma $ )&lt;br>
「小明在該行星的重量是 300 牛頓」&lt;/li>
&lt;li>$ 300\ N = 30\ kgw $ (單位轉換)&lt;br>
「小明在該行星的重量是 30 公斤重」&lt;/li>
&lt;/ul>
&lt;h3 id="或是在太空中沒有重力加速度--g--0--">或是在太空中，沒有重力加速度( $ g = 0 $ )&lt;/h3>
&lt;ul>
&lt;li>$ W = mg = 60 \times 0 = 0 $&lt;br>
「小明在太空中的重量是 0 」&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>以上，希望能解決大家的困擾&lt;br>
有問題歡迎提出&lt;br>
也歡迎參照 PTT &lt;a href="//www.ptt.cc/bbs/SENIORHIGH/M.1416156646.A.713.html">原文&lt;/a>&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>在補習班的日子</title><link>https://dwye.dev/post/20140828_164254/</link><pubDate>Thu, 28 Aug 2014 16:42:54 +0800</pubDate><guid>https://dwye.dev/post/20140828_164254/</guid><description>
&lt;p>這是篇公開心得，所以避開了所有人名以及公司名，有必要者用綽號稱之。&lt;/p>
&lt;h2 id="緣起">緣起&lt;/h2>
&lt;p>2012年11月，第一次到13樓的辦公室考試，那邊的人說，考卷就在桌上，寫完考卷和資料之後就可以走了，之後靜待通知。&lt;/p>
&lt;p>所有事情的發生，都有它的背景以及緣起。大學時代決定邁向經濟獨立目標的我，四處尋找工作機會。因緣際會下有了第一個家教，但是總覺得還不夠，於是就問了原本已在補習班工作的高中學長D大，決定先到補習班累積經驗。&lt;/p>
&lt;h2 id="始">始&lt;/h2>
&lt;p>走出補習班，我立刻衝到斜對角街上的墊腳石書店，走上二樓，找到93年指考試題的詳解。因為有事先練習歷屆試題，憑印象對完答案發現只錯了一題，應該是能成功錄取了！&lt;/p>
&lt;p>第一次上班是學長帶我，那時候身為菜鳥，什麼都不知道，連解個題都會被學長看不下去喊卡。一開始只是到補習班寫詳解，有空學長會讓我試著解一些題目給學生看，慢慢的從同事的身上學習，從學生的反應再調整，約兩個禮拜之後，我也開始有自己的時段，並且放上線上預約。&lt;/p>
&lt;p>這家補習班的制度甚完備，至少解題輔導方面做得很好，學生可以預先在網路上預約我們，只要在指定的時間來補習班一趟就能有專人為自己解惑，省去現場排隊的困擾，解題時間也夠長。若是不幸每個老師被都預約滿了，也能到現場直接抽號碼排隊，雖然就失去了預約的好處，但補習班也有提供足夠的等待區座位，有桌椅以及沙發，算是也有個地方讓自己念書而不至於讓時間白白流失。&lt;/p>
&lt;p>D大和我們的主管似乎還蠻要好的，我也和他聊過幾次天。我覺得這裡和我以前高中補習的地方比起來，似乎少了一點商業氣息，而多了一些真正為學生著想的感覺。這裡的學生大多都很喜歡這裡；所謂的名師願意在下課後為學生多留一個小時以上幫學生解答上課疑惑；我們兼職的也是抱著開心的心情來上班，彼此之間感情好；補習班也不會像少數同業（我高中補的那家很誇張）四處公開攻擊他人，我覺得，真是來到一個對的地方。&lt;/p>
&lt;h2 id="適應">適應&lt;/h2>
&lt;p>每到學測或指考將近，補習班因為有開衝刺班級，所以解題的需求就會大增，為了讓學生的疑問都能夠及時得到解答，所以我們也必須在學期末加班。大多數的解題老師都是大學生，所以我們就勢必得學習在工作與課業的時間分配上達到均衡，避免讓原本就很爆炸的期末更加爆走。&lt;/p>
&lt;p>第一年，是平淡的度過，也許是我的解題實力還沒有很夠，或是學生沒有特別注意到我，上班的時候常常閒閒的，每次都帶書去讀還能領薪水也是不錯，不像其他熱門的同事基本上都是從上班解到下班。不過也是有認識一些學生，還有在隨班的時候念普物念到一半有學生主動XU我。有時候有人請假，就必須找人「代班」，隨著上過的班越多，有時候除了自己的時段也能認識一些來代班的人，或是藉由代班和其他時段的人有所互動。也有一次在幫其他人代班的時候，有學生問我是在哪一天的班，我說是禮拜五晚上，但是那個學生禮拜五晚上要補別的科目，真是太為他感到可惜了。不過會被這樣問，應該也是覺得我解的不錯吧。&lt;/p>
&lt;p>在我進來補習班的一個禮拜後，馬上就有另外一位新人進來，但是就年紀來說他可是大我整整四個年級，不過看起來很像和我同年的，直到我問到他讀哪裡時才嚇到 XD。後來我們常常一起接同一個時段，所以變得比較熟，常常互相交流神魔，這是第二年的事情了。&lt;/p>
&lt;h2 id="上手">上手&lt;/h2>
&lt;p>第二年我接了最熱門的禮拜六下午時段，不知道是時段加持還是實力提升，開始了週週爆滿的上班生活。每個禮拜都是中午12點打卡，先幫早上的班解題，然後買午餐吃午餐，下午一點開始解預約，一路解到五點半，甚至常常加班到六點。工作最晚的一次，是加班打到七點半的卡，那次是段考前吧，剛好我沒事，想說學生都辛苦來一趟了沒有解決完他問題實在對不起他們，於是就加了兩個小時的班。&lt;/p>
&lt;p>因為預約制度的關係，有時候系統一開放，學生就會立刻登入搶走自己最常預約的老師。這種對自己很死忠的學生，我們常常私下稱其為「固定粉絲」，簡單說起來就是每周上班都會看到他。通常固定粉絲都和自己很好，所以解起題來也是氣氛輕鬆，偶爾也能聊個天關心一下學生的近況，算是忙碌中的一點小休閒。對了，補習班的規定白紙黑字寫說不能讓學生知道自己的電話，可能是怕我們和學生私下聯絡甚至變成家教搶走補習班的生意吧，或是發生所謂禁忌的師生戀情（我還真的看過&amp;hellip;&amp;hellip;），不過，現在早就已經不是電話時代了，所以&amp;hellip;&amp;hellip;.。&lt;/p>
&lt;p>我也常常每個禮拜到補習班看到的都是固定的人。在補習班碰到的學生不是自己選擇的，所以學生的程度資質也很不一，我在那時候的家教學生都是附中的班上前幾名，他們領悟力很好都很好教，但是補習班學生有的領悟力比較沒有那麼好，就得放慢速度，多點耐心，講得仔細一點，還要靠經驗找出他們的盲點他們才能聽懂。這也是累積我的家教實力的一大好機會，也是現在我每次試教都能成功的原因：因為我在補習班碰過了各式各樣的學生，臨場能力大增，所以大概都能找出學生的問題並且對症下藥解決之，也因此能得到學生和家長的信賴與喜愛。&lt;/p>
&lt;p>講點有趣的事情，有一個學生，被我們物理解題封為「解題老師殺手」，每次他來，都是帶著一整疊的問題，以及燦爛的笑容。當你在預約名單的最後看到這位殺手，你就知道今天要加班了。當然也有人會狠下心直接準時走人，但我的個性常常很容易被盧，於是乎他後來也很常來找我，多了一位粉絲，不知道是好事還是壞事。&lt;/p>
&lt;p>除了解題之外，有的時候我們還要幫補習班寫詳解，也就是我們俗稱的「寫稿」，主要是每年的段考試題。若是在上班時間，有時候上頭就會丟一些稿，讓我們在空閒時間寫，而這是算在上班的內容當中，所以不另外計薪。但通常我們都是被預約滿滿，沒什麼時間寫稿，更何況還要常常滿段解現場，所以也有把稿外帶回家寫的做法。因為對於解題熟悉，寫稿反而是我覺得在補習班ＣＰ值最高的，但不知道為什麼，已經一整個學期沒有稿可以寫了，也許是有另外請人寫吧。&lt;/p>
&lt;p>有時候空閒時我會到班上去聽老師上課，我們的老師並不算很大的高中物理權威，但講起課來也是有自己的一套風格，喜歡畫自己自創的人物「狗兔」來替代火柴人，上課也常常用語氣及音調變化來讓課程聽起來不要那麼呆版，當然也有偶爾誇張的言詞抓住學生的注意力，或是自身的經驗分享來勉勵學生。有時候補教老師的教法我實在不是很認同，但是也是讓我多認識了一些不一樣的人對物理的不同看法。解題上，雖然我有自己的一套方法，但是為了和老師配合，我也會刻意學習老師在班上的解法，並在解題時問學生要聽哪一種。雖然我不苟同，但多會一種方法，並不是不好。&lt;/p>
&lt;p>另外，老師有時候會私下約我們出去吃飯，可能是當作彌補我們沒有像數學部一樣可以吃尾牙吧。每次聚餐吃的都還蠻高級的，蠻符合老師「省小錢，花大錢」的思維。&lt;/p>
&lt;h2 id="轉折">轉折&lt;/h2>
&lt;p>在補習班解題並不像家教，我們其實不必對學生的成績負責，也是補習班時薪低上很多的合理原因之一吧？只是我們終究不是解題機器，和固定粉絲熟了之後，也是會關心他們的成績，會問他們在班上的排名，會好奇他們學測考得如荷，甚至是上了大學何去何從。也因此有時候當時常會找自己的學生考得沒有很理想的時候，其實也會偷偷跟著難過，就像是家教學生一樣。這反而是補習班矛盾的地方吧？當然也有碰過學生在畢業之後約老師出來吃飯聊天甚至出來玩的情況，反正畢業之後大家都是大學生了，也不受到補習班的規範了。&lt;/p>
&lt;p>第二年也有新的學弟妹進來解題，變成我來負責帶菜鳥了，換個角度看他們，好像當初進來時學長看自己的感覺一樣，頓時覺得自己老了好幾歲，不過也因為自己的成長而感到興奮。在這裡待了第二年之後，認識的人變得很多，常常很自在的上班，偶爾空閒時也能和其他人聊天互話家常。有時候會私下揪出來吃飯，也有因為是同學校的可以交流選課與社團經驗等等，或是聊到學術上的話題。有時候也會聊到一點上頭認為比較禁忌的話題：補習班的八卦。&lt;/p>
&lt;p>在這裡待久了，會漸漸感受到其實一切並沒有那麼單純，有的時候還是會有一些暗鬥的傳聞出來，也有一些老師的負面八卦，不過或許是杞人憂天，又或是有人故意散播謠言，誰知道呢？知道有人對主管新策的不滿，有人因為太特異的行為屢勸不聽被解雇了，或是有同事之間出現了感情糾紛，也會對自己工作的地方多了一點眼界，但整體而言這裡還是我認為不錯的工作環境，對學生來說也是不錯的補習班。總言之，有八卦的地方，就是交流互動多的地方，也是我認為的好地方。&lt;/p>
&lt;p>光明的背後一定有陰影，事情有正面一定有反面。因為我工作的這家補習班不算小，所以有時候必須到其他的分部排班，其中板橋離我們每個人的生活圈都很遠，一開始補習班還有給我們車馬費，但後來就取消了。每學期我們都要推派倒楣鬼過去，搭捷運過去要40分鐘，真的不是很方便，還好我從頭到尾都沒有排過那裏的班。&lt;/p>
&lt;p>最讓我挫折的一件事情，也是唯一我在這邊挫折的一件事，就是薪水。其實打從第二年下半年以來，就一直有著是否要辭退的想法。一是我實力夠了，實在不需要繼續在這累積經歷；二就是這段要提到的薪水。前面有提到補習班有招收衝刺班，所以期末總是需要我們加班幫忙。但是我因為有社團有家教，本身就是比較忙的，實在難以空出很多時間，有時候期末考週多接個三、四段班就是極限了。總是有明言暗語中提點著我們，衝刺班能夠排的段數越多，越能代表你對補習班的忠心程度，因此也是薪水調升的一項主要依據中。我認為，我的實力不比其他人差，年資也比新進的學弟妹多上一年，但是就因此我的薪水永遠都是起薪，相較同期進來的其他人來說實在不太服氣，老實說對於有經濟壓力的我而言，這也是最後選擇離開的理由之一。&lt;/p>
&lt;p>更何況，我的一位高中好友，在別家補習班已經做到上台的境界了，當然這是制度的差異，然而我還年輕，還有往上爬的野心，實在不想如此禁錮自己。只是諒在自己在補習班已經有一定人脈，每次上班也蠻開心的，更何況每週都有學生等著要問我問題呢，實在不忍心拋下任何人，就先把這件事情擱著。&lt;/p>
&lt;p>&lt;strong>我是為了學生而努力，而不是為補習班而努力&lt;/strong>。著這樣的心情，我又多做了一段時間。&lt;/p>
&lt;p>有時候，學生也會在畢業之後私下給我們一點回饋，像是我曾經收過學生送的蛋糕與食物等等，也有人收過學生的卡片，還有與學生合照等等。其實有時候覺得他們能夠得到幫助而滿意地感謝我們，是身為解題老師最好的回報。&lt;/p>
&lt;h2 id="曲終">曲終&lt;/h2>
&lt;p>宴會過後，人終將散去。進來補習班打工，總有離開的一天。趁著暑假，常問我的學生都考上了大學之後，利用這個時機離開，是對一切都傷害最小的。當經驗累積到一定程度，當實力培養到一個境界，我在這邊能學的我敢說至少學到了八成，剩下的我到外面也能學更多。就像我高中補數學一樣，只是補個滋味，知道了老師教法和讀書方法，我就不繼續報名了。選擇是在一個晚上之間決定的，至少這樣自行完美的離去，總比哪天不小心犯錯被辭退，或是哪天和誰發生爭執而自行引退還要好。&lt;/p>
&lt;p>這兩年，謝謝一切：謝謝帶領過我的兩位主管；謝謝數位同是解物理的同事們一起分擔許多的學生以及麻煩；謝謝老師帶領整個補習班的物理團隊；謝謝和我一起上過班的其他同事，能夠和我聊天交流，認識你們真好；謝謝所有問我的學生，能夠捧我的場，祝你們有美好的大學生活，還沒考試的能考出不錯的成績；最後的最後，謝謝D大，讓我有機會接觸這裡。這裡很好，是我自己選擇了離開，也祝福所有還在工作的人，繼續加油，讓學生能夠考上自己理想的志願。&lt;/p>
&lt;p>現在是2014年8月。&lt;/p>
&lt;p>有時候講到情緒激動處，雖沒有臨表涕泣，但仍會不知所云，請多包涵 XD&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>估算法</title><link>https://dwye.dev/post/%E4%BC%B0%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 20 Aug 2014 17:28:39 +0800</pubDate><guid>https://dwye.dev/post/%E4%BC%B0%E7%AE%97%E6%B3%95/</guid><description>
&lt;p>雖然大多數考題數字皆有設計過，但若選項間數字差異很大，懂得一些估算技巧，可以增加答題速度。以下面這題為例：(92學測補考)&lt;/p>
&lt;blockquote>
&lt;p>南、北極的冰帽如果真的全部融化，粗略預估全球海平面最可能會上升多少高度？&lt;br>
（提示：全球海洋的平均深度約為 $4000\ \mathrm{m}$；南極大陸的冰層厚度約 $2.2\ \mathrm{km}$。面積約為 $13,000,000\ \mathrm{km}^2$；格林蘭的面積約 $1,700,000\ \mathrm{km}^2$，冰層厚度約 $1.5\ \mathrm{km}$；地球半徑約 $6400\ \mathrm{km}$）&lt;br>
(A) 60~80 毫米 (B) 60~80 公分 (C) 60~80 公尺 (D) 600~800 公尺 (E) 6~8 公里&lt;/p>
&lt;/blockquote>
&lt;h2 id="列出算式">列出算式：&lt;/h2>
&lt;p>善用科學記號，有助於我們接下來要進行的簡化！（算式內單位皆統一為公斤）&lt;br>
$$&lt;br>
上升高度 = \frac{體積增加}{海洋面積} = \frac{2.2 \times 1.3 \times 10^7 + 1.5 \times 1.7 \times 10^6}{4 \pi \times (6.4 \times 10^3)^2 \times 0.7}&lt;br>
$$&lt;/p>
&lt;h2 id="太難算了吧">太難算了吧！&lt;/h2>
&lt;p>這麼一長串的算式，基本上科技進步的現代，都是丟給計算機之神casio 991ES解決。然而，考場如戰場，敲計算機其實也是需要時間的，更何況這個戰場（學測）還不給帶計算機。因此，正是估算法大顯神威的時候了。&lt;/p>
&lt;h2 id="估算法登場">估算法登場！&lt;/h2>
&lt;p>估算法三大原則如下：&lt;/p>
&lt;ul>
&lt;li>先算次方&lt;/li>
&lt;li>加減先算，乘除要約&lt;/li>
&lt;li>一個變大，一個變小&lt;/li>
&lt;/ul>
&lt;h3 id="先算次方">先算次方&lt;/h3>
&lt;p>先執行第一原則，我們把科學記號的 10 的次方全部拆出來，上述算式可以拆成：&lt;br>
$$&lt;br>
\frac{2.2 \times 1.3 + 1.5 \times 1.7 \times 0.1}{4 \pi \times 6.4^2 \times 0.7} \times&lt;br>
\frac{10^7}{10^{3 \times 2}} =&lt;br>
\frac{2.2 \times 1.3 + 1.5 \times 1.7 \times 0.1}{4 \pi \times 6.4^2 \times 0.7} \times 10&lt;br>
$$&lt;br>
其實大部分的題目，做到這裡，答案就呼之欲出了。&lt;/p>
&lt;p>不過這題要注意，各選項位數並沒有差上很多，且前項分子可能比分母大一個數量級，所以分數部分也要進一步估算，通常是需要一點經驗的：&lt;/p>
&lt;h3 id="進一步估算">進一步估算&lt;/h3>
&lt;p>估算的時候，別忘了使用$\approx$（或是台灣國高中以下常用$\fallingdotseq$）代表大約等於喔。&lt;/p>
&lt;p>按照第二原則，先處理加減，第一步將明顯小了十倍的 $1.5 \times 1.7 \times 0.1$ 直接拔掉：&lt;/p>
&lt;p>$$&lt;br>
\frac{2.2 \times 1.3 + 1.5 \times 1.7 \times 0.1}{4 \pi \times 6.4^2 \times 0.7} \approx&lt;br>
\frac{2.2 \times 1.3}{4 \pi \times 6.4^2 \times 0.7}&lt;br>
$$&lt;/p>
&lt;p>接著利用第三原則將 $2.2 \times 1.3$ 變成 $2.0 \times 1.5$：&lt;/p>
&lt;p>$$&lt;br>
\frac{2.2 \times 1.3}{4 \pi \times 6.4^2 \times 0.7}\approx&lt;br>
\frac{2.0 \times 1.5}{4 \pi \times 6.4^2 \times 0.7}&lt;br>
= \frac{3}{4 \pi \times 6.4^2 \times 0.7}&lt;br>
$$&lt;/p>
&lt;p>最後將 3 和 $\pi\ (\approx 3.14)$ 約掉。&lt;/p>
&lt;p>$$&lt;br>
\frac{3}{4 \pi \times 6.4^2 \times 0.7} \approx \frac{1}{4 \times 6.4^2 \times 0.7}&lt;br>
$$&lt;/p>
&lt;p>接下來的計算就簡單了，可以直接硬算。但這篇我們就堅持估算法到底，當作估算法的練習吧！&lt;/p>
&lt;p>為了方便起見，這裡可能要做暴力一點的估算，直接拿整數近似，一樣用到第三原則，把 $6.4^2 \times 0.7$ 變成 $6^2 \times 1$：&lt;br>
$$&lt;br>
\frac{1}{4 \times 6.4^2 \times 0.7} \approx&lt;br>
\frac{1}{4 \times 6^2 \times 1} =&lt;br>
\frac{1}{4 \times 36} =&lt;br>
\frac{1}{144} =&lt;br>
\frac{1000}{144} \times 10^{-3}&lt;br>
$$&lt;/p>
&lt;p>最後回到第一原則，把次方拿出來。&lt;/p>
&lt;h3 id="整理結果">整理結果&lt;/h3>
&lt;p>綜合第一步拿到的 10 的一次方，可以知道答案約是：&lt;br>
$$&lt;br>
\frac{1000}{144} \times 10^{-2}\ \mathrm{km}&lt;br>
$$&lt;/p>
&lt;p>前面那項大約為 7（其實選項也告訴我們，是在 6 到 8 之間），所以答案會落在 $7 \times 10^{-2}\ \mathrm{km}$ 附近，也就是 $70\ \mathrm{m}$ 左右，因此答案是(C)。&lt;/p>
&lt;p>過成看起來有些冗長，但其實精熟起來速度是很快的，甚至在別人下筆列橫式計算時，你已經秒殺這題了。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>補習那些小事</title><link>https://dwye.dev/post/20140804_111118/</link><pubDate>Mon, 04 Aug 2014 11:11:18 +0800</pubDate><guid>https://dwye.dev/post/20140804_111118/</guid><description>
&lt;p>一句話，補習&lt;strong>千萬別盲補&lt;/strong>&lt;/p>
&lt;p>高中教育中，若是一間師資正常的高中，理想上來看，學校教學基本上是足夠的。不過剛剛說的是「理想上」，若是真的不幸，在眾多老師裡面碰到了說話比較玄妙的老師，或是不幸地學校裡面沒有足夠的老師導致最後臨時找來一個沒什麼該科目教學經驗的，這時候再考慮以下補救之道：&lt;/p>
&lt;h2 id="自修">自修&lt;/h2>
&lt;p>怎麼自修？應該用什麼教材來自修？自己自修讀得來嗎？這些都是決定自修之前必須評估的問題。以我看來，若不是對成績要求很大，基本上課本、習作、講義等組合應該夠用，甚至可能連講義都不需要。如果對成績有些要求，或是想更進一步學更多，可以買市面上的自修。像我在自修高中生物時，就是用翰林版的自修，個人認為效果不錯。&lt;/p>
&lt;p>自修的時候，通常會&lt;strong>建議進度要比老師超前&lt;/strong>這樣就算老師教的不怎麼好，在上到相關的進度時，至少心中有個譜，也會比較容易跟上老師的腳步，理解老師所教。&lt;br>
當然，如果你那個科目很厲害，完全不用依靠老師，也可以拿上課時間來自習，無視老師教學，不過如果到時候考不好，下場請自負喔。&lt;/p>
&lt;h2 id="補習">補習&lt;/h2>
&lt;p>如果覺得這一科不知道怎麼讀，或是已經自修過，發現自己並不是讀得很通，考試很危險，這時候再來考慮是不是要多上一次課。補習班的選擇這裡不多談，不過建議一定要試聽過，然後找到自己可以適應的老師，不管上課有什麼花招，老師觀念講得好是比較重要的。補習之後，還是要騰出時間自己來消化上課內容，&lt;strong>很多東西不自己做一遍，是很難吸收進去的&lt;/strong>在上課弄懂以後，要把東西變成自己的，考試才能進步。也因此，不建議花太多時間在補習上面，因為這樣自己念書的時間就會被壓縮太多。&lt;/p>
&lt;h2 id="家教">家教&lt;/h2>
&lt;p>明明就有補習班存在，為什麼家教還有生存的空間？我一直認為家教是一個很特殊的存在，一直到大學我才接觸到這個行業。家教的特殊性質在於「&lt;strong>客製化&lt;/strong>，無論是學校，甚至是補習班，常常都是大班教學，無法顧及每個人，這時候若是有一個人可以專門帶領自己，解決難題，為自己設計一套適合的課程及規劃，也不失為一個好的選擇。&lt;/p>
&lt;h2 id="其他資源">其他資源&lt;/h2>
&lt;p>如果你有一個好爸爸（誤XD），或是其他家人親戚兄弟姊妹懂得你不會的科目，多少可以向他們求助一些。如果你認識社團學長姐，或是班上有功課不錯的人，都可以向他們請教，教學的慾望相信每個人或多或少都有一些，你可以好好利用。&lt;/p>
&lt;p>綜合以上，補習並不是唯一選擇。&lt;/p>
&lt;h2 id="補習學什麼">補習學什麼？&lt;/h2>
&lt;p>名師很多，總能把高中知識講的天花亂墜，什麼考題分析、趨勢猜測，題目分門別類，觀念總有獨門，秒殺速解、口訣速成，應有盡有。有時候補習班給了很多資源，可以就需要者使用之，不必全部拿來讀（像我當初補某家北車壽德大樓6樓補習班，就送了一堆書，他們大多還是全新，有些對於考試其實沒什麼助益，或是投資報酬率不夠。）這邊簡單列一下我們可以從補習班得到的資源：&lt;/p>
&lt;h2 id="課程">課程&lt;/h2>
&lt;p>來補習班最重要的就是上課，把自己不懂的地方聽懂，知道一些解題技巧。這不多談。&lt;/p>
&lt;h2 id="講義與書籍">講義與書籍&lt;/h2>
&lt;p>可以參考一下，補習班講義為何要這樣編排，是這樣學習比較有效果嗎？裡面的題目也能當作練習，省去額外找題目的麻煩。補習班的額外送書有時候也是有實用的，像是我使用了補習班送的學測4000單，以及狄克生片語，少買了幾本書。&lt;/p>
&lt;h2 id="額外輔導">額外輔導&lt;/h2>
&lt;p>我的職業是輔導老師，就是專門在上課以外的時間幫學生解決學業上的疑惑，若是善用這項服務，也許可以幫自己節省一些念書時間，有點像是短時間的個人家教，不過通常品質沒那麼有保證（因為錢比較少&amp;hellip;）。對了，要適當的使用，別濫用，你不可能問題多到要每天見你的輔導老師。&lt;/p>
&lt;h2 id="學習方法">學習方法&lt;/h2>
&lt;p>這才是我認為最重要的，然而也是最少人能領悟到的。我高二時因為數學讀不來所以去補習，之後就因為領悟到適合自己的讀書方式所以離開了。在補習班裡面，你會知道哪些題目是你一定要會的，哪些公式背起來哪些不用（當然，前提是老師教法也要正確），看看老師強調哪裡，為什麼有些地方老師會跳過。甚至偶爾也可以跟老師小聊一下，在該科目教學那麼久，老師一定有自己的一套心得。&lt;/p>
&lt;h2 id="知識沒有速成">知識沒有速成&lt;/h2>
&lt;p>一分耕耘一分收穫，錯誤的耕耘方式，可以讓你得到經驗；正確的耕耘方式，可以讓你成功得到知識。補習班絕對不是拿來速成省時間用的，如果現在選擇速成，以後大考複習的時候就麻煩了。大考出題範圍廣、觀念多，難以速成，所以還是一步一腳印吧。&lt;strong>補習班，是拿來補個人的不足之處的&lt;/strong>&lt;/p>
&lt;h2 id="作讀書計畫">作讀書計畫&lt;/h2>
&lt;p>複習時，讀書計畫對於自己的方向來說其實頗重要，建議每個人都要有自己的讀書計畫，可以只有大綱，但是還是要有。對於每一科，依據自己的情況，選用不同的讀書方式與時間分配。我建議，真的不足的，再排補習；就算補習，還是要排該科讀書計畫。可以問補習班老師的意見，但是不要絕對聽從，&lt;strong>沒有什麼方式是適合每個人的&lt;/strong>就連我這篇文章也是，要抱著質疑的心態閱讀。&lt;/p>
&lt;h2 id="just-do-it">Just do it&lt;/h2>
&lt;p>對於是否補習感到迷惘？讀書計畫不知道要怎麼排？我覺得，與其浪費時間在那邊想破頭不知道該怎麼走，不如就衝一發吧。先試看看不補習可不可以，不行再換；先試看看用這樣的方式能不能念起來，不行再改。從暑假開始到學測，半年的準備期，說長不長，說短還真的不短，還是有一些容錯率的。不知道怎麼做的時候，記住這句話：&lt;strong>先做了再說，Just do it！&lt;/strong>&lt;/p>
&lt;h2 id="後記">後記&lt;/h2>
&lt;p>這篇是關於補習的，其實也都是個人看法啦。寫到最後有點像是念書教戰守則，不過我每次提筆要寫一篇關於念書的文章時，都寫不出來，所以只好就每個主題來寫了。對於全科班我不熟悉，所以不多加評論，但是還是建議不要補太多習。希望能或多或少幫助到一點人。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>學測自然科參考書推薦</title><link>https://dwye.dev/post/20140730_041700/</link><pubDate>Wed, 30 Jul 2014 04:17:00 +0800</pubDate><guid>https://dwye.dev/post/20140730_041700/</guid><description>
&lt;p>這陣子剛好幫家教學生挑書&lt;br>
又剛好碰到高中板友有問&lt;br>
所以趁機獨立出來一篇文章&lt;/p>
&lt;h2 id="挑選理由與方式">挑選理由與方式：&lt;/h2>
&lt;p>都是親自到書店看過&lt;br>
以學測範圍為主&lt;br>
盡量連社會組都適合使用&lt;br>
重點除了排版、內容編寫，還有選題&lt;/p>
&lt;h2 id="物理">物理：&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://www.sanmin.com.tw/product/index/005239583">全華－終極解碼物理學測複習&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="化學">化學：&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://www.pcstore.com.tw/ibookhouse/M14417912.htm">康寧泰順－引航高中化學總複習(學測篇)&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.tameng.com.tw/front/bin/ptdetail.phtml?Part=NY06385&amp;Rcg=519">h南一－學測廣角鏡 化學&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="生物">生物：&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://www.wunanbooks.com.tw/product/9789862242179">建興－高中學測總複習上上籤 生物&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.pcstore.com.tw/ibookhouse/M10835609.htm">華逵－邏輯式學測生物總複習&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="地科">地科：&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="http://www.go8.com.tw/index.php?route=product/product&amp;path=&amp;product_id=4419">龍騰－地球科學嘿皮go&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.m.sanmin.com.tw/Product/index/99b155b8l109Z39Q105N66S107z125JIJgPSg191OzY">華逵－滿級分學測地球科學嘿皮書&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>(別問為什麼物理只有一本XD)&lt;br>
更多關於參考書，請見&lt;a href="../20140726_055506">此篇&lt;/a>&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>【好站分享】邱博文物理線上資源</title><link>https://dwye.dev/post/20140729_060106/</link><pubDate>Tue, 29 Jul 2014 06:01:06 +0800</pubDate><guid>https://dwye.dev/post/20140729_060106/</guid><description>
&lt;p>如果學物理碰到一個觀念，一直無法想像怎麼辦？&lt;br>
要怎麼從死板板的圖片變成順暢的動畫在腦中播放？&lt;br>
在這個數位化的時代&lt;br>
其實網路上已經有很多資源可以幫助我們學習&lt;br>
這邊要分享的就是其中之一&lt;/p>
&lt;p>邱博文老師，是現在台北的高中物理補教界名師&lt;br>
除了曾在儒林、台大等補習班教書之外&lt;br>
也擁有自己的公司、自己的補習班&lt;br>
以及遠大的個人教學理念與抱負&lt;br>
當然他也有建立很多的物理教學動畫&lt;br>
其中包含歷屆物理試題解題影片、各章重點教學影片、物理3D模擬動畫&lt;br>
好資源，不用嗎&lt;br>
以下附上 youtube 網址&lt;/p>
&lt;p>&lt;a href="http://www.youtube.com/user/feynmantech/featured">http://www.youtube.com/user/feynmantech/featured&lt;/a>&lt;/p>
&lt;p>另外，這是費曼因公司的網站&lt;br>
下載專區也有一些資源可以使用&lt;br>
主要有用的集中在「3.學習資源」裡&lt;/p>
&lt;p>&lt;a href="http://www.e-physics.net/download.html">http://www.e-physics.net/download.html&lt;/a>&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>【分享】費曼物理學講義</title><link>https://dwye.dev/post/20140728_074313/</link><pubDate>Mon, 28 Jul 2014 07:43:13 +0800</pubDate><guid>https://dwye.dev/post/20140728_074313/</guid><description>
&lt;p>偉大的物理學家，也幾乎是近世普物課程之始祖：費曼(Feynman)，在他的教學生涯中，有一本影響後世甚大的書：「費曼物理學講義(The Feynman Lectures on Physics)」。這本書保留了費曼當初上課時的原汁原味，也繼承了費曼一向優秀的口才與講解能力，號稱是最好理解也最深入物理內涵的一套講義。甚至有些教授以及物理學界人物也稱，看過了費曼物理學講義之後，才懂得某個領域真正的內涵。&lt;/p>
&lt;p>不論是英文版，或是簡體中文版，網路上都能找到免費的講義全文。不過繁體中文版較奇特，現在由天下文化出版，包裝成科普書似的，而且還賣得挺貴的。這實在不是一個好現象，一來這書根本不科普，已經可以當作正式教科書了。況且，原版都已經免費上架，實在沒什麼道理讓翻譯版本繼續賺錢。可惜我尚在求學階段，自己也算繁忙，無法負起重新翻譯並將之免費上網的重任，只希望近年能有人肯為這件事出一份力，這麼好的東西實在不應該藏私。不然，這就會成為我以後的夢想：翻譯一套簡單易懂的費曼物理學講義，並且放在這個blog。&lt;/p>
&lt;p>扯遠了，先貼網址吧。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="http://www.feynmanlectures.caltech.edu/">英文版網頁&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.dropbox.com/sh/d86ccno4yvos2js/AADGUnfvV39u0MIXnpUpFKXsa">簡體中文版下載處&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://zh.wikipedia.org/wiki/%E8%B4%B9%E6%9B%BC%E7%89%A9%E7%90%86%E5%AD%A6%E8%AE%B2%E4%B9%89">維基百科也有更多介紹&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="聲明">聲明&lt;/h3>
&lt;p>根據我對翻譯權的了解，作者為非本國人的情況，在台灣不具有翻譯權，因此散佈簡體中文版的翻譯應該是沒有違反法律。若有版權相關問題，請聯絡我，我會立刻刪除，謝謝。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>我流挑參考書的方法</title><link>https://dwye.dev/post/20140726_055506/</link><pubDate>Sat, 26 Jul 2014 05:55:06 +0800</pubDate><guid>https://dwye.dev/post/20140726_055506/</guid><description>
&lt;p>時間過得很快，課綱改了兩次，原本的文章參考書推薦部分似乎也不合時宜了，因此就順便把這篇文修改一下，希望有緣看到的人皆能受惠。&lt;/p>
&lt;p>市面上參考書林林總總，競爭非常激烈，而且由於賺頭不小，越來越多老師和出版社加入戰場。一般來說，學校老師都會推薦或是強制我們購買某一本參考書，而網路上也有不少推薦文（如：&lt;a href="http://stu60912.pixnet.net/blog/post/46054601">Treak參考書推薦&lt;/a>）。不過我是個眼見為憑的人，寧願自己去書店花個一兩小時，自己挑選自己中意的參考書。&lt;/p>
&lt;p>對我來說，課本的功能只是查詢用，而複習時最重要的筆記等都會集中在第一階段地毯式複習的參考書（詳見下文）。換句話講，我是採用以參考書為中心進行複習的風格，所以參考書的挑選此時變得格外重要。&lt;/p>
&lt;p>其中我主要會參考的點有&lt;/p>
&lt;h2 id="一印刷與排版">一、印刷與排版&lt;/h2>
&lt;p>每個人都有每個人習慣的版面，如果一本書的版面第一眼就讓自己看起來很不舒服，更不用談連續鑽研它好幾個月了。還有彩色這部分，一般來說生物、地理這兩科我會偏好選彩色講義，不過彩色上色也要上的好，不然太花了看久眼睛也會很痛，同時也比較難突顯出自己用筆做的重點。&lt;/p>
&lt;h2 id="二文字敘述">二、文字敘述&lt;/h2>
&lt;p>有分「條列式」和「文章式」兩種，因為課本屬於後者，我比較偏好前者，同時重點式比較吸引人去看。當然其實大部分的參考書都是兩種綜合的只是比例不同。&lt;/p>
&lt;h2 id="三例題解說與詳解">三、例題解說與詳解&lt;/h2>
&lt;p>一般來說我會選擇有逐題詳解的，因為我覺得這代表作者的用心程度，不過詳解內容還是稍微看一下，因為有的參考書的詳解只是重複答案的內容（ex:(A)(C)(D)正確。），而詳解多也不一定是好事，因為這樣你要找很久才能找到解題關鍵&amp;hellip;&amp;hellip;對我來說，最好的詳解應該是要「快、狠、準」的。&lt;/p>
&lt;p>至於有沒有例題解說我倒不太在意，因為我都是一樣把解說遮住當一般的練習題練習。&lt;/p>
&lt;h2 id="四編寫內容">四、編寫內容&lt;/h2>
&lt;p>大考考的不外乎是基礎知識跟常識，尤其學測更偏向這個方面。所以說，太刁鑽的題目、敘述基本上都免了，以多講觀念、多做觀念釐清的參考書為佳，如果有有趣的課外補充可以參考一下，只是命中考題的機率真的頗低，常識的部分還是平常就要多關心科學知識比較實在。&lt;/p>
&lt;h2 id="五出版社作者">五、出版社、作者&lt;/h2>
&lt;p>比較大的出版社有翰林、華逵、晟景&amp;hellip;&amp;hellip;等等，通常大出版社的書都比較齊全，但有時候為了完整性每一科都有出參考書，只是有些科目的品質就比較差強人意。一般而言市面上比較有名的有：翰林的大滿貫與學測新導向系列、華逵的生物精通以及地科嘿皮書、晟景的複習週記和平安符系列、龍騰的社會科滿分攻略、三民的英文套書等。有的小一點的出版社也有有名的書如：康寧泰順書坊的引航化學、藏經閣的九陰真經等。&lt;/p>
&lt;p>作者部分很多補教名師和明星高中的老師都會出書，像是我們附中還有建中的老師都是出了名的愛出書的。同時也有不少補教老師會把自己多年的教學經驗和講義寫成參考書出版。我一般來說會選擇比較有名的老師寫的書，因為有名代表那位老師是真正有這方面的教學專長的，也是一種保障。不過，不一定準。&lt;/p>
&lt;h2 id="六更新日期">六、更新日期&lt;/h2>
&lt;p>一般來說，用心的作者會每年把最新考題還有趨勢更新在書裡面，以及改正之前的謬誤，也是一個參考的點。通常大出版社的書會比較常更新，不過有的書更新了其實只是加入新的一年考題還有改一下出版日期而已。其實若不是歷屆試題本，我覺得只要課綱符合即可，差個一兩年不會影響太多，反正新的歷屆試題之後也都有機會再做。&lt;/p>
&lt;h2 id="七其它人的評價">七、其它人的評價&lt;/h2>
&lt;p>學校老師通常對於自己科目的參考書有一套看法，可以多和老師聊聊天。網路上也有不少關於參考書的評價，其中像是深藍、PTT高中版等都有不少討論串可以參考。當然也可以向其他同學或是學長姊請教。&lt;/p>
&lt;h2 id="參考書使用規劃">參考書使用規劃&lt;/h2>
&lt;p>以學測來說，我的複習方式主要分成三階段：「地毯式補坑複習」、「快速重點複習」、「考前衝刺」。&lt;/p>
&lt;h2 id="一地毯式補坑複習">一、地毯式補坑複習&lt;/h2>
&lt;p>這個階段通常在暑假就會進行，我會選用比較深入詳盡的參考書，扎實的把整個學測範圍看過一遍，把之前高一高二留的坑洞盡量補起。這個階段推薦的參考書類型像是翰林的大滿貫這類，也許東西會太多，這時候就要畫記重點，並把自己不熟的地方記著，以便接下來再複習。&lt;/p>
&lt;h2 id="二快速重點複習">二、快速重點複習&lt;/h2>
&lt;p>開學以後，要兼顧進度以及學測，可能就沒辦法挪出那麼多時間複習，這時有可以把第一次複習時的重點以及不熟的地方快速掃過，配合分範圍的題庫做複習。或是可以再買一本偏向重點式的參考書（如平安符系列等）。&lt;/p>
&lt;h2 id="三考前衝刺">三、考前衝刺&lt;/h2>
&lt;p>理想狀況是，考完最後一次模考到學測前，已經完成前面兩個步驟，接著就以歷屆試題和模擬試題交叉練習，從題目找出不熟的地方，也要弄清楚歷屆題目的來龍去脈。&lt;/p>
&lt;h2 id="工商時間">工商時間&lt;/h2>
&lt;p>這邊簡單推薦幾本物理參考書，是我認識的老師所寫，我也親自看過。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.wunanbooks.com.tw/product/9789572185643">全華－終極解碼物理學測複習&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>一本題目挑選OK，觀念和例題講解都清楚的書。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.m.sanmin.com.tw/Product/Index/004402997">全華－優勢高中基礎物理(一)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>就是本自修，學測主要考的內容不會比基礎物理(一)多出太多，用自修札札實實重新念一遍也是不錯的選擇。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.m.sanmin.com.tw/Product/Index/003011633">龍騰－稱霸高中物理學測總複習講義&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>這本書補充比較多，也有配合邱博文老師一直再推廣的網路學習資源，適合自然組使用，社會組的話後面題目有些比較難可以跳過。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.m.sanmin.com.tw/Product/Index/003773534">龍騰－稱霸高中物理指考總複習講義&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>一本詳盡的高中物理全範圍複習書，除了觀念提示之外，每章後面也會幫你做好重點中的重點，選題也不錯。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>【高中科目心得】兩年後，再看高中物理</title><link>https://dwye.dev/post/20140725_112921/</link><pubDate>Fri, 25 Jul 2014 11:29:21 +0800</pubDate><guid>https://dwye.dev/post/20140725_112921/</guid><description>
&lt;h2 id="緣起">緣起&lt;/h2>
&lt;p>從一個學生，到進入物理家教界兩年，以及在補習班工作，對於高中物理的認知，看法未必與以前完全相同，現在從一份半個教育者的眼光來看高中物理，所能看到的應該會比以前更廣更全面。&lt;/p>
&lt;h2 id="走上物理家教">走上物理家教&lt;/h2>
&lt;p>會開始走上這條路，一切都是機緣。原先只是抱著累積經驗的心態，沒想到教著教著，卻也教出興趣來。那時候還自己用電腦把要教的題目全部重新打一次，集中在一張紙上，一開始當然也是教的有點抖抖的，所以比較難一點的題目我都要偷偷把解法抄在筆記本裡面，臨場緊張忘記的時候，才可以抱一下佛腳。&lt;/p>
&lt;p>後來隨著時間的推演，應徵進了補習班解題，對於我的臨場物理實力是一大幫助。同時我也接了第二個學生，我還是很堅持每次都要自己整理題目，並且用一本小筆記本寫下這次要教的東西當小抄，不用參考書和學生講義上課，自成一個脈絡。當然對於還有學校課業和社團要忙得我來說，兩個家教似乎是不小的負擔，尤其學生進度又不一樣，常常在家教的前一天晚上，都會打題目到半夜兩三點。但是再怎麼累，只要第一次撐過去，之後我就可以繼續用這些題目來教，以後接新的家教就能如魚得水，省下不少的力。&lt;/p>
&lt;p>只是，凡事都不會那麼順利，在第二年尋找新的家教 case 上，因為競爭者眾多且僧多粥少，實在花了不少精力才找到 case。而且因為第一年教的兩個學生都屬於很聰明的類型，學習和吸收速度都十分優秀，突然教到一般高中的學生，會有點適應不上來，變成我要花更多時間慢慢講解題目，題目的挑選也不能太難。原先我計畫著同一份題目一直沿用，最後也只能量身訂做。&lt;/p>
&lt;h2 id="補習班見聞">補習班見聞&lt;/h2>
&lt;p>自從進了補習班之後，我對於物理教學真是「大開眼界」，補習班裡面有各種程度的學生以及班級，有各種不同教法的名師，以及天花滿天墜的帥氣解法和公式等等。我在補習班這些日子，實力真的上升了不少，同時對於每道題目幾乎都可以有兩種以上的解法。在補習班，也許有不少人不能認同老師上課分題型，學秒殺法的方式，但仔細想想，老師一人要對付學生數百人，能找到所有學生都滿意的教學方式，還真不容易。我覺得，老師要學生背一些解法，學一些偏門觀念，不也實質對於學生的段考和模考是有幫助的？認同的人就學起來，不認同的人也大可用自己的解法罷了。&lt;/p>
&lt;h2 id="學物理的捷徑">學物理的捷徑&lt;/h2>
&lt;p>學物理的捷徑，可想而知，就是：「&lt;strong>走大路不抄小路&lt;/strong>」小路看起來雖然快，但難免曲折，容易迷失在裡面。隨著看過的學生越來越多，其實很多學生的問題源都是「只領悟到觀念的碎片，而遺忘了完整的觀念」。教育部課綱其實把每個章節的大重點以及學生該學什麼都寫的一清二楚，也有強調哪些東西學生要學計算，哪些東西不提推導僅介紹，哪些東西只作定性描述等等。不過，市面上少數講義內容從聯考時代改改改，卻忘了參照課綱，導致收進了一些其實大考根本不強調的東西。學校段考也常如此，但就讓學生增廣見聞的理由來說，還情有可原，只是我覺得學生應該要知道哪些東西是「基礎」，哪些東西是「旁支」，哪些東西是「看看就好根本不用會」。也許第一次學，難免囫圇吞棗，但在複習的時候，我會希望學生能做到這些。&lt;/p>
&lt;h2 id="學測物理騙局">學測物理騙局&lt;/h2>
&lt;p>拿起新課綱的北模自然科試題，整理出物理的部分，大部分的題型都能分入下面兩類：計算、是非。可以考計算的，就出個物理計算題。科學家和強力量子論等不能考計算的，就考是非。學測固然有這些題型，但並不是最主要的部分，尤其是看過第二部分考題就知道，大多都是以閱讀引導作答，很少有必須完全靠自己的知識作答的題目。但這也不能怪出題者，畢竟學測是耗資不小，經歷反複檢驗的題目，題形嚴謹卻能有變化，能真正測驗學生的程度而不是死背，相形之下，模考常常都是老師必須額外挪出時間出題，誰不會想偶爾改個考古題丟進去了事？倒也因為這樣，許多自然科不錯的人都會告訴我們「物理不用讀」，這麼說似乎有點誇張，但若國中有打好基礎，學測範圍的物理幾乎沒有多出太多東西，反而關鍵性的題目常常都是那些閱讀題，那是一般老師很難教導給學生的。所能靠的，就是學生平常培養眼界，多接觸科普知識，當然基礎觀念一定要滾瓜爛熟，才能有在題目中找出線索的能力。&lt;/p>
&lt;p>除了模考之外，**連歷屆試題都會騙你！**最近的課綱修改為例，其實刪去的不少東西，例如說「家庭用電」，原本是95課綱的一大考點，99課綱中這個章節完全被砍去。所以若是有人做到類似題目，分不清火線地線，以為自己高一沒有認真學習，這就錯了。因為，高一根本沒教你這些東西。至少以物理科來說，做歷屆試題時，因為課綱變化不小，要自己注意到哪些已經在課綱範圍外，最好的方式就是：把課綱也看一遍。照著課綱去找觀念，絕對不會漏，也可以避免多讀，能把省下的時間去顧其他科，也是不錯。&lt;/p>
&lt;h2 id="國中撐起高中">國中撐起高中&lt;/h2>
&lt;p>因為我手邊也正且有國中會考的理化複習講義，翻了翻，才察覺到，國中範圍跟高一物理的重疊性實在不小，諸如打點計時器、電與磁、作功等等&amp;hellip;&amp;hellip;，其實很多事情都是國中講過的，高一物理只重觀念介紹，也不會有太多複雜題型。簡單說來，只要國中學好，高一物理根本輕鬆學！反過來說，其實很多物理不好的人，就是因為從國中開始，基礎都沒打好，才會一路爛下去。這也顯示出家教時因材施教的重要性，若是國中基礎有顧好（因為基測制度，這些人大多在明星高中，我相信在會考以及特招存在的情況下，未來仍然是這樣），那麼高二之後的物理便能省一點力，簡單介紹觀念後就能直接進入題目分析與計算。若是國中基礎沒打好，那麼觀念部分就絕對不能放水，還要配合國中等級的簡單題目，先把觀念搞懂來，才能接下去處理高二高三的題目。這樣一來，若是以家教為例，這類型學生就必須多花一些時間來教學，所以可能一堂課就要三小時以上，或是每週多上一次課程，才不會教學時間捉襟見肘。&lt;/p>
&lt;h2 id="會與熟練">「會」與「熟練」&lt;/h2>
&lt;p>每年考試，都會有人在ptt馬後炮：「這明明我就會啊，怎麼當時沒想出來」「這題我有想到解法，可惜時間不夠」。不管是學測自然或指考物理，考場上我們就是和時間賽跑。把時間除以題目數，指考每題大約有3分鐘的作答時間，學測每題可以分到的作答時間更不到2分鐘。更何況，一般人推崇的先寫完、後檢查原則，代表著寫完之後還要留下時間檢查，所以每題可以分到的作答時間就更少，也因此熟練度的鍛鍊也是很重要的。&lt;/p>
&lt;p>現在不是談大學知識，是談高中考試，&lt;strong>看到題目要「會」，知道題目在考哪裡，只是基本功&lt;/strong>理想的狀況，是看到題目不只是要會，更要浮現「切入方法」，也就是對於觀念以及解題的熟練度要夠。尤其是指考，物理不是一科用「讀」的科目，是要用「算」的。其實這對於段考也適用，在唸物理時，希望學生不只是能知道觀念，更要時常把觀念「用」在題目裡面。同時，能把做過的題目訂正，想不出來的題目，不是背誦祥解，而是知道為什麼詳解如此切入。別人寫的出來，沒道理自己不行，只是自己的功夫還沒到家，所以才需要多練習，練習看到題目能知道問題點在哪以及切入方法，在考場上才能及時作答，達到快狠準的境界。&lt;/p>
&lt;h2 id="為什麼要學物理">為什麼要學物理&lt;/h2>
&lt;p>「物理，即事物之道理，於世間萬物之中，尋找共同之規律。」一般人學物理，都是在進學校後，一本自然課本發現，就不知不覺被老師帶入物理的世界裡。當然，有的人僅初窺皮毛，有的人樂於其中並向前探索，甚至有的人走到尖端，撐起這個世界。日常生活中，有多少現象和物理有關？其實國中物理所學，幾乎都是常識，例如光的性質、聲音與速度等等，這些是天天都會在身活周遭用到的。例如開車時候，怎麼看自己和前面的車會不會相撞；行人要走多快，才能避開遠方行駛而來的車，這些事情，我們不一定動筆算，但學過物理的我們，腦中其實已經自動幫我們算出大略的答案。同樣道理，為什麼保險絲會燒掉，為什麼我們不能把電線挖開讓電器全部串來在一起使用，腳踏車出問題要怎麼找問題點&amp;hellip;&amp;hellip;，還有更多事情，都和物理有關。也許我們不用會計算，但是物理的觀念，多少知道一些，對於生活也是有所幫助的。也因此，高中就分為自然組和社會組，社會組就不用學太多題目的計算，只要知道基本觀念就夠了。&lt;/p>
&lt;h2 id="物理與化學">物理與化學&lt;/h2>
&lt;p>一定有人會說，我是化學系，與物理有何相干？為何一個化學系的人，敢跑來物理家教市場搶我們物理人的飯碗？其實，若熟讀科學歷史，不難發現，很多時候物理學家和化學家是難以區分的。有句話說：「&lt;strong>數學，是應用哲學；物理，是應用數學；化學，是應用物理；生物；是應用化學&lt;/strong>」沒錯，化學身為研究變化之學問，怎麼能夠和事物的道理切分開來？物理的原則，總不會到了化學課本裡面就不適用了吧？量子力學的發展，導致了原子軌域觀念的產生，很多人以為，化學就是一門在實驗裡面觀察並歸納的學問，其實很多時候，化學也是「算」出來的。以我現在待的理論化學組來說，理論化學實驗室是所謂「dry lab」，沒有藥品的實驗室。沒有藥品怎麼做實驗？我們用電腦模擬實驗，那電腦要怎麼建構出化學機制？當然是用已知的「物理」原則建立模型，蓋出一個世界。其實理論化學，現在常常跟物理化學掛在一起，幾乎可以算是物理化學的一塊，所靠的就是近代物理最大的突破：量子物理（或在化學界，有個科目叫做量子化學，便是將量子力學的一些原則用於化學上）。物理與化學，同屬於科學，在某些領域上自然難以切割，正如生物與化學也常常有所交集一般。&lt;/p>
&lt;h2 id="從高中物理到大學物理">從高中物理到大學物理&lt;/h2>
&lt;p>每當大學放榜，總是有許多新鮮人迫不及待想要先看看大學的世界長什麼樣子。就我看來，大學理科最重要的科目，非「微積分」莫屬了。大學普物，以知名課本 Halliday 所著之 Fundamentals of Physics 為例，除了會把高中的基礎幾乎全部講一遍之外，也把數學工具，就是所謂微積分，活用於其中，用同樣的觀念就可以解出更多高中所不能解決的問題。當然也有一些新的領域進來，例如流體、熱學、原子核等等。電磁學更是把不得不提的超知名物理明星馬克士威所整理出的四大方程都介紹一遍，這是沒有微積分基礎的高中生所無法觸及的。在普物之後，以物理系而言，會就各個領域規劃更進階一點的課程，例如「力學」、「電磁學」、「熱物理」、「量子物理」等等，了解物理學各界的發展，讓學生置身歷史之中，了解學問的來龍去脈。當然，若是要濟身於物理界的尖端，我甚至可以說，照著課表修課是絕對不夠的，就算到了研究所，學到了「量子場論」、「進階電磁學」之類的課程，也都是近代早有不少先驅在裡面探索的領域，這時候若是直接訪問教授的研究，甚至進到實驗室進行專題研究，反而比較能接觸到學問的尖端。不過，這必須建立在廣大的先備知識下。物理的領域博大精深，高中物理，恐怕連皮毛都稱不上，因此也不必抱怨高中教太多東西，因為從大學的角度看來，高中，根本沒教什麼東西。&lt;/p>
&lt;h2 id="還有更多">還有更多&lt;/h2>
&lt;p>上一篇「&lt;a href="../20120711_061900">最弱科到最強科，我的物理 by YDW&lt;/a>」其實也分享了不少東西，關於讀書的方式，也提及不少，裡頭所寫過的，就避免再寫一次。這篇文章說實在，也沒多給出太多東西，大概就是統整這兩年來的所見所聞吧。見到的學生越多，領悟的也越多。只希望我碰到的人，不一定要喜歡物理，只是不要以物理為苦惱，因為，讓物理變的討人厭的絕對不是物理本身，而是教育制度和考試。也許未來，還會有第三篇或更多篇，但我接下來想做的，是把分雜在各個地方的經驗以及知識，寫成一小篇一小篇的專題，不求很多人看過，但求看過的人皆能有所收穫，如此而已。&lt;/p>
&lt;p>by YDW 2014.07.25&lt;/p>
&lt;h3 id="補充">補充&lt;/h3>
&lt;p>想知道理論化學在幹嘛的，可以參考鄭原忠老師的線上課程（當然，需要有大學普通物理、普通化學與微積分作為基礎）：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://quantum.ch.ntu.edu.tw/online_courses/index.html">鄭原忠 OCW: Quantum Dynamic and Spectroscopy&lt;/a>&lt;/li>
&lt;/ul></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>【文章推薦】申請入學：面試與備審</title><link>https://dwye.dev/post/20140725_064404/</link><pubDate>Fri, 25 Jul 2014 06:44:04 +0800</pubDate><guid>https://dwye.dev/post/20140725_064404/</guid><description>
&lt;p>一篇台大教授關於面試學生的心得文與建議&lt;/p>
&lt;p>我想，從教授的角度直接分析&lt;/p>
&lt;p>應當比補習班旁敲側推來的有用多&lt;/p>
&lt;p>&lt;a href="http://chernyr.blogspot.tw/2012/04/blog-post.html">文章連結&lt;/a>&lt;/p>
&lt;p>另外，這位教授也有出書&lt;/p>
&lt;p>書名：「這樣念大學才不後悔」&lt;/p>
&lt;p>出版社：平安文化&lt;/p>
&lt;p>我家裡收藏了一本，每次回家（我現在外宿）都會重新拿出來翻翻&lt;/p>
&lt;p>相信對於不知道方向的迷惘新鮮人&lt;/p>
&lt;p>多少可以引導出一些方向&lt;/p>
&lt;p>&lt;a href="http://www.books.com.tw/products/0010542007">連結&lt;/a>&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>對於公式的態度</title><link>https://dwye.dev/post/%E5%B0%8D%E6%96%BC%E5%85%AC%E5%BC%8F%E7%9A%84%E6%85%8B%E5%BA%A6/</link><pubDate>Thu, 17 Jul 2014 17:28:48 +0800</pubDate><guid>https://dwye.dev/post/%E5%B0%8D%E6%96%BC%E5%85%AC%E5%BC%8F%E7%9A%84%E6%85%8B%E5%BA%A6/</guid><description>
&lt;p>相較於指考，學測物理有的公式實在不算多，而且課綱中都講明了，很多章節都已經避開推導以及計算。因此剩下的公式，大多算是基本中的基本，例如牛頓第二運動定律 $F = ma$，相信大家國中也都背過了。但有些公式就複雜多了，例如阿特午機(Atwood machine)的張力公式：&lt;br>
$$&lt;br>
T = \frac{2m_1m_2}{m_1+m_2}g&lt;br>
$$&lt;/p>
&lt;p>這樣複雜的公式，也許有人根本沒看過，也許有人在學校課堂或補習班講義裡面看過它，這種公式到底要不要背？&lt;/p>
&lt;h2 id="用最少的公式解最多的題目">用最少的公式，解最多的題目&lt;/h2>
&lt;p>我的看法是，必須把公式分成兩類，一類是「&lt;strong>物理定義&lt;/strong>」，像是 $F = ma$，你不背起來，根本沒辦法從受力算出加速度。另一類是「&lt;strong>導出公式&lt;/strong>」，像我剛剛舉的這個例子就是，這種公式不背也沒差，背了是增加解題速度，但缺點常常是使用範圍太窄，例如這個公式只能用在阿特午機，段考還好，但大考幾乎沒有投資報酬率可言。這類型的公式要不要背，完全看個人，但我的建議是能不背，就不背，&lt;strong>用最少的公式，解最多的題目&lt;/strong>。&lt;/p>
&lt;h2 id="公式的意義">公式的意義&lt;/h2>
&lt;p>當我們背下每條公式時，應該要知道&lt;strong>每條公式背後的物理意義&lt;/strong>，如果是導出公式，更要知道公式是怎麼推導出來的。碰到題目時，先分析題目要什麼，我們有什麼條件，這些條件和答案有什麼公式可以帶出，例如說等加速度運動，給初速度、末速度、位移，要求加速度，熟練的人就會立刻想到$v^2=v_0^2+2a\Delta x$，當然畫 $v$-$t$ 圖也是一種解法。腦袋裡面先有流程再動筆是最好的，若是想不到，也可利用起始條件，走一步算一步。&lt;/p>
&lt;p>當然，如果只是考學測，幾乎沒有複雜的計算及推導，剩下少少的公式幾乎國中都背過，似乎也就沒那麼多煩惱了，只要把公式背後的物理意義搞懂即可。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>我怎麼唸英文</title><link>https://dwye.dev/post/%E6%80%8E%E9%BA%BC%E5%94%B8%E8%8B%B1%E6%96%87/</link><pubDate>Sat, 14 Jul 2012 22:02:18 +0800</pubDate><guid>https://dwye.dev/post/%E6%80%8E%E9%BA%BC%E5%94%B8%E8%8B%B1%E6%96%87/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>　　先說說我高一時的狀況吧，就是一個標準的混混學生，英文雜誌當擺飾，只有在考前才會拿出來惡補，國中也只有1000單的能力。上了高中在第一、二次段考的成績不是很滿意所以就去補習了。&lt;/p>
&lt;h2 id="補英文的歷程">補英文的歷程&lt;/h2>
&lt;p>　　其實我只被同學拉去試聽過劉毅英文而已就去補了，當時選的原因只是因為基測ＰＲ夠高可以減免很多學費，不過後來又繼續待在裡面一直到高三上。我試聽的是後來紅極一時的陳子璇老師的課，當然之後報名也是由她上課。&lt;/p>
&lt;p>　　先說說我在劉毅英文的心得吧，首先他們的上課特色就是大量歸納同義字、同義片語，如果是版本班的話基本上應付學校段考是沒有問題的，不過在高二時就全部轉報模考班（好像還是有附贈版本班可是我那時太忙了沒去聽）。&lt;/p>
&lt;p>　　劉毅模考班的特色就是難度相當暴力，高二剛開始可能會非常不習慣，上課速度也很快並且補充很多東西，上課講義印的很詳細。雖然難度有點過頭，不過在訓練自己寫選擇題的功效上還有一些同義字的歸納記憶上來說是蠻有效的，我的英文也是這樣穩穩的進步到現在這個程度的。&lt;/p>
&lt;h2 id="在補習之後">在補習之後&lt;/h2>
&lt;p>　　補了兩年的英文，會不會後悔呢？我覺得補習不只是把補習班所教的知識吸收進去，更是要把補習班的「教學方法」也跟著吸收走，所謂「教學方法」其實也是我們之後尋找自己適合的學習方法的一種參考。向劉毅英文就很強調「單字量的累積」和「每周一次模考題練習」，而我再沒有補習之後也是照這個方式繼續增強自己的英文實力的。我是覺得，如果自己讀真的沒辦法再去補習，不然我還是會先嘗試自己讀為主。&lt;/p>
&lt;h2 id="所以那個學習方法">所以那個學習方法？&lt;/h2>
&lt;ul>
&lt;li>單字&lt;/li>
&lt;li>文法/句型&lt;/li>
&lt;li>閱讀&lt;/li>
&lt;li>寫作&lt;/li>
&lt;/ul>
&lt;h3 id="單字">單字&lt;/h3>
&lt;p>我會用空閒時間增加單字量，例如說買午餐排隊的時候，或是在車上無聊的時候，隨身攜帶4000單/7000單是我當時的特色之一。當時選擇了三民書局出版的隨身單字本。不過補習班也有發4000單，其實有很多選擇，就看哪本最順眼吧。不過，&lt;strong>一定要有例句&lt;/strong>！這樣才能了解單字的用法，並幫助記憶！而且我會挑對於一個單字，能夠註明多種意思的書，畢竟外文跟中文的發展歷史不同，意思不可能是一對一的。&lt;/p>
&lt;h3 id="文法句型">文法句型&lt;/h3>
&lt;p>我是跟著學校使用康熹出版的《必背英文句型》，這本書的特色就是簡單明瞭，分章很有規則，一頁就是一個句型，很適合拿來規劃複習。但我寫完一本覺得不夠熟係，又挖出了以前學校訂英文講義附送的句型本，但這本就因為時間的關係沒有寫完。&lt;/p>
&lt;h3 id="閱讀">閱讀&lt;/h3>
&lt;p>加強閱讀的方法有很多種，包含英文雜誌、看英文新聞、直接多做閱讀題等等，我是選擇直接多寫模考題解決，模考題的來源主要是學校，另外我也有自己購買歷屆試題把它寫完並檢討完，對我而言這樣就已經足夠了。&lt;/p>
&lt;h3 id="寫作">寫作&lt;/h3>
&lt;p>沒有什麼訣竅，就單純多寫，每個禮拜寫兩篇拿給老師改（不過前提是老師願意配合，也很謝謝我們學校的英文老師，多半都很熱心，鼓勵我們寫作文給他們改），並且取得老師的意見，每次不斷的改善。&lt;/p>
&lt;p>也可以在寫作時練習最近讀到的文法與單字，可以加深印象之外，也能增加自己的寫作詞庫。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>[高中科目心得] 最弱科到最強科，我的物理</title><link>https://dwye.dev/post/20120711_061900/</link><pubDate>Wed, 11 Jul 2012 06:19:00 +0800</pubDate><guid>https://dwye.dev/post/20120711_061900/</guid><description>
&lt;h2 id="寫在最前面">寫在最前面&lt;/h2>
&lt;p>我覺得，物理是一科非常吃「讀書方法」的科目，好的讀書方法帶你上天堂，不好的讀書方法帶你到懷寧街某獨棟補習班。一個單元中哪些公式一定要背，哪些觀念要如何釐清，哪些解法是要知道的，在考前一定要掌握這些脈絡，考試時才能從容地正確作答。&lt;/p>
&lt;h2 id="全新的挑戰">全新的挑戰&lt;/h2>
&lt;p>高一的時候我們班老師是名聲傳遍千里的Ｐ哥，三次段考都是走標準的Ｐ哥簡單風（兩張單面，一題五分，共二十題，全部都是習作和講義的題目&amp;hellip;&amp;hellip;我們這屆的人應該在熟悉不過了），因此到了高二其實有很大的不習慣，第一堂課就被茂福的微積分嚇著了！其實說來也頗貼心，為了因應Ｐ哥基礎物理和真正高二物理的差距，茂福補充了不少資料給我們，不過那個微積分證明當時我可是一點也看不懂&amp;hellip;&amp;hellip;突然面對那麼多符號總是會讓人不甚習慣。&lt;/p>
&lt;p>沒錯，進入了高中物理的世界，有很多事情是需要適應的。其一便是符號的運算，什麼 F,m,v,a,g,h,R&amp;hellip;&amp;hellip;..，不再像是國中的時候只是單純的數字運算，高中物理甚至會出現整題只有符號在運算的題目！千萬不要怕，給自己足夠的計算空間，只要有足夠的自信，其實列出式子後要做的只是移項一下答案就出來了（不得不說，我一直到高三時才克服這項恐懼&amp;hellip;&amp;hellip;尤其是波爾氫原子模型那邊）。另外，讀懂題目並以適當的圖解畫出題意也是重要的一項技能，像是 v-t 圖，還有茂福非常強調的力圖，這些圖形也是很吃空間的，所以說我覺得物理需要很大很大的計算空間，也難怪每次陸董上課都需要規劃好一整面黑板該如何使用，並且花一段時間畫圖。&lt;/p>
&lt;h2 id="哪些公式該背">哪些公式該背？&lt;/h2>
&lt;p>大家都知道我是個討厭背公式的人，但是我還是有背一些公式，除了 F = ma、P = mv 這種近乎基本的東西之外，像是直線運動三大公式、微分公式、拉密定律（其實我背的是正弦）這些我有背下，那至於一些複雜的像是斜拋的公式還有阿特午機之類的我就以推導為主。有一些投資報酬率高的速算法，像是彈性碰撞的 V’ = 2Vc-V0 我就有背（背下這條也不需要花多大的力氣）。掌握一個原則，能推導的就以推導為主。背下每一個公式之前要知道那些公式是怎麼來的，還有甚麼時候可以使用那些已經背下來的公式，用投資報酬率的方式去衡量也是一招。至於如果需要幫助記憶的方法，可以上潘冠錡老師的網站，裡面有很多有用的東西，其中我強力推薦「圓周運動需要什麼力」和「SHM 是簡諧運動」這兩首歌，當然裡面還有其他的東西，有興趣的人就自己去挖寶吧！&lt;/p>
&lt;h2 id="善用想像">善用想像&lt;/h2>
&lt;p>有些物理的概念其實是有些抽象的，因為日常生活中其實不太會碰到（進行了太多假設），像是功與能這章，當然還有克卜勒三大定律、靜電學、氣體動力論&amp;hellip;&amp;hellip;等等。想辦法習慣物體裡面有著「能量」這樣一個虛構的東西存在其中（還是你把它想成查克拉也可以&amp;hellip;&amp;hellip;）然後可能往下掉的時候那個物體內在的能量就會轉變成物體的動能，推動一個物體的同時也給予它能量等等，甚至和力學結合在一起！根據陸董所說，高中物理有三大守恆是很有用的，其一是「動量守恆」，其二是「角動量守恆」，另一個就是「力學能守恆」，只要在沒有非保守力作功和能量散失的情況下，就勇敢地用下力學能守恆吧！既然提到了守恆就在順便一提動量的重要性，基本上在高中物理會碰到的題目中，動量守恆是恆成立的，就算是核反應亦然！從碰撞一直到康普頓效應，動量守恆都是一項解題的利器，務必熟悉！&lt;/p>
&lt;h2 id="物理好像有很多黃皮綠皮之類的書要看嗎">物理好像有很多黃皮綠皮之類的書，要看嗎？&lt;/h2>
&lt;p>對於高二進度這邊，我比較不能提供什麼經驗，原因很簡單，因為我的高二物理成績是徘徊在及格邊緣的。順便爆一下自己的料，我常常早上在物理課看報紙，而且沒有被茂福抓到過（不然可能就會&amp;hellip;&amp;hellip;茂福神掌！）。題目的話，除了學校採用的那本陳忠誠老師所編寫的講義之外，出版社送的講義也不會差到哪裡去（我們當時是用南一版），順帶一提，南一版的講義編寫者湯烈漢老師也寫了不少總複習參考書，大多是華揆出版。我主要是寫學校發的那本講義（換上了黃皮&amp;hellip;&amp;hellip;貌似是想沾沾張鎮麟黃皮書的名號），其實這樣就已經足夠了，但寫的時候重點是要把握每一題裡面所用到的觀念，其實很多題目是可以一以貫之的，注意別把觀念打碎了而執著於記憶每種題型的解法，我覺得我們要做的是讓自己的觀念穩固，在面對全新的題目時仍能知道如何突破。&lt;/p>
&lt;p>回到副標，要不要買這些書呢，我覺得，如果有意進修，這套系列的書的確是可以提供不少幫助，黃皮書主要用於扎實自己的基本觀念（兩本上下），綠皮書則是鑑往知來、修練自我的好工具（三本上中下，收錄非常豐富的題目，都頗厚），至於另一本藍皮書則是如果有對於實驗題型的需求時倒是蠻好用的，尤其是今年指考莫名其妙叫我們自己設計一道實驗，若是對於實驗不夠熟，更不用提如何設計一套新實驗了。但是缺點，同時也是這系列書的優點：東西太多了。尤其是綠皮書，若不是從高二就更著進度寫，對於我這個有六科要兼顧的三類組來說，怎麼可能寫得完？但若是以寶典方式來使用（也就是僅供讀寫重點和查詢用），也不失為不錯的方式，只是說真的，沒有必要，只給將來有興趣進修物理的人做做自我挑戰吧。&lt;/p>
&lt;h2 id="學測物理怎麼辦">學測物理怎麼辦&lt;/h2>
&lt;p>承第二段，在Ｐ哥的帶領下我可是扎扎實實的讓自己的物理睡了一學期&amp;hellip;&amp;hellip;。在升高三暑假決定開始讀學測時，物理也是被我排在最不重要的科目，首先，物理只佔 1/4 科的重要度，再者，九五課綱的基礎物理基本上幾乎就是國中三年的物理再加上一點常識，對於小時候對於科學就有興趣的我，這根本不算什麼。此外，對於我們自然組來說，學過了高二物理，高一物理簡直是沒有難度可言，而學測高二物理又只考皮毛中的皮毛，甚至只需要在提供的文章中搜索推敲答案就呼之欲出，而且還不用全部答對（當然，全部答對最好，我曾經有「第二部分神話」，即是第二部分從來沒被扣到分過，每次都錯四題以內，只是剛好在101學測那一次打破，有點諷刺）。&lt;/p>
&lt;p>講了那麼多好像物理根本不用讀一樣，事實上我還是自己挑了一本參考書。我們班大部分的人都挑了陸董寫的物理一本通，三民出版的，特色是內容詳細，把高二會考的部分融於高一物理之中，同時若想要向北模宣戰這本書也提供了不少北模題目可以大略試試身手，解答也從不拖泥帶水，而且時近代物理和現代物理的應用甚至把高三下的東西補充了一點進來以利理解（其實九五課綱的基礎物理的基本特色就是，只跟你說有這件事，不告訴你為什麼，例如光的繞射）。不過我當時已經事先在書店選購了晟景出版的應試對策，是台南女中的周青彬老師寫的，其實我選上這本書的理由很簡單，這本書在它的競爭對手中是最薄最便宜的&amp;hellip;&amp;hellip;。的確我當時的策略就是不想砸太多心力在物理這科上面，甚至我的心態是將來就乾脆不碰物理了，因為我認為我沒有念物理的天分，但真相是我只是沒找到適合自己的物理讀書方法罷了。附帶一提，九九課綱上面這兩本書目前都還沒有更新，所以學弟妹不好意思你們可能沒辦法用這兩本書了，實在可惜。&lt;/p>
&lt;h2 id="我補的是鍾怡物理">我補的是鍾怡物理&lt;/h2>
&lt;p>鍾怡物理？走遍了北車補習街，如何也找不到這個招牌。我就不繼續買關子了，所謂鍾怡物理，其實就是陸董的物理課啦！陸董是一個上課風格獨特的老師，而且不只是獨特而已。先概述一下這位老師的幾個特色好了：第一，上課使用自己編的講義，用自己的一套系統進行教學；第二，走到教室的第一件事情就是把黑板擦乾淨、擦到發亮為止（這形容真的不誇張），並且把粉筆擺好，因為你準備要聆聽一場 well-designed 的課程了；第三，上課非常重視板書的整齊度，每次畫圖都會讓我們休息幾分鐘，但是每次畫圖都非常令人驚艷，就像印出來的一樣，而在寫計算過程時也是非常整齊，同時也是這種教學風格讓我不小心領略到計算空間的重要性；第四、如果恰逢第四節課上課會鼓勵我們買東西吃；第五、上課禁止我們看其他書（尤其是補習班講義），原因很簡單，老師認為我們有辦法在他的課中獲益比自己看書還多，而這也是事實；第六、第一堂課會和我們約定好幾個原則，若是違反原則他會馬上翻臉，可是其他情況下是個亦師亦友的好老師，而且說話很直很中肯。當然還有太多其他的特色，在此不一一贅述，若是能親身體驗才更能明白。此外，我覺得陸董上課還有一大特色，就是「自信」。&lt;/p>
&lt;p>老師有自信，學生才能對於他們的學習有自信，這也是我在社團內對於課程講師的一個大原則。我想我領悟到的其中一個讀書方法就是自信的重要性，碰到題目時，若是猶豫不決，題目永遠不可能解開，但若是能抱著自信去嘗試，只要觀念是正確的，基本上沒有什麼題目是行不通的，只是不同的方法會經歷不同複雜度的計算過程，但是條條大路都能通往羅馬，就別太在意了，只是準備好足夠的計算空間先吧。我覺得能在高三遇到陸董這樣的好老師應該是我三生有幸吧，信不信由你，物理從我的最弱科變成我的最強科，指考前一個月我連北模試題都可以寫到 90 分以上，同時我甚至還考慮過大學要不要去雙主修個物理呢，當然這是以後的事情了。在此我也在這邊感謝陸老師一年的教導。&lt;/p>
&lt;h2 id="致命的弱點">致命的弱點&lt;/h2>
&lt;p>一直以來，我在學科的弱點就是粗心。有時手比腦袋還快，也有時輸入跟輸出不一致，各式各樣粗心的原因層出不窮。其實粗心反過來說，就是不夠小心，解決方法之一當然就是：小心一點，只是誰又能在時間緊湊的考場上保持該有的冷靜呢？&lt;br>
所以我採用的方式是：拿一本筆記本，分章節分範圍一條一條寫下自己曾經不小心而犯錯的地方，並且每次再犯錯就在旁邊加上一筆正字記號。這個方法一開始是我在對付學測數學時想到的，物理我是一直到4/18確定要考指考後才啟用這個方法，而此時我的物理實力其實也已經有一定的基礎了。我覺得這個方式還蠻有用的，其實只要寫下來大部分的錯誤都不會再犯太多次，而且如果記的時間夠長的話，這本筆記本還會變成考前衝刺的利器！&lt;/p>
&lt;h2 id="指考物理衝刺">指考物理衝刺&lt;/h2>
&lt;p>我挑選的是陸董和大部分老師都很推薦的大滿貫物理講義，是南二中的陳世清老師編寫的。這本講義的最大特色是，重點有抓到、分量剛剛好（不像綠皮書厚的很誇張）。兩百多頁也許有人會認為多，但實際上我大約三十天就寫完了（也是因為我比較晚開始讀指考所以情非得已一定要用飆的）。這本書寫完之後其實我就直接開始挑戰歷屆&amp;hellip;&amp;hellip;.北模試題！當初會做出這個決定的原因是我想要練自己在一群混雜各章題目的試題中順利地見神殺神、見鬼捉鬼的能力。剛開始的確會有點挫折，但越挫就會越勇，後來寫歷屆指考就變成小 case 了。雖然常常聽說北模試題出的不好，但只是在於＂難度＂方面調控的不好，實際上那些題目還是值得拿來練習的，不過還是一句話，抓住解題的觀念，而不是記憶每個題目的特別解法。&lt;/p>
&lt;p>至於成效怎樣呢&amp;hellip;&amp;hellip;至少我很滿意我現在這個分數，雖然沒有達到當初立下要考滿分的目標，但也夠了。&lt;/p>
&lt;h2 id="後記">後記&lt;/h2>
&lt;p>從這麼長一篇文章裡面要撈點有用的經驗感覺會像是大海撈針呢&amp;hellip;&amp;hellip;，但各位看倌就辛苦點吧，至少這樣才能保持住我這篇心得的原汁原味。有時候我在算物理時會想，高中物理是不是太過理想化了，但後來仔細思考，這其實只是方便我們學習吧，當我們越學越深入，也許要考慮的東西就會越來越多，像是阻力、能量散失等等，所以其實距離物理在現實中的應用還有一段距離吧，只是不學好基礎，何談應用？也許這就是高中教育的目的了。第二篇也打完了，我也不預告下一篇會是什麼，因為我也不清楚我會不會打下一篇，你們以為我很熱心一直想分享自己的經驗給需要的人嗎？其實我主要只是想記下這些東西而已，當作未來的一種懷念吧。&lt;/p>
&lt;p>by YDW 2012.07.11&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>[高中科目心得] 自修一年生物的小心得</title><link>https://dwye.dev/post/20120710_061600/</link><pubDate>Tue, 10 Jul 2012 06:16:00 +0800</pubDate><guid>https://dwye.dev/post/20120710_061600/</guid><description>
&lt;h2 id="緣起">緣起&lt;/h2>
&lt;p>先說說緣起好了。從高一開始我就一直待在二類班沒有轉班，當時的心態是我不想當醫生，所以也就直接把三類排除在外了（那時我不知道三類還有那麼多選擇&amp;hellip;&amp;hellip;也是一大疏失吧），當時很天真的想說把探索志願這件事情留到以後再說，先在二類待著，直到我的腳踝中了一箭&amp;hellip;&amp;hellip;沒錯一直到升高三的暑假我才發現自己有興趣的是生物化學領域，所以就毅然決然的抱起自修，開始一趟漫長（但不怎麼艱辛）的生物自讀旅程&amp;hellip;&amp;hellip;。&lt;/p>
&lt;h2 id="從喜歡上生物開始">從喜歡上生物開始&lt;/h2>
&lt;p>剛開始的志願其實也沒有很確定，會開始自讀生物只是在因緣際會之下在垃圾堆（註：學長姐每年不要的書都會丟在一起，任我們自取）翻到了一本高二上生物自修（大約 95% 空白），又剛好因應學測需求，就開工了。卻那知我在第一個禮拜就把高二上解決了，主要就是劃重點、寫習題檢討這樣。那時感到有點欲罷不能（而且學測生物會考到高二下），所以就上網查了一下哪本生物自修比較有名，而我查到的就是：翰林出版南一中郭人仲老師所編寫的自修！除了觀念條理清楚外，課外補充也不少，詳解也不馬虎很精準，從神經和免疫一開始我又一頭栽進了生物的世界！&lt;/p>
&lt;p>你以為我到這就已經喜歡上生物了嗎？還太早！真正的功勞我必須首推暑假時許偉傑老師所上的生物課！他的教法有一個鮮明的特色，就是很有自己的一套系統。我們上課的人甚至只需顧著看黑板抄筆記就好，講義也不用瞄任何一眼就能順利地跟著老師的腳步走，再加上時時穿插的個人經驗分享（有種講法叫「廢話」，但我不覺得那些話有資格被稱為廢話，至少我們都聽得津津有味），以及我回家的每天思索，其實生物還是蠻有趣的一個科目嘛！&lt;/p>
&lt;h2 id="跟著進度唸">跟著進度唸！&lt;/h2>
&lt;p>就在許偉傑老師的生物課之前，我就已經用飛快的速度把高二生物唸完了，當時我幾乎就是車上唸生物，上課聽生物，回家繼續唸生物&amp;hellip;&amp;hellip;。由於之前對於翰林版那本自修印象不錯，因此我在高三進度的部分也就繼續使用翰林版的生物自修。我記得暑假時和那年的校內三類組榜首閒聊時，我告訴他我決定高三要自修生物，他告訴我高三生物和高一高二的都不一樣，難度增加許多，然而他最後還是鼓勵我，在此也順便感謝學長當時的鼓勵。從第一章緒論，就讓人感受到高三生物的不一樣：我即將進入真正生物學的範疇，要開始以科學專業的角度看一些事情了，而不是只做通識性的認識而已。&lt;/p>
&lt;p>其實我認為就這種按部就班的唸法，對我來說到是蠻順利的，又剛好在此我也領悟到了一些其他科的學習方法，像是數學跟物理科拿到第一次段考 90 分等，當時有種滿面春風的感覺。除了進度之外，我也替自己安排大約每唸兩章就複習一次（把之前看過的重點和筆記再看一遍），然後每次段考前要讀完那次段考範圍等。&lt;/p>
&lt;h2 id="當學測過去之後">當學測過去之後&lt;/h2>
&lt;p>我也不知道為什麼我還是每一科都照著進度讀！也許是我一開始就隱隱約約感覺到自己指考的可能性吧。這學期我多買了一本翰林版的期考試題挖挖哇（其實也不是這本書多好啦，只是剛好符合我想寫段考題的需求）。當時我聽一些三類的朋友說，正常生物的段考分數都是 7X 分，也就是 1/4 的正確率嘛，而的確在寫得當中會有一些題目還蠻刁鑽的（但比數學好多了&amp;hellip;&amp;hellip;），但是太機車的題目或是有些甚至超出範圍的題目我也沒有理它就是了，到最後發現其實我的答對率不錯嘛。第一次北模我有拿考卷來寫&amp;hellip;&amp;hellip;成績也算可以，就只輸我們班另一個三類的 3 分而已（那個人後來上了名古屋大學，超厲害！）。&lt;/p>
&lt;h2 id="指考戰士的生活">指考戰士的生活&lt;/h2>
&lt;p>其實 4/18 放榜後一開始我的重心是以救物理和背完 7000 單為主，也因此有一小段時間沒有碰生物，但也是一個禮拜多幾天而已。對我來說，生物是一科耗費腦力很少的科目（尤其是複習的時候），有點像是另一個社會科吧，所以我把它排在一天的最後，也就是在晚上讀。由於我認為自修已經提供了足夠資訊，因此我在選購總複習參考書時就盡量以簡單扼要的類型為主，不同於大部分人選的華逵精通總複習，我選擇了言日中所編寫的新高中生物超速度記憶，而這邊的言日中，其實就是前幾段提到的許偉傑老師啦！而歷屆試題的部份我選擇了捷學國際出版的，一開始是看在它解說詳細的份上選擇的，但後來寫一些發現是一個失策，因為其中有不少錯誤（當然也有可能是因為資料多，錯誤發生的次數也跟著上升），而且購買這個出版社其他科歷屆試題的同學也跟我說，有些地方的解法或答案是錯的。&lt;/p>
&lt;h2 id="考前的衝刺">考前的衝刺&lt;/h2>
&lt;p>等到考前大約二十來天的時候，我把上面那本總複習參考書讀完了，其實那本書要讀完並不用花很久的時間，只是有些較深入的觀念真的要自己補充（當然指考不一定會考那麼難）。因此我又在某次逛書店的時候買了一本複習的題本，是補教老師姜孟希寫的題庫，從這麼多本書中選擇它的理由是因為題型夠活，而解答也很精闢。然而有些題目真的是有一點刁鑽，我的處理方式也是像之前寫段考題那樣。這本題本有點厚所以我就沒有寫完了，只有在每次有時間的時候挑選我覺得重要的章節來寫（動物生理學、內分泌學和胚胎學、植物生理學、新陳代謝及能量轉換、人體的防禦系統、組織學、植物構造與運輸&amp;hellip;&amp;hellip;好啦其實我還寫蠻多的），而大部份我都是利用通勤的時間在寫。而在最後一天，我就拿起那本總複習，快速掃過之前畫的重點，準備赴戰。&lt;/p>
&lt;h2 id="總結">總結&lt;/h2>
&lt;p>其實到後面感覺一直都很穩，寫完歷屆就知道大概會考什麼樣的東西，也懂得去避開一些太細節的記憶，找到每章節的重點。此外，在讀的過程中，常常感受到生命實在不愧是累積億年的奇蹟，居然能協調的如此奇妙！但我將來要克服的東西其實還很多，像是之前一直都逃避沒去接觸的解剖。雖然我不確定我的讀書方式是否是最好的，但至少這次的指考生物成績還算是滿意了，因此作此心得文，當作記錄之外，也給需要的人作為一點參考。&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item><item><title>進台大重要嗎</title><link>https://dwye.dev/post/20120219-to-ntu/</link><pubDate>Sun, 19 Feb 2012 18:38:00 +0800</pubDate><guid>https://dwye.dev/post/20120219-to-ntu/</guid><description>
&lt;p>　　台大，既然能擁有著台灣第一學府的名號，也必定有它的本事。台大有著自由開放的學風、豐富的學習資源、許多厲害的教授、強大的同伴兼競爭對手&amp;hellip;&amp;hellip;.等等。但凡是有正面的誇獎，就會有負面批評：在企業界中最受歡迎的學生是成大畢業的，而不是台大，為什麼呢？有人說，台大學生太過高傲，仗勢著自己的高學歷，就要企業給他們更好的待遇，相較於成大學生而言，成大校友形成了一個堅強的體系，校內教授也積極努力的給學生學習資源，因此成大出來的學生雖然比較被動，卻也比較易於「駕馭」，有著一種願意從基層打拼的感覺。也難免成大的學生在企業界占盡優勢。&lt;br>
　　但其實這只是學校的走向問題：成大很明顯是一所為企業界培育人才的學校，清大交大也有這種走向。然而台大卻是往台灣的學術中心發展，台大培育出的學生不一定是為企業界量身打造的，不過不能否認的是他們在學術領域的表現，尤其是在醫學領域台大明顯是最優秀的。台大擔當著讓台灣減少對國外的依賴，讓台灣在學術領域走出自己的一片天的重要角色。說實在的，台大培養的主要不是企業員工，而是研究人才。&lt;br>
　　那麼就回到根本的問題，進台大重要嗎？&lt;br>
　　身為一個北部人，北部的第一志願非台大莫屬，很少人願意到南部念成大，難免是因為已經習慣在北部的生活，要離鄉背井讀書不容易，這現象又以台北最為嚴重。台北，中華民國現在的首都，也是全台灣工商最發達的國際城市，上層階級的有錢人大多聚集在此，也造成了台灣南北發展不均的現象。這些社會中較上層的人多半擁有較好的資源，能給小孩教好的教學，再加上能夠待在上層階級的他們，家族的資質也不會太差，因此就形成了一種「壟斷」的現象：有錢人的孩子較聰明，聰明的他們又能再度成為有錢人。既然台北市聚集了這麼多聰明人，可想而知北部的第一志願台大的分數必然會被衝高。&lt;br>
　　但如果台大的分數只是「被衝高」的，進台大似乎就不顯的那麼重要了，只要願意離家讀書，在成大、清大、交大四年學成後翻身的可能性也不會遜於台大學生。但現實殘酷地，台大就是擁有著最多的資源，雖然自由開放的學風使台大不會太強迫於學生必須一步步走在教授安排的軌道上，不過相對而言，有心學習且有志向的學生在這所大學就更能取得優勢。&lt;br>
　　不如問問自己，我想要的是什麼？&lt;br>
　　台大在綜合評比下一定是最優秀的，不過在個別領域上前幾名的大學卻各有勝負，例如清大理學院、交大資工、陽明生科等等也都是數一數二的，但它們在台大的對手都掛著台大的光環，所以這些科系在台大的分數就隨著潮流一直被衝高。只是我們不能只因為前幾名的順序就評斷哪個好、哪個壞。講句實在話，這些大學、這些科系都算很好了，若不是追求頂尖，又何必斤斤計較？更何況這些不是台大的學校也常培育出不輸台大的學生，說不定你我就會是那個人，那刁鑽於這細細的錄取分數上就顯得更沒有意義了。&lt;br>
　　套一句陸董說的話，大學不是人生的「終點站」，只是個「中點站」，重要的是我們在社會上的表現，人一生的成敗總是在入棺之後才能評斷的，就像希特勒在發動第二次世界大戰之前，也曾經是當時世界上令人崇拜的領導人，也有像林書豪那樣念了全球頂尖的哈佛大學卻出來打籃球在球壇上嶄露身手的人。擺在我們面前的是許多條路，條條大道都能抵達羅馬，只要我們能清楚地知道方向並抱著決心走下去。&lt;br>
　　最後再問一次自己，進台大重要嗎？&lt;/p></description><copyright>本文原創部分採用 創用 CC 姓名標示-非商業性-禁止改作 4.0 國際授權條款 授權。</copyright></item></channel></rss>