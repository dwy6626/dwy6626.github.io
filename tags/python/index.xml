<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on dw's 小站</title><link>https://dwye.dev/tags/python/</link><description>Recent content in Python on dw's 小站</description><generator>Hugo -- gohugo.io</generator><copyright>&amp;copy; 2020. All rights reserved.</copyright><lastBuildDate>Wed, 16 Feb 2022 18:41:25 +0800</lastBuildDate><atom:link href="https://dwye.dev/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 實作 LRU Cache (LeetCode 146)</title><link>https://dwye.dev/post/python-lru/</link><pubDate>Wed, 16 Feb 2022 18:41:25 +0800</pubDate><guid>https://dwye.dev/post/python-lru/</guid><description>&lt;h2 id="題目">題目&lt;/h2>
&lt;p>LeetCode 146 的名稱就叫 &lt;a href="https://leetcode.com/problems/lru-cache/">LRU Cache&lt;/a>，算是教科書等級的題目，希望你可以實作一個 cache，在內部的 Cache Key 有著透過 LRU 演算法的淘汰機制（最久沒影使用的 Key 會優先淘汰）。&lt;/p>
&lt;p>時間複雜度限制 get 和 set 都要 O(1)。&lt;/p></description></item><item><title>Python 費氏數列解法（五）：不同解法的執行時間比較</title><link>https://dwye.dev/post/python-fibonacci-5/</link><pubDate>Sat, 29 May 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci-5/</guid><description>&lt;p>終於來到最後一篇了，前面幾篇依序寫了各種不同費氏數列的寫法，包含：&lt;a href="https://dwye.dev/post/python-fibonacci">遞迴、迭代&lt;/a>、&lt;a href="https://dwye.dev/post/python-fibonacci-2">矩陣&lt;/a>、從矩陣衍生的&lt;a href="https://dwye.dev/post/python-fibonacci-3">Fast doubling&lt;/a>、以及最後&lt;a href="https://dwye.dev/post/python-fibonacci-4">公式解&lt;/a>和補充的&lt;a href="https://dwye.dev/post/python-decimal">精確版公式解&lt;/a>。&lt;/p>
&lt;p>從時間複雜度來看，從矩陣開始都是 $O(\lg n)$（如果我們把公式解內指數運算當作 $O(\lg n)$ 的話），那這三個哪個比較快呢？&lt;/p>
&lt;p>&lt;a href="https://yodalee.me/2019/02/2019_fibonacci/">這篇&lt;/a>文章裡面用 c 比較了 fast doubling 和公式解，發現號稱常數時間複雜度的公式解，反而慢上很多，而且還需要考慮精確度問題。&lt;/p></description></item><item><title>使用 Decimal 提高浮點運算精確度</title><link>https://dwye.dev/post/python-decimal/</link><pubDate>Fri, 28 May 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-decimal/</guid><description>&lt;p>在&lt;a href="https://dwye.dev/post/python-fibonacci-4/">第四篇&lt;/a>提到費氏數列的公式解會遇到浮點數問題，只能精準算到 122 位。因為浮點數是利用二進位的小數來做儲存，對於非二進位的數字會有誤差。而且其儲存位數有上限，對於無理數的運算，超過一定的大小就會出現精確度問題。&lt;/p>
&lt;p>所以這篇就要來簡單使用 Python 內建的 Decimal module 來拉高浮點數運算的精確度。&lt;/p></description></item><item><title>Python 費氏數列解法（四）：公式解與推導</title><link>https://dwye.dev/post/python-fibonacci-4/</link><pubDate>Sun, 09 May 2021 17:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci-4/</guid><description>&lt;p>在&lt;a href="https://dwye.dev/post/python-fibonacci-2">第二篇&lt;/a>介紹了費氏數列的矩陣解法，不過費氏數列其實是可以直接用公式算出第 n 項的值的，這邊就來介紹並推導一下公式解，順便幫自己複習一下數學 XD&lt;/p></description></item><item><title>Python 費氏數列解法（三）：Fast Doubling</title><link>https://dwye.dev/post/python-fibonacci-3/</link><pubDate>Tue, 06 Apr 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci-3/</guid><description>&lt;p>&lt;a href="https://dwye.dev/post/python-fibonacci-2">上篇&lt;/a>寫到費氏數列的矩陣解法來達成 $O(\lg n)$ 的時間複雜度，實際上可以再做一些變化來簡化計算。如果目標時間複雜度是 $O(\lg n)$，代表我們要能每次直接計算當 n 變成兩倍時的數值。&lt;/p>
&lt;p>下面介紹的 Fast Doubling 方法就是這個例子。&lt;/p></description></item><item><title>Python 費氏數列解法（二）：矩陣解</title><link>https://dwye.dev/post/python-fibonacci-2/</link><pubDate>Wed, 31 Mar 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci-2/</guid><description>&lt;p>在&lt;a href="https://dwye.dev/post/python-fibonacci">上篇&lt;/a>我們討論了費氏數列的各種基本解法。&lt;/p>
&lt;p>原本我也以為 O(n) 的迭代解就已經是標準解法了，直到被大神朋友指正：&lt;/p>
&lt;blockquote>
&lt;p>問費氏數列應該是想聽 $O(\lg n)$ 解法吧？&lt;/p>
&lt;/blockquote>
&lt;p>查了一下還真的有，&lt;a href="https://medium.com/fcamels-notes/%E8%B2%BB%E6%B0%8F%E6%95%B8%E5%88%97-o-logn-%E7%9A%84%E8%A7%A3%E6%B3%95-e36067e57baa">這篇文章&lt;/a>寫得蠻完整的，這篇會參考該篇文章來撰寫，但會用我自己的話以及 Python 寫出來。&lt;/p></description></item><item><title>Python 費氏數列解法（一）</title><link>https://dwye.dev/post/python-fibonacci/</link><pubDate>Sun, 28 Mar 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci/</guid><description>&lt;p>面試被問到的題目，雖然是很基本的題目，但相關延伸也有不少，寫篇文章記錄一下。&lt;/p>
&lt;h2 id="遞迴最基本又直觀的解法">遞迴：最基本又直觀的解法&lt;/h2></description></item><item><title>Python 實作 Disjoint Set 與 Union Find</title><link>https://dwye.dev/post/python-union-find/</link><pubDate>Mon, 22 Feb 2021 18:41:25 +0800</pubDate><guid>https://dwye.dev/post/python-union-find/</guid><description>使用情境 在 Leetcode 寫到一題： 1319. Number of Operations to Make Network Connected 現在有 n 台電腦以及一些 cables 將電腦點對點連接，問需要移動至少幾條 cable 才能讓在所有電腦連成單一網路。 以 graph 的角度來看，電腦就是 nodes，cables 就是 edges。 要將整張 graph 連接起來，至少需要 n-1 個 edges。若一個 graph 裡面有超過 n-1 個 edges，剩下的就是多出來的 edges，可以供我們拿來移動的 edges。 所以第一件事就是要檢查 edges 數量 &amp;gt;= n-1。 當檢查完畢之後，我們有至少 n-1 條 edges，一定可以用這些 edges 將所有 nodes 連接起來。 因為題目只問需要移動幾條 edges，我們可以假設我們</description></item><item><title>Matplotlib 中文字體亂碼問題</title><link>https://dwye.dev/post/matplotlib-font/</link><pubDate>Tue, 03 Mar 2020 23:41:25 +0800</pubDate><guid>https://dwye.dev/post/matplotlib-font/</guid><description>&lt;p>花了一段時間解決這個問題，發篇文章記錄一下。&lt;/p>
&lt;h2 id="嘗試">嘗試&lt;/h2>
&lt;p>一開始想到的是字型設定，所以就看一下系統有哪些中文字型：&lt;/p></description></item><item><title>讓 VSCode 的 Terminal 執行 Conda 的 Python</title><link>https://dwye.dev/post/vscode-python-terminal/</link><pubDate>Mon, 29 Jul 2019 15:47:44 +0800</pubDate><guid>https://dwye.dev/post/vscode-python-terminal/</guid><description>&lt;p>其實這個問題一直都有在困擾我，不過因為通常都是用 iTerm 另外開 Terminal 測試，或是直接用 VSCode 的 Python Plug-in 執行，所以就比較還好。因為想寫 Side Project，今天決定先認真來解決這個問題。&lt;/p>
&lt;p>於是就找到了這個 issue:&lt;/p></description></item><item><title>在 Jupyter 使用虛擬 Python 環境</title><link>https://dwye.dev/post/venv-jupyter/</link><pubDate>Mon, 04 Mar 2019 23:41:25 +0800</pubDate><guid>https://dwye.dev/post/venv-jupyter/</guid><description>&lt;p>因為交作業要有特定套件，但調參數還是用 Jupyter 方便，所以就研究了下怎麼用特定的 Python 來執行 Jupyter Notebook 或是 JupyterLab。方法有兩種，首先我們先從創建虛擬環境講起：&lt;/p>
&lt;h2 id="準備">準備&lt;/h2>
&lt;h3 id="創建虛擬環境">創建虛擬環境&lt;/h3>
&lt;p>這邊以 conda 為例：&lt;/p></description></item></channel></rss>