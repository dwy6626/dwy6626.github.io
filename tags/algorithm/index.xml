<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on dw's 小站</title><link>https://dwye.dev/tags/algorithm/</link><description>Recent content in Algorithm on dw's 小站</description><generator>Hugo -- gohugo.io</generator><copyright>&amp;copy; 2020. All rights reserved.</copyright><lastBuildDate>Tue, 30 Mar 2021 20:18:25 +0800</lastBuildDate><atom:link href="https://dwye.dev/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 費氏數列解法（二）：矩陣解</title><link>https://dwye.dev/post/python-fibonacci-2/</link><pubDate>Tue, 30 Mar 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci-2/</guid><description>在上篇我們討論了費氏數列的各種基本解法。 原本我也以為 O(n) 的迭代解就已經是標準解法了，直到被大神朋友指正： 問費氏數列應該是想聽 $O(\lg n)$ 解法吧？ 查了一下還真的有，這篇文章寫得蠻完整的，這篇會參考該篇文章來撰寫，但會用我自己的話以及 Python 寫出來。 哪來的矩陣？ $$ \begin{bmatrix} F(n)\\ F(n-1) \end{bmatrix} = \begin{bmatrix} F(n-1) + F(n-2) \\ F(n-1) \end{bmatrix} = \begin{bmatrix} 1 &amp;amp; 1\\ 1 &amp;amp; 0 \end{bmatrix} \begin{bmatrix} F(n-1)\\ F(n-2) \end{bmatrix} $$ 其實就是將上篇的尾遞迴方法及迭代法中每次的運算內容，使用矩陣乘法表達出來。 有了矩陣可以幹嘛（公式推導） 有了矩陣表示法，對於費氏數列第 n 項 $F(n)$ 就可以表示成： $$ \begin{bmatrix} F(n)\\ F(n-1) \end{bmatrix} = \begin{bmatrix} 1 &amp;amp; 1\\ 1 &amp;amp; 0 \end{bmatrix} &amp;hellip; \begin{bmatrix} 1 &amp;amp; 1\\ 1 &amp;amp; 0 \end{bmatrix}\begin{bmatrix} F(2)\\ F(1) \end{bmatrix}</description></item><item><title>Python 費氏數列解法（一）</title><link>https://dwye.dev/post/python-fibonacci/</link><pubDate>Sun, 28 Mar 2021 20:18:25 +0800</pubDate><guid>https://dwye.dev/post/python-fibonacci/</guid><description>&lt;p>面試被問到的題目，雖然是很基本的題目，但相關延伸也有不少，寫篇文章記錄一下。&lt;/p>
&lt;h2 id="遞迴最基本又直觀的解法">遞迴：最基本又直觀的解法&lt;/h2></description></item><item><title>Python 實作 Disjoint Set 與 Union Find</title><link>https://dwye.dev/post/python-union-find/</link><pubDate>Mon, 22 Feb 2021 18:41:25 +0800</pubDate><guid>https://dwye.dev/post/python-union-find/</guid><description>使用情境 在 Leetcode 寫到一題： 1319. Number of Operations to Make Network Connected 現在有 n 台電腦以及一些 cables 將電腦點對點連接，問需要移動至少幾條 cable 才能讓在所有電腦連成單一網路。 以 graph 的角度來看，電腦就是 nodes，cables 就是 edges。 要將整張 graph 連接起來，至少需要 n-1 個 edges。若一個 graph 裡面有超過 n-1 個 edges，剩下的就是多出來的 edges，可以供我們拿來移動的 edges。 所以第一件事就是要檢查 edges 數量 &amp;gt;= n-1。 當檢查完畢之後，我們有至少 n-1 條 edges，一定可以用這些 edges 將所有 nodes 連接起來。 因為題目只問需要移動幾條 edges，我們可以假設我們</description></item></channel></rss>